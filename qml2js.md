# qml2js

## 序言
qml2js项目基于[qmlweb](https://github.com/qmlweb/qmlweb)内的QMLParser（后面可能会转成使用[acorn的Loose插件](https://github.com/ternjs/acorn/pull/352)来做Parser，参考：[eclipse/cdt/.../acorn-qml](https://github.com/eclipse/cdt/tree/master/qt/org.eclipse.cdt.qt.core/acorn-qml)）基础上另外做的开发，而qmlweb目的是将QtQuick的应用移植到Web上，与qml2js的方向不一致。
由于目标与发展方向与官方不一致，所以这里另外开辟了一个个人维护的仓库。

但理论上qml2js的发展方向是兼容qmlweb，所以如果qmlweb的发展运作正常，qml2js自然能替代qmlweb所能做的。但是qmlweb使用的是原生的HTML而不是基于canvas的绘图方式来进行绘制，所以我个人不是很赞同，因为如果涉及到QtGraphicalEffects方面，会有很大的阻碍，或者说，不可能用原生的HTML去实现。所以qml2js的思路就是把这个东西摆明了说，这是一个QML-HTML包，而不是QtQuick。

个人认为QtQuick在Web环境下最大的优势是QML这么语言而不是QtQuick现有的库，这是一门可以替代HTML+CSS+JS的语言，非常适合现代化应用的开发。如果将QtQuick完全移植，固然可以，但是如果真的要移植，个人认为工作量会巨大。需要一群专注的开发者来进行开发与维护，而目前qmlweb的开发团队是无法满足这个条件的。

所以，我认为可以退而求其次，先不管QtQuick官方现有的库，而是先做好QML to JS这个单纯工具，然后引入HTML开发者更熟悉的HTML包来进行开发，而不是QtQuick那套底层（Item、Image、Text、MouseArea之类的仅仅作为借鉴不完整的引入），如果使用那套来进行开发，无疑会增加现有HTML开发者的学习成本，所以我认为直接引入一个内置的使用映射生成的包，写法遵循HTML标签来实现：
```qml
Body{
    Div{
        /*
            不建议也将会禁止使用HTML已有的布局系统
            但目前QML-HTML不够成熟，所以暂时开放这种写法来妥协一些不成熟所带来的未知问题
            当然，也仅仅是布局系统相关的属性：style.margin .padding .width .height .left .top 等等
         */
        style.marginLeft: "30px" // will be no work

        /*
            个人认为使用QtQuick的布局系统会更有优势
            如果任性地让开发者直接使用HTML现有的样式系统来布局，就无法体验到QtQuick这套布局规则的优秀特性
            而且，如果使用现有的HTML布局系统，固然会增加工作量（如果后面需要将这套QML-HTML移植到原生应用平台上的话，会导致需要去实现一套CSS布局系统，得不偿失）
            追求用最少的API做最多的事情。
        */
        anchors.centerIn: parent
        childrens:[
            "start",
            Div{

            },
            "end"    
        ]
    }
}
```

另外既然是运行在浏览器上面的库，我的目标如下：

* 足够小，以满足手机设备下载速度（无Gzip的情况下控制在30KB以内）
    - 移除(qmlweb)QtQuick等库
    - 分离(qmlweb)Parser，在浏览器上只留一个Runtime，运行的时候下载AST文件即可运行
* 使用ES3实现
    > 我个人的理解，Getter、Setter接口这种东西在做出来后，目的是面向其它开发者的使用，确保接口友好的同时保持安全性的问题。而框架中依旧使用了Getter、Setter来封装接口，这其实是没有必要的，因为框架中只要开发者进行自我约束后，就可以开发出基于ES3的Runtime
    > Parser面向的情况比较特殊，故使用ES5实现，ES3的浏览器中通过添加shim来做支持
    - 满足国内开发需求环境，解决基本兼容性问题
* Console工具
    > 为了方便调试qml文件，我目前的想法是提供一个开发者控制面板，类似Webkit内核浏览器的Console界面：包含一个下拉框来选择对应的QML文件；包含显示面板和带智能提示的输入面板
* Debugger工具
    - 提供map文件，方便在原生控制台中查看、定位源码
    - 提供Debugger面板，配合Console工具来进行调试开发
* 实现Parser工具，可在grunt、glup、cmd等工具中使用
* 无入侵性
    > 以组件为单位，使用者可以将其当成一个模块，放入指定的节点内，也可以直接移除或者销毁。如此一来方便集成到其它框架中使用：你可以用它做一个日历控件，然后编译出一个日历控件函数，这个函数只要有Runtime环境就可以运行，运行的时候只需要提供一个节点或者ID就可以渲染到这个节点中，并返回控制这个组件的一个对象（就像jQ的插件一样）。所以第三方框架中如果要使用qml2js写的组件，只需要简单的一层封装即可
* 定制面向QML2JS组件通讯、数据管理一套工具
    > 幸运的是QML语法中就已经有了类继承的概念
* 维护一个统一标准的、对前端开发者友好的（相对HTML5低学习成本）视觉辅助库。包括动画、滤镜等等
* 高度优化可定制的加载器
    - 编译结果分为： Library + Program 。Program表示从编译入口进入后除了第三方模块以外的模块代码，所以Library意味着第三方模块代码
    - All：单个包模式，Library + Program合成一个包一起下载
    - InNeed：按需加载模式，一个Program包以及异步下载的独立Library
    - Concat：请求合并模式，在InNeed编译基础上，会编译出大量组合包，来实现请求合并。这是针对大量请求的组合Library进行了组合合并，从而减少请求数量，增加请求速度。
    - Custom：自定义模式，基于InNeed。允许开发者自定义自己的依赖下载方法，再次基础上可以使用自己服务器的concat服务

# 需要考虑的问题

**QML到HTML这个阶段，组件使用者肯定有样式定制的需求，这个如何满足？**

>考虑到跨平台的问题，我觉得不应该使用css文件来作为样式包，css只能是作为一个辅助。
>或者说站在组件开发的角度，组件开发者是否觉得组件的样式不应该被改动？
>但如果一组风格开发者和一组功能开发者在协作开发的时候；或者一组风格开发者和多组功能开发者（不同接口风格）协作开发的时候，这个问题应该如何解决？

**包管理的问题，我是否应该维护一个官方的包，或者说是带搜索功能的一个站点？**

**用户对于第三方包应该如何管理与应用应该如何使用？**
>使用统一的包管理工具是下载源码，并使用统一的编译工具进行编译？还是直接导入编译完成的结果来进行使用？（go get还是npm install）还是说有更适合QML的包管理方式？

目前考虑使用类似go get的模块管理方案，方便编译优化，而通用的模块就可以省去下载。
