{"version":3,"sources":["qml2js-parser.min.js","/source/qml2js-parser.min.js"],"names":["global","clone","obj","temp","key","is_letter","ch","UNICODE","letter","test","is_digit","charCodeAt","is_alphanumeric_char","is_unicode_combining_mark","non_spacing_mark","space_combining_mark","is_unicode_connector_punctuation","connector_punctuation","is_identifier_start","is_identifier_char","parse_js_number","num","RE_HEX_NUMBER","parseInt","substr","RE_OCT_NUMBER","RE_DEC_NUMBER","parseFloat","JS_Parse_Error","message","line","col","pos","comment","this","ex","stack","js_error","is_token","token","type","val","value","extractLinesForErrorDiag","text","r","lines","split","i","length","mark","tokenizer","$TEXT","peek","S","charAt","next","signal_eof","EX_EOF","newline_before","find","what","indexOf","start_token","tokline","tokcol","tokpos","is_comment","regex_allowed","HOP","UNARY_POSTFIX","KEYWORDS_BEFORE_EXPRESSION","PUNC_BEFORE_EXPRESSION","ret","nlb","comments_before","skip_whitespace","WHITESPACE_CHARS","read_while","pred","parse_error","err","read_num","prefix","has_e","after_e","has_x","has_dot","valid","isNaN","read_escaped_char","String","fromCharCode","hex_bytes","n","digit","read_string","with_eof_error","quote","read_line_comment","substring","read_multiline_comment","tok","warn","read_name","backslash","name","read_regexp","prev_backslash","regexp","in_class","mods","read_operator","grow","op","bigger","OPERATORS","handle_slash","push","next_token","handle_dot","read_word","word","KEYWORDS","KEYWORDS_ATOM","eof_error","cont","force_regexp","PUNC_CHARS","OPERATOR_CHARS","replace","context","nc","NodeWithToken","str","start","end","qmlweb_parse","document_type","exigent_mode","embed_tokens","is","peeked","input","prev","croak","msg","ctx","eLine","token_error","unexpected","expect_token","expect","punc","can_insert_semicolon","semicolon","as","slice","arguments","parenthesised","expression","add_tokens","maybe_embed_tokens","parser","ast","apply","labeled_statement","label","labels","stat","statement","STATEMENTS_WITH_LABELS","pop","simple_statement","prog1","break_cont","member","in_loop","for_","init","var_","for_in","regular_for","step","lhs","if_","belse","cond","body","block_","a","try_","bcatch","bfinally","vardefs","no_in","const_","new_","args","newexp","expr_atom","expr_list","subscripts","closing","allow_trailing_comma","allow_empty","first","array_","from","to","object_","as_property_name","as_name","function_","expr","allow_calls","curry","make_unary","tag","is_assignable","expr_op","left","min_prec","prec","PRECEDENCE","right","expr_ops","maybe_conditional","yes","maybe_assign","ASSIGNMENT","maybe_qmlelem","undefined","qmlblock","qml_is_element","toUpperCase","qmlstatement","qmlpropdef","objName","propName","in_function","qmldefaultprop","qmlsignaldef","propname","onProp","subname","todo","qmlimport","moduleName","isDottedNotation","version","namespace","qmldocument","imports","root","jsdocument","statements","amIn","s","console","log","switch_block_","in_statement","loop","cur","UNARY_PREFIX","ATOMIC_START_TOKEN","atom","commas","JSResource","f","concat","Function","array_to_hash","Array","prototype","call","characters","array","prop","Object","hasOwnProperty","QMLMethod","src","QMLPropertyDefinition","QMLAliasDefinition","objectName","propertyName","QMLSignalDefinition","params","parameters","QMLMetaPropertyGroup","QMLMetaElement","$class","$children","$on","convertToEngine","tree","walk","walker","walkers","bindout","binding","QMLBinding","toplevel","item","$imports","qmlelem","elem","$defaultProperty","qmlprop","qmlobjdef","property","qmlobj","qmlmethod","qmlaliasdef","string","isList","hasBinding","TypeError","parseQML","parsetree","QmlDocument","ast_walker","_vardefs","defs","MAP","def","_block","out","gen","user","with_walkers","save","block","splice","var","const","try","t","c","throw","new","ctor","switch","branch","break","continue","conditional","e","assign","lvalue","rvalue","dot","function","defun","if","for","for-in","vvar","hash","while","do","return","binary","unary-prefix","unary-postfix","sub","subscript","object","props","p","rx","elements","seq","with","parent","Scope","names","mangled","rev_mangled","cname","refs","uses_with","uses_eval","children","level","ast_add_scope","with_new_scope","current_scope","scope","define","reference","_lambda","is_defun","d","w","having_eval","fixrefs","origin","has","ast_mangle","options","get_mangled","newMangle","except","get_define","defines","extra","next_mangled","with_scope","_scope","set_mangle","at_top","self","best_of","ast1","ast2","gen_code","last_stat","b","aborts","boolean_expr","make_conditional","make_real_conditional","when_constant","warn_unreachable","empty","is_string","node","prepare_ifs","redo_if","fi","e_body","redo_if_lambda","redo_if_block","for_side_effects","handler","stop","$stop","restart","$restart","found","unary","ast_lift_variables","do_body","env","skip","references","unshift","_toplevel","ast_squeeze","negate","not_c","keep_comps","rmblock","tighten","block_type","reduce","forEach","dead_code","has_quit","st","no_warnings","make_seqs","make_if","make_real_if","tmp","_do_while","defaults","is_identifier","last","make_string","ascii_only","dq","sq","to_ascii","code","toString","encode_string","inline_script","make_name","indent","beautify","repeat_string","indent_start","indentation","indent_level","with_indent","incr","add_spaces","join","add_commas","space","parenthesize","make","el","needs_parens","DOT_CALL_NO_PARENS","make_num","m","Math","floor","toLowerCase","exec","make_then","th","make_block","make_function","keyword","must_has_semicolon","make_block_statements","noindent","make_switch_block","newline","has_body","make_1vardef","quote_keys","space_colon","SPLICE_NEEDS_BRACKETS","tr","ca","has_call","co","func","condition","operator","jsp","stmt","split_lines","max_line_length","splits","parse","current_length","last_split","split_here","custom","prev_token","map","RESERVED_WORDS","construct","meta","component","constructors","qdirInfo","engine","qmldirs","Qt","createComponent","url","createObject","dom","className","id","$context","$basePath","applyProperties","createSimpleProperty","getter","setter","QMLProperty","default","changed","$properties","set","get","readOnly","newVal","$canEditReadOnlyProperties","setupGetterSetter","$isComponentRoot","metaObject","objectScope","componentScope","Signal","compile","eval","fromAnimation","$setCustomData","signalName","connect","j","completed","completedAlreadyCalled","unboundMethod","QMLBaseObject","QObject","$draw","isComponentRoot","Component","completedSignals","destruction","attributes","__proto__","constructor","Keys","asteriskPresed","backPressed","backtabPressed","callPressed","cancelPressed","deletePressed","escapePressed","flipPressed","hangupPressed","leftPressed","menuPressed","noPressed","pressed","released","returnPressed","rightPressed","selectPressed","spacePressed","tabPressed","upPressed","volumeDownPressed","volumeUpPressed","yesPressed","getAttributes","QMLColor","round","QMLContext","nameForObject","QMLComponent","$metaObject","jsImports","finalizeImports","js","importDesc","qmlEngine","qrc","jsparse","getUrlContents","importJavascriptInContext","bind","moduleImports","loadImport","loadImports","QMLInteger","QMLItem","$parent","rootElement","document","innerHTML","style","position","top","overflow","createElement","pointerEvents","qml","css","boxSizing","resources","parentChanged","newParent","oldParent","childrenChanged","removeChild","appendChild","updateHGeometry","updateVGeometry","dataChanged","newData","child","xChanged","yChanged","widthChanged","heightChanged","implicitWidthChanged","implicitHeightChanged","focus","setupFocusOnDom","element","updateFocus","hasFocus","activeElement","firstChild","addEventListener","focusChanged","qmlFocus","activeFocus","getElementsByTagName","rootContext","base","$isUsingImplicitWidth","$isUsingImplicitHeight","anchors","leftChanged","rightChanged","topChanged","bottomChanged","horizontalCenterChanged","verticalCenterChanged","fillChanged","centerInChanged","leftMarginChanged","rightMarginChanged","topMarginChanged","bottomMarginChanged","marginsChanged","stateChanged","oldVal","oldState","newState","k","states","actions","$revertActions","action","target","changes","$getAllChanges","change","$actions","origValue","explicit","restoreEntryValues","transition","rating","transitions","curTransition","curRating","reversible","$start","QMLRotation","getConstructor","QMLScale","QMLTranslate","$updateTransform","transform","rotation","scale","filter","transformStyle","axis","x","y","z","angle","xScale","yScale","transformType","operation","MozTransform","webkitTransform","webkitTransformStyle","OTransform","msTransform","msFilter","webkitFilter","MozFilter","rotationChanged","scaleChanged","transformChanged","visibleChanged","visibility","opacityChanged","opacity","clipChanged","zChanged","width","height","implicitHeight","implicitWidth","spacing","margins","visible","state","window","onresize","innerHeight","innerWidth","offsetHeight","offsetWidth","$drawItem","rotRad","PI","rotOffsetX","sin","rotOffsetY","globalAlpha","translate","rotate","restore","QMLList","list","QMLPositioner","spacingChanged","layoutChildren","slotChildrenChanged","animation","$tidyupList","QMLPropertyChanges","QMLVariant","objectId","objectIds","$delete","$Component","disconnect","$updatingGeometry","hC","lM","leftMargin","rM","rightMargin","fill","isConnected","centerIn","horizontalCenter","u","vC","bottom","tM","topMargin","bM","bottomMargin","verticalCenter","toJSON","deps","JSON","stringify","REGEXP_MODIFIERS","RegExp","=","QMLDocument","base54","DIGITS","has_mangled","mname","prior","evaluate","$NOT_CONSTANT","no","Error","lval","ex2","AtTop","v","Splice","o","doit","readExports","eatUntil","recursive","matches","semi","matcher","exports","match","skipExceptions","urlContentCache","xhr","XMLHttpRequest","open","send","status","responseText","readQmlDir","makeurl","path","qmldirFileUrl","qmldir","internals","externals","importJs","filename","Easing","Linear","InQuad","OutQuad","InOutQuad","OutInQuad","InCubic","OutCubic","InOutCubic","OutInCubic","InQuart","OutQuart","InOutQuart","OutInQuart","InQuint","OutQuint","InOutQuint","OutInQuint","InSine","OutSine","InOutSine","OutInSine","InExpo","OutExpo","InOutExpo","OutInExpo","InCirc","OutCirc","InOutCirc","OutInCirc","InElastic","OutElastic","InOutElastic","OutInElastic","InBack","OutBack","InOutBack","OutInBack","InBounce","OutBounce","InOutBounce","OutInBounce","Font","MixedCase","AllUppercase","AllLowercase","SmallCaps","Capitalize","Light","Normal","DemiBold","Bold","Black","includesFile","rgba","g","openUrlExternally","page","executionContext","components","nameIsUrl","file","moredirs","importPathList","error","extractBasePath","$file","resolvedUrl","removeDotSegments","detectedBasePath","currentCaller","caller","maxcount","LeftButton","RightButton","MiddleButton","NoModifier","ShiftModifier","ControlModifier","AltModifier","MetaModifier","KeypadModifier","LeftToRight","RightToLeft","Vertical","Horizontal","Key_Escape","Key_Tab","Key_Backtab","Key_Backspace","Key_Return","Key_Enter","Key_Insert","Key_Delete","Key_Pause","Key_Print","Key_SysReq","Key_Clear","Key_Home","Key_End","Key_Left","Key_Up","Key_Right","Key_Down","Key_PageUp","Key_PageDown","Key_Shift","Key_Control","Key_Meta","Key_Alt","Key_AltGr","Key_CapsLock","Key_NumLock","Key_ScrollLock","Key_F1","Key_F2","Key_F3","Key_F4","Key_F5","Key_F6","Key_F7","Key_F8","Key_F9","Key_F10","Key_F11","Key_F12","Key_F13","Key_F14","Key_F15","Key_F16","Key_F17","Key_F18","Key_F19","Key_F20","Key_F21","Key_F22","Key_F23","Key_F24","Key_F25","Key_F26","Key_F27","Key_F28","Key_F29","Key_F30","Key_F31","Key_F32","Key_F33","Key_F34","Key_F35","Key_Super_L","Key_Super_R","Key_Menu","Key_Hyper_L","Key_Hyper_R","Key_Help","Key_Direction_L","Key_Direction_R","Key_Space","Key_Any","Key_Exclam","Key_QuoteDbl","Key_NumberSign","Key_Dollar","Key_Percent","Key_Ampersant","Key_Apostrophe","Key_ParenLeft","Key_ParenRight","Key_Asterisk","Key_Plus","Key_Comma","Key_Minus","Key_Period","Key_Slash","Key_0","Key_1","Key_2","Key_3","Key_4","Key_5","Key_6","Key_7","Key_8","Key_9","Key_Colon","Key_Semicolon","Key_Less","Key_Equal","Key_Greater","Key_Question","Key_At","Key_A","Key_B","Key_C","Key_D","Key_E","Key_F","Key_G","Key_H","Key_I","Key_J","Key_K","Key_L","Key_M","Key_N","Key_O","Key_P","Key_Q","Key_R","Key_S","Key_T","Key_U","Key_V","Key_W","Key_X","Key_Y","Key_Z","Key_BracketLeft","Key_Backslash","Key_BracketRight","Key_AsciiCircum","Key_Underscore","Key_QuoteLeft","Key_BraceLeft","Key_Bar","Key_BraceRight","Key_AsciiTilde","Key_Back","Key_Forward","Key_Stop","Key_VolumeDown","Key_VolumeUp","Key_VolumeMute","Key_Yes","Key_multiply","Key_add","Key_substract","Key_divide","Key_News","Key_OfficeHome","Key_Option","Key_Paste","Key_Phone","Key_Calendar","Key_Reply","Key_Reload","Key_RotateWindows","Key_RotationPB","Key_RotationKB","Key_Save","Key_Send","Key_Spell","Key_SplitScreen","Key_Support","Key_TaskPane","Key_Terminal","Key_Tools","Key_Travel","Key_Video","Key_Word","Key_Xfer","Key_ZoomIn","Key_ZoomOut","Key_Away","Key_Messenger","Key_WebCam","Key_MailForward","Key_Pictures","Key_Music","Key_Battery","Key_Bluetooth","Key_WLAN","Key_UWB","Key_AudioForward","Key_AudioRepeat","Key_AudioRandomPlay","Key_Subtitle","Key_AudioCycleTrack","Key_Time","Key_Hibernate","Key_View","Key_TopMenu","Key_PowerDown","Key_Suspend","Key_ContrastAdjust","Key_MediaLast","Key_unknown","Key_Call","Key_Camera","Key_CameraFocus","Key_Context1","Key_Context2","Key_Context3","Key_Context4","Key_Flip","Key_Hangup","Key_No","Key_Select","Key_ToggleCallHangup","Key_VoiceDial","Key_LastNumberRedial","Key_Execute","Key_Printer","Key_Play","Key_Sleep","Key_Zoom","Key_Cancel","connectedSlots","signal","slot","thisObj","$connectNotify","callType","$disconnectNotify","GETTER","SETTER","evaluatingProperty","int","real","Number","double","bool","Boolean","color","enum","variant","modules","Main","registerGlobalQmlType","registerQmlType","moduleDescriptor","versions","module","baseClass","inherit","collectConstructorsForModule","mergeObjects","obj1","obj2","mergedObject","perContextConstructors","moduleVersion","moduleAlias","moduleConstructors","oldProto","create","keys","setupGetter","setupSetter","useDefineProperty","defineProperty","configurable","enumerable","JSItemModel","roleNames","setRoleNames","rowsInserted","rowsMoved","rowsRemoved","modelReset","jsData","source","symbolName","AST_Tree","foo_function_scope","properties","operationState","QMLOperationState","Init","bp","QMLEngine","keyCodeToQt","keyCode","keypad","shiftKey","eventToKeyboard","accepted","count","isAutoRepeat","modifiers","ctrlKey","CtrlModifier","altKey","metaKey","charCode","touchHandler","preventDefault","at","layerX","touches","pageX","offsetLeft","layerY","pageY","offsetTop","button","onclick","mousemoveHandler","mouseAreas","l","hoverEnabled","oldMousePos","exited","entered","tick","now","Date","getTime","elapsed","lastTick","tickers","fps","$interval","running","bindedProperties","rootObject","Running","tickerId","setInterval","whenStart","removeEventListener","clearInterval","Idle","whenStop","ensureFileIsLoadedInQrc","qmlparse","basePath","loadFile","loadQMLTree","loadQML","debugTree","$initializePropertyBindings","leadingSlash","segments","segment","importsArray","currentFileDir","qmldirsContents","QtQuick","QtQuick.Controls","entry","nameIsQualifiedModuleName","nameIsDir","content","userAddedModulePaths","probableDirs","diredName","attrname","addImportPath","focusedElement","keyboardSignals","onkeypress","event","eventName","backup","onkeyup","registerProperty","dependantProperties","update","dirpath","userAddedImportPaths","setImportPathList","arrayOfDirs","addModulePath","dirPath","loadComponent","$getTextMetrics","fontCss","canvas","font","metrics","measureText","$resolvePath","$registerStart","$registerStop","$addTicker","$removeTicker","index","size","getWidth","getHeight","$perfDraw","debugConsole","$syncPropertyToRemote","sendToServer","method","generateBodyForPostQuery","ajax","mimeType","queryMimeType","success","xhrReadResponse","saved","objectToUrlEncoded","myEncodeURIComponent","encodeURIComponent","overrideMimeType","onreadystatechange","readyState","DONE","failure","runningRequests","isLoading","setRequestHeader","responseObject","updatePropertiesFromResponseObject","$hasProperty","fetched","fetch","mimetype","remove","destroy","localStorage","getKey","attrName","category","loadProperties","getItem","initializeProperties","emitter","setItem"],"mappings":"CAAA,SCAUA,QD+FV,QAASC,OAAMC,GACX,GAAU,MAAPA,GAA8B,gBAAT,GACpB,MAAOA,EAEX,IAAIC,KAEJ,KAAI,GAAIC,KAAOF,GACXC,EAAKC,GAAOH,MAAMC,EAAIE,GAC1B,OAAOD,GAyJX,QAASE,WAAUC,GACX,MAAOC,SAAQC,OAAOC,KAAKH,GAGnC,QAASI,UAASJ,GAEV,MADAA,GAAKA,EAAGK,WAAW,GACZL,GAAM,IAAY,IAANA,EAG3B,QAASM,sBAAqBN,GACtB,MAAOI,UAASJ,IAAOD,UAAUC,GAGzC,QAASO,2BAA0BP,GAC3B,MAAOC,SAAQO,iBAAiBL,KAAKH,IAAOC,QAAQQ,qBAAqBN,KAAKH,GAGtF,QAASU,kCAAiCV,GAClC,MAAOC,SAAQU,sBAAsBR,KAAKH,GAGlD,QAASY,qBAAoBZ,GACrB,MAAa,KAANA,GAAmB,KAANA,GAAaD,UAAUC,GAGnD,QAASa,oBAAmBb,GACpB,MAAOY,qBAAoBZ,IAChBO,0BAA0BP,IAC1BI,SAASJ,IACTU,iCAAiCV,IAC3B,KAANA,GACM,KAANA,EAInB,QAASc,iBAAgBC,GACjB,MAAIC,eAAcb,KAAKY,GACRE,SAASF,EAAIG,OAAO,GAAI,IAC5BC,cAAchB,KAAKY,GACfE,SAASF,EAAIG,OAAO,GAAI,GAC5BE,cAAcjB,KAAKY,GACfM,WAAWN,GADnB,OAKf,QAASO,gBAAeC,EAASC,EAAMC,EAAKC,EAAKC,GACzCC,KAAKL,QAAUA,EACfK,KAAKJ,KAAOA,EAAO,EACnBI,KAAKH,IAAMA,EACXG,KAAKF,IAAMA,EACXE,KAAKD,QAAUA,EAAUA,EAAU,EACnC,YAEE,MAAME,GACAD,KAAKE,MAAQD,EAAGC,OAQhC,QAASC,UAASR,EAASC,EAAMC,EAAKC,EAAKC,GACnC,KAAM,IAAIL,gBAAeC,EAASC,EAAMC,EAAKC,EAAKC,GAG1D,QAASK,UAASC,EAAOC,EAAMC,GACvB,MAAOF,GAAMC,MAAQA,IAAgB,MAAPC,GAAeF,EAAMG,OAASD,GAGpE,QAASE,0BAAyBC,EAAMd,GAKtC,IAAK,GAHDe,GAAI,GACJC,EAAQF,EAAKG,MAAM,MAEdC,EAAIlB,EAAO,EAAQA,EAAO,GAAZkB,EAAeA,IACtC,GAAIA,GAAK,GAAKA,EAAIF,EAAMG,OAAS,CAC7B,GAAIC,GAASF,GAAKlB,EAAS,KAAO,IAClCe,IAAKK,EAAOF,EAAI,KAAOF,EAAME,GAAK,KAGtC,MAAOH,GAKT,QAASM,WAAUC,GAeX,QAASC,KAAS,MAAOC,GAAEV,KAAKW,OAAOD,EAAEtB,KAEzC,QAASwB,GAAKC,GACN,GAAInD,GAAKgD,EAAEV,KAAKW,OAAOD,EAAEtB,MACzB,IAAIyB,IAAenD,EACX,KAAMoD,OAQd,OAPU,MAANpD,GACIgD,EAAEK,gBAAiB,IACjBL,EAAExB,KACJwB,EAAEvB,IAAM,KAENuB,EAAEvB,IAELzB,EAOf,QAASsD,GAAKC,EAAMJ,GACZ,GAAIzB,GAAMsB,EAAEV,KAAKkB,QAAQD,EAAMP,EAAEtB,IACjC,IAAIyB,GAAqB,IAAPzB,EAAW,KAAM0B,OACnC,OAAO1B,GAGf,QAAS+B,KACDT,EAAEU,QAAUV,EAAExB,KACdwB,EAAEW,OAASX,EAAEvB,IACbuB,EAAEY,OAASZ,EAAEtB,IAGrB,QAASO,GAAMC,EAAME,EAAOyB,GACpBb,EAAEc,cAA0B,YAAR5B,IAAuB6B,IAAIC,cAAe5B,IAClC,WAARF,GAAqB6B,IAAIE,2BAA4B7B,IAC7C,QAARF,GAAkB6B,IAAIG,uBAAwB9B,EAClE,IAAI+B,IACIjC,KAAQA,EACRE,MAAQA,EACRZ,KAAQwB,EAAEU,QACVjC,IAAQuB,EAAEW,OACVjC,IAAQsB,EAAEY,OACVQ,IAAQpB,EAAEK,eAOlB,OALKQ,KACGM,EAAIE,gBAAkBrB,EAAEqB,gBACxBrB,EAAEqB,oBAEVrB,EAAEK,gBAAiB,EACZc,EAGf,QAASG,KACD,KAAOP,IAAIQ,iBAAkBxB,MACrBG,IAGhB,QAASsB,GAAWC,GAEZ,IADA,GAAIN,GAAM,GAAInE,EAAK+C,IAAQL,EAAI,EACxB1C,GAAMyE,EAAKzE,EAAI0C,MACdyB,GAAOjB,IACPlD,EAAK+C,GAEb,OAAOoB,GAGf,QAASO,GAAYC,GACb5C,SAAS4C,EAAK3B,EAAEU,QAASV,EAAEW,OAAQX,EAAEY,OAAQvB,yBAA0BW,EAAEV,KAAMU,EAAEU,UAGzF,QAASkB,GAASC,GACV,GAAIC,IAAQ,EAAOC,GAAU,EAAOC,GAAQ,EAAOC,EAAoB,KAAVJ,EACzD9D,EAAMyD,EAAW,SAASxE,EAAI0C,GAC1B,MAAU,KAAN1C,GAAmB,KAANA,EACLgF,GAAc,EACXA,GAAQ,EAElBA,GAAgB,KAANhF,GAAmB,KAANA,EAIlB,KAANA,KACQ+E,IAAiB,GAALrC,GAAWmC,IAGzB,KAAN7E,EAAkB+E,GACtBA,GAAU,EACA,KAAN/E,EACSiF,GAAYD,GAEV,EADQC,GAAU,EAG1B3E,qBAAqBN,IAdhB8E,GAAc,EACXA,EAAQC,GAAU,GAerCF,KACI9D,EAAM8D,EAAS9D,EACvB,IAAImE,GAAQpE,gBAAgBC,EAC5B,OAAKoE,OAAMD,OAGHR,GAAY,mBAAqB3D,GAF1BkB,EAAM,MAAOiD,GAMpC,QAASE,KACD,GAAIpF,GAAKkD,GAAK,EACd,QAAQlD,GACJ,IAAK,IAAM,MAAO,IAClB,KAAK,IAAM,MAAO,IAClB,KAAK,IAAM,MAAO,GAClB,KAAK,IAAM,MAAO,IAClB,KAAK,IAAM,MAAO,MAClB,KAAK,IAAM,MAAO,IAClB,KAAK,IAAM,MAAO,MAClB,KAAK,IAAM,MAAOqF,QAAOC,aAAaC,EAAU,GAChD,KAAK,IAAM,MAAOF,QAAOC,aAAaC,EAAU,GAChD,KAAK,KAAM,MAAO,EAClB,SAAW,MAAOvF,IAI9B,QAASuF,GAAUC,GAEX,IADA,GAAIzE,GAAM,EACHyE,EAAI,IAAKA,EAAG,CACX,GAAIC,GAAQxE,SAASiC,GAAK,GAAO,GAC7BiC,OAAMM,IACFf,EAAY,2CACpB3D,EAAOA,GAAO,EAAK0E,EAE3B,MAAO1E,GAGf,QAAS2E,KACD,MAAOC,GAAe,+BAAgC,WAE9C,IADA,GAAIC,GAAQ1C,IAAQiB,EAAM,KACjB,CACD,GAAInE,GAAKkD,GAAK,EACd,IAAU,MAANlD,EAAYA,EAAKoF,QAChB,IAAIpF,GAAM4F,EAAO,KACtBzB,IAAOnE,EAEf,MAAOiC,GAAM,SAAUkC,KAIvC,QAAS0B,KACD3C,GACA,IAAoBiB,GAAhBzB,EAAIY,EAAK,KAQb,OAPS,IAALZ,GACIyB,EAAMnB,EAAEV,KAAKpB,OAAO8B,EAAEtB,KACtBsB,EAAEtB,IAAMsB,EAAEV,KAAKK,SAEfwB,EAAMnB,EAAEV,KAAKwD,UAAU9C,EAAEtB,IAAKgB,GAC9BM,EAAEtB,IAAMgB,GAETT,EAAM,WAAYkC,GAAK,GAGtC,QAAS4B,KAED,MADA7C,KACOyC,EAAe,iCAAkC,WAChD,GAAIjD,GAAIY,EAAK,MAAM,GACfhB,EAAOU,EAAEV,KAAKwD,UAAU9C,EAAEtB,IAAKgB,GAC/BsD,EAAM/D,EAAM,WAAYK,GAAM,EAYlC,OAXAU,GAAEtB,IAAMgB,EAAI,EACZM,EAAExB,MAAQc,EAAKG,MAAM,MAAME,OAAS,EACpCK,EAAEK,eAAiBf,EAAKkB,QAAQ,OAAS,EAGrC,WAAWrD,KAAKmC,KACZ2D,KAAK,oBAAsBjD,EAAExB,MAC7ByE,KAAK,oCAAwC3D,GAC7C2D,KAAK,kHAGND,IAIvB,QAASE,KAED,IADA,GAAkClG,GAA9BmG,GAAY,EAAOC,EAAO,GACN,OAAhBpG,EAAK+C,MACL,GAAKoD,EAMa,KAANnG,GAAW0E,EAAY,4CAC3B1E,EAAKoF,IACAvE,mBAAmBb,IAAK0E,EAAY,iBAAmB1E,EAAGK,WAAW,GAAK,+BAC/E+F,GAAQpG,EACRmG,GAAY,MATZ,IAAU,MAANnG,EAAYmG,GAAY,EAAMjD,QAC7B,CAAA,IAAIrC,mBAAmBb,GACvB,KAD4BoG,IAAQlD,IAWzD,MAAOkD,GAGf,QAASC,KACD,MAAOV,GAAe,kCAAmC,WAEjD,IADA,GAAyC3F,GAArCsG,GAAiB,EAAOC,EAAS,GAAQC,GAAW,EAChDxG,EAAKkD,GAAK,IAAQ,GAAIoD,EACtBC,GAAU,KAAOvG,EACjBsG,GAAiB,MAClB,IAAU,KAANtG,EACHwG,GAAW,EACXD,GAAUvG,MACX,IAAU,KAANA,GAAawG,EAChBA,GAAW,EACXD,GAAUvG,MACX,CAAA,GAAU,KAANA,IAAcwG,EACjB,KACS,OAANxG,EACHsG,GAAiB,EAEjBC,GAAUvG,EAElB,GAAIyG,GAAOP,GACX,OAAOjE,GAAM,UAAYsE,EAAQE,MAIjD,QAASC,GAAc7B,GACf,QAAS8B,GAAKC,GACN,IAAK7D,IAAQ,MAAO6D,EACpB,IAAIC,GAASD,EAAK7D,GAClB,OAAIgB,KAAI+C,UAAWD,IACX3D,IACOyD,EAAKE,IAELD,EAGvB,MAAO3E,GAAM,WAAY0E,EAAK9B,GAAU3B,MAGhD,QAAS6D,KACD7D,GACA,IAAIY,GAAgBd,EAAEc,aACtB,QAAQf,KACJ,IAAK,IAGD,MAFAC,GAAEqB,gBAAgB2C,KAAKnB,KACvB7C,EAAEc,cAAgBA,EACXmD,GACX,KAAK,IAGD,MAFAjE,GAAEqB,gBAAgB2C,KAAKjB,KACvB/C,EAAEc,cAAgBA,EACXmD,IAEf,MAAOjE,GAAEc,cAAgBuC,IAAgBK,EAAc,KAG/D,QAASQ,KAED,MADAhE,KACO9C,SAAS2C,KACN6B,EAAS,KACT3C,EAAM,OAAQ,KAGhC,QAASkF,KACD,GAAIC,GAAOlB,GACX,OAAQnC,KAAIsD,SAAUD,GAEZrD,IAAI+C,UAAWM,GACfnF,EAAM,WAAYmF,GAClBrD,IAAIuD,cAAeF,GACnBnF,EAAM,OAAQmF,GACdnF,EAAM,UAAWmF,GALjBnF,EAAM,OAAQmF,GAQhC,QAASzB,GAAe4B,EAAWC,GAC3B,IACQ,MAAOA,KACb,MAAM3F,GACA,GAAIA,IAAOuB,OACN,KAAMvB,EADQ6C,GAAY6C,IAK/C,QAASN,GAAWQ,GACZ,GAAIA,EACI,MAAOpB,IACf/B,KACAb,GACA,IAAIzD,GAAK+C,GACT,OAAK/C,GACDI,SAASJ,GAAY4E,IACf,KAAN5E,GAAmB,KAANA,EAAkB0F,IAC/B3B,IAAI2D,WAAY1H,GAAYiC,EAAM,OAAQiB,KACpC,KAANlD,EAAkBkH,IACZ,KAANlH,EAAkB+G,IAClBhD,IAAI4D,eAAgB3H,GAAY0G,IAC1B,MAAN1G,GAAcY,oBAAoBZ,GAAYmH,QAClDzC,GAAY,yBAA2B1E,EAAK,KAR5BiC,EAAM,OA1S9B,GAAIe,IACIV,KAAkBQ,EAAM8E,QAAQ,0BAA2B,MAAMA,QAAQ,UAAW,IACpFlG,IAAkB,EAClBkC,OAAkB,EAClBpC,KAAkB,EAClBkC,QAAkB,EAClBjC,IAAkB,EAClBkC,OAAkB,EAClBN,gBAAkB,EAClBS,eAAkB,EAClBO,mBAgTR,OALA4C,GAAWY,QAAU,SAASC,GAEtB,MADIA,KAAI9E,EAAI8E,GACL9E,GAGRiE,EA8Df,QAASc,eAAcC,EAAKC,EAAOC,GAC3BtG,KAAKwE,KAAO4B,EACZpG,KAAKqG,MAAQA,EACbrG,KAAKsG,IAAMA,EAOnB,QAASC,cAAarF,EAAOsF,EAAeC,EAAcC,GAelD,QAASC,GAAGrG,EAAME,GACV,MAAOJ,UAASgB,GAAEf,MAAOC,EAAME,GAGvC,QAASW,KAAS,MAAOC,IAAEwF,SAAWxF,GAAEwF,OAASxF,GAAEyF,SAEnD,QAASvF,KAQD,MAPAF,IAAE0F,KAAO1F,GAAEf,MACPe,GAAEwF,QACExF,GAAEf,MAAQe,GAAEwF,OACZxF,GAAEwF,OAAS,MAEXxF,GAAEf,MAAQe,GAAEyF,QAEbzF,GAAEf,MAGjB,QAASyG,KACD,MAAO1F,IAAE0F,KAGjB,QAASC,GAAMC,EAAKpH,EAAMC,EAAKC,GACvB,GAAImH,GAAM7F,GAAEyF,MAAMZ,UACdiB,EAAiB,MAARtH,EAAeA,EAAOqH,EAAInF,OACvC3B,UAAS6G,EACAE,EACO,MAAPrH,EAAcA,EAAMoH,EAAIlF,OACjB,MAAPjC,EAAcA,EAAMmH,EAAIjF,OACxBvB,yBAA0BW,GAAEV,KAAMwG,IAGnD,QAASC,GAAY9G,EAAO2G,GACpBD,EAAMC,EAAK3G,EAAMT,KAAMS,EAAMR,KAGrC,QAASuH,GAAW/G,GACC,MAATA,IACIA,EAAQe,GAAEf,OAClB8G,EAAY9G,EAAO,qBAAuBA,EAAMC,KAAO,KAAOD,EAAMG,MAAQ,KAGpF,QAAS6G,GAAa/G,EAAMC,GACpB,MAAIoG,GAAGrG,EAAMC,GACEe,QAEf6F,GAAY/F,GAAEf,MAAO,oBAAsBe,GAAEf,MAAMC,KAAO,IAAMc,GAAEf,MAAME,IAAM,cAAgBD,EAAO,IAAMC,GAGnH,QAAS+G,GAAOC,GAAQ,MAAOF,GAAa,OAAQE,GAEpD,QAASC,KACD,OAAQf,IACArF,GAAEf,MAAMmC,KAAOmE,EAAG,QAAUA,EAAG,OAAQ,MAIvD,QAASc,KACGd,EAAG,OAAQ,KAAMrF,IACXkG,KAAwBJ,IAG1C,QAASM,KACD,MAAOC,OAAMC,WAGrB,QAASC,KACDP,EAAO,IACP,IAAIrH,GAAK6H,IAET,OADAR,GAAO,KACArH,EAGf,QAAS8H,GAAW3B,EAAKC,EAAOC,GACxB,MAAOF,aAAeD,eAAgBC,EAAM,GAAID,eAAcC,EAAKC,EAAOC,GAGlF,QAAS0B,GAAmBC,GACpB,MAAIvB,GAAqB,WACjB,GAAIL,GAAQjF,GAAEf,MACV6H,EAAMD,EAAOE,MAAMnI,KAAM4H,UAE7B,OADAM,GAAI,GAAKH,EAAWG,EAAI,GAAI7B,EAAOS,KAC5BoB,GAEHD,EAmGpB,QAASG,GAAkBC,GACnBjH,GAAEkH,OAAOlD,KAAKiD,EACd,IAAIhC,GAAQjF,GAAEf,MAAOkI,EAAOC,IAI5B,OAHI/B,KAAiBtE,IAAIsG,uBAAwBF,EAAK,KAC9CnB,EAAWf,GACnBjF,GAAEkH,OAAOI,MACFhB,EAAG,QAASW,EAAOE,GAGlC,QAASI,KACD,MAAOjB,GAAG,OAAQkB,MAAMd,GAAYL,IAG5C,QAASoB,GAAWvI,GACZ,GAAIkE,GAAOmC,EAAG,QAAUvF,GAAEf,MAAMG,MAAQ,IASxC,OARY,OAARgE,GACIlD,IACKwH,OAAOtE,EAAMpD,GAAEkH,SACZvB,EAAM,SAAWvC,EAAO,wCAElB,GAAbpD,GAAE2H,SACHhC,EAAMzG,EAAO,gCACrBmH,IACOC,EAAGpH,EAAMkE,GAGxB,QAASwE,KACD1B,EAAO,IACP,IAAI2B,GAAO,IACX,QAAKtC,EAAG,OAAQ,OACRsC,EAAOtC,EAAG,UAAW,QACVrF,IAAQ4H,GAAK,IACdpB,IAAW,GAAM,GACvBnB,EAAG,WAAY,OACJwC,EAAOF,GAEvBG,EAAYH,GAG3B,QAASG,GAAYH,GACb3B,EAAO,IACP,IAAI/I,GAAOoI,EAAG,OAAQ,KAAO,KAAOmB,IACpCR,GAAO,IACP,IAAI+B,GAAO1C,EAAG,OAAQ,KAAO,KAAOmB,IAEpC,OADAR,GAAO,KACAI,EAAG,MAAOuB,EAAM1K,EAAM8K,EAAMN,EAAQP,KAGnD,QAASW,GAAOF,GACR,GAAIK,GAAiB,OAAXL,EAAK,GAAcvB,EAAG,OAAQuB,EAAK,GAAG,IAAMA,CACtD3H,IACA,IAAItD,GAAM8J,IAEV,OADAR,GAAO,KACAI,EAAG,SAAUuB,EAAMK,EAAKtL,EAAK+K,EAAQP,KAiCpD,QAASe,KACD,GAAgDC,GAA5CC,EAAO5B,IAAiB6B,EAAOlB,IAKnC,OAJI7B,GAAG,UAAW,UACVrF,IACAkI,EAAQhB,MAETd,EAAG,KAAM+B,EAAMC,EAAMF,GAGpC,QAASG,KACDrC,EAAO,IAEP,KADA,GAAIsC,OACIjD,EAAG,OAAQ,MACPA,EAAG,QAAQS,IACfwC,EAAExE,KAAKoD,KAGf,OADAlH,KACOsI,EA6Bf,QAASC,KACD,GAAqBC,GAAQC,EAAzBL,EAAOC,GACX,IAAIhD,EAAG,UAAW,SAAU,CACpBrF,IACAgG,EAAO,KACFX,EAAG,SACAI,EAAM,gBACd,IAAIvC,GAAOpD,GAAEf,MAAMG,KACnBc,KACAgG,EAAO,KACPwC,GAAWtF,EAAMmF,KAQzB,MANIhD,GAAG,UAAW,aACVrF,IACAyI,EAAWJ,KAEdG,GAAWC,GACRhD,EAAM,gCACPW,EAAG,MAAOgC,EAAMI,EAAQC,GAGvC,QAASC,GAAQC,GAET,IADA,GAAIL,QACK,CACIjD,EAAG,SACAS,GACR,IAAI5C,GAAOpD,GAAEf,MAAMG,KAQnB,IAPAc,IACIqF,EAAG,WAAY,MACXrF,IACAsI,EAAExE,MAAOZ,EAAMsD,IAAW,EAAOmC,MAEjCL,EAAExE,MAAOZ,KAEZmC,EAAG,OAAQ,KACR,KACRrF,KAER,MAAOsI,GAGf,QAASV,GAAKe,GACN,MAAOvC,GAAG,MAAOsC,EAAQC,IAGjC,QAASC,KACD,MAAOxC,GAAG,QAASsC,KAG3B,QAASG,KACD,GAA+BC,GAA3BC,EAASC,IAAU,EAOvB,OANI3D,GAAG,OAAQ,MACPrF,IACA8I,EAAOG,EAAU,MAEjBH,KAEDI,EAAW9C,EAAG,MAAO2C,EAAQD,IAAO,GAwCnD,QAASG,GAAUE,EAASC,EAAsBC,GAE1C,IADA,GAAIC,IAAQ,EAAMhB,MACVjD,EAAG,OAAQ8D,KACPG,EAAOA,GAAQ,EAAYtD,EAAO,MAClCoD,IAAwB/D,EAAG,OAAQ8D,KACnC9D,EAAG,OAAQ,MAAQgE,EACff,EAAExE,MAAO,OAAQ,cAEjBwE,EAAExE,KAAK0C,IAAW,GAIlC,OADAxG,KACOsI,EAGf,QAASiB,KACD,GAAIC,GAAO1J,GAAEf,MAAMP,IACfyI,EAAOgC,EAAU,KAAM9D,GAAc,GACrCsE,EAAK3J,GAAEf,MAAMP,GACjB,OAAO4H,GAAG,QAASa,EAAM,IAAMnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAGhE,QAASE,KAED,IADA,GAAIJ,IAAQ,EAAMhB,MACVjD,EAAG,OAAQ,OACPiE,EAAOA,GAAQ,EAAYtD,EAAO,KACjCb,IAAgBE,EAAG,OAAQ,OAFf,CAKjB,GAAIrG,GAAOc,GAAEf,MAAMC,KACfkE,EAAOyG,GACC,SAAR3K,GAA2B,OAARkE,GAAyB,OAARA,GAAmBmC,EAAG,OAAQ,MAG9DW,EAAO,KACPsC,EAAExE,MAAOZ,EAAMsD,IAAW,MAH1B8B,EAAExE,MAAO8F,IAAWC,IAAU,GAAQ3G,IAOtD,MADAlD,KACOoG,EAAG,SAAUkC,GAG5B,QAASqB,KACD,OAAQ7J,GAAEf,MAAMC,MACZ,IAAK,MACL,IAAK,SACD,MAAOsI,OAAMxH,GAAEf,MAAMG,MAAOc,GAEpC,MAAO4J,KAGf,QAASA,KACD,OAAQ9J,GAAEf,MAAMC,MACZ,IAAK,OACL,IAAK,WACL,IAAK,UACL,IAAK,OACD,MAAOsI,OAAMxH,GAAEf,MAAMG,MAAOc,EAChC,SACI8F,KAIhB,QAASoD,GAAWY,EAAMC,GAClB,MAAI1E,GAAG,OAAQ,MACPrF,IACOkJ,EAAW9C,EAAG,MAAO0D,EAAMF,KAAYG,IAElD1E,EAAG,OAAQ,MACPrF,IACOkJ,EAAW9C,EAAG,MAAO0D,EAAMxC,MAAMd,GAAYwD,MAAMhE,EAAQ,OAAQ+D,IAE9EA,GAAe1E,EAAG,OAAQ,MACtBrF,IACOkJ,EAAW9C,EAAG,OAAQ0D,EAAMb,EAAU,OAAO,IAExDc,GAAe1E,EAAG,aAAexE,IAAIC,cAAehB,GAAEf,MAAMG,OACjDoI,MAAM0C,MAAMC,EAAY,gBAAiBnK,GAAEf,MAAMG,MAAO4K,GAClD9J,GAEd8J,EAGf,QAASG,GAAWC,EAAKxG,EAAIoG,GAGrB,MAFW,MAANpG,GAAoB,MAANA,GAAgByG,EAAcL,IACzCrE,EAAM,kBAAoB/B,EAAK,aAChC0C,EAAG8D,EAAKxG,EAAIoG,GAG3B,QAASM,GAAQC,EAAMC,EAAU3B,GACzB,GAAIjF,GAAK2B,EAAG,YAAcvF,GAAEf,MAAMG,MAAQ,IACtCwE,IAAY,MAANA,GAAciF,IAAOjF,EAAK,KACpC,IAAI6G,GAAa,MAAN7G,EAAa8G,WAAW9G,GAAM,IACzC,IAAY,MAAR6G,GAAgBA,EAAOD,EAAU,CAC7BtK,GACA,IAAIyK,GAAQL,EAAQpB,IAAU,GAAOuB,EAAM5B,EAC3C,OAAOyB,GAAQhE,EAAG,SAAU1C,EAAI2G,EAAMI,GAAQH,EAAU3B,GAEhE,MAAO0B,GAGf,QAASK,GAAS/B,GACV,MAAOyB,GAAQpB,IAAU,GAAO,EAAGL,GAG3C,QAASgC,GAAkBhC,GACnB,GAAImB,GAAOY,EAAS/B,EACpB,IAAItD,EAAG,WAAY,KAAM,CACjBrF,GACA,IAAI4K,GAAMpE,IAAW,EAErB,OADAR,GAAO,KACAI,EAAG,cAAe0D,EAAMc,EAAKpE,IAAW,EAAOmC,IAE9D,MAAOmB,GAGf,QAASK,GAAcL,GACf,IAAK3E,EAAc,OAAO,CAC1B,QAAQ2E,EAAK,IACT,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,OACD,OAAO,CACX,KAAK,OACD,MAAkB,QAAXA,EAAK,IAI5B,QAASe,GAAalC,GACd,GAAI0B,GAAOM,EAAkBhC,GAAQ1J,EAAMa,GAAEf,MAAMG,KACnD,IAAImG,EAAG,aAAexE,IAAIiK,WAAY7L,GAAM,CACpC,GAAIkL,EAAcE,GAEV,MADArK,KACOoG,EAAG,SAAU0E,WAAW7L,GAAMoL,EAAMQ,EAAalC,GAEhElD,GAAM,sBAEd,MAAO4E,GAGf,QAASU,GAAcpC,GACf,GAAImB,GAAOe,EAAalC,EACxB,OAAItD,GAAG,OAAQ,KACJe,EAAG,UAAW0D,EAAK,GAAIkB,OAAWC,KACtCnB,EAcf,QAASrC,GAAQnD,GACT,IAEQ,QADExE,GAAE2H,QACGnD,IACb,UACQxE,GAAE2H,SAIpB,QAASyD,GAAepG,GACpB,MAAOA,GAAI,GAAGqG,eAAiBrG,EAAI,GAGvC,QAASmG,KACLjF,EAAO,IAEP,KADA,GAAIsC,OACIjD,EAAG,OAAQ,MACXA,EAAG,QAAQS,IACfwC,EAAExE,KAAKsH,IAGX,OADApF,GAAO,KACAsC,EAgBX,QAAS+C,KACL,GAAIrM,GAAOc,GAAEf,MAAMG,KACnBc,IACA,IAAIkD,GAAOpD,GAAEf,MAAMG,KAEnB,IADAc,IACY,SAARhB,EAAiB,CACjBgH,EAAO,KACFX,EAAG,SAASS,GACjB,IAAIwF,GAAUxL,GAAEf,MAAMG,KAEtB,IADAc,IACIqF,EAAG,OAAQ,KAAM,CACjBrF,IACKqF,EAAG,SAASS,GACjB,IAAIyF,GAAWzL,GAAEf,MAAMG,KACvBc,KAEJ,MAAOoG,GAAG,cAAelD,EAAMoI,EAASC,GAE5C,GAAIlG,EAAG,OAAQ,KAAM,CACjBrF,IACAF,GAAE0L,aACF,IAAIhC,GAAO1J,GAAEf,MAAMP,IACfyI,EAAOC,KACPuC,EAAK3J,GAAEf,MAAMP,GAEjB,OADAsB,IAAE0L,cACKpF,EAAG,aAAclD,EAAMlE,EAAMiI,EAC5BnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAGrC,MAFWnE,GAAG,OAAQ,MAClBrF,IACGoG,EAAG,aAAclD,EAAMlE,GAIlC,QAASyM,KAIL,MAHAzL,KACA+F,EAAa,OAAQ,YAEdK,EAAG,iBAAkBiF,KAGhC,QAASK,KACL,GAAIxI,GAAOpD,GAAEf,MAAMG,KACnBc,IACA,IAAI8I,KACJ,IAAIzD,EAAG,OAAQ,KAAM,CACjBrF,GAEA,KADA,GAAIsJ,IAAQ,GACJjE,EAAG,OAAQ,MAAM,CACbiE,EAAOA,GAAQ,EAAYtD,EAAO,KACjCX,EAAG,SAASS,GACjB,IAAI9G,GAAOc,GAAEf,MAAMG,KACnBc,KACKqF,EAAG,SAASS,IACjBgD,EAAKhF,MAAM9E,KAAMA,EAAMkE,KAAMpD,GAAEf,MAAMG,QACrCc,IAERA,IAIJ,MAFIqF,GAAG,OAAQ,MACXrF,IACGoG,EAAG,eAAgBlD,EAAM4F,GAIpC,QAASsC,KACL,GAAI/F,EAAG,UAAW,YAAa,CAC3B,GAAImE,GAAO1J,GAAEf,MAAMP,GACnBwB,IACA,IAAIiH,GAAO4C,IAAU,GACjBJ,EAAK3J,GAAEf,MAAMP,IACb0E,EAAO+D,EAAK,EAChB,OAAOb,GAAG,YAAalD,EAAM+D,EACzBnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAC1B,GAAInE,EAAG,OAAQ,UAAW,CAE7B,GADArF,IACIqF,EAAG,OAAQ,KAAM,CACjBrF,IACAF,GAAE0L,aACF,IAAIhC,GAAO1J,GAAEf,MAAMP,IACfyI,EAAOC,KACPuC,EAAK3J,GAAEf,MAAMP,GAEjB,OADAsB,IAAE0L,cACKpF,EAAG,UAAWuF,EAAU1E,EAC3BnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAE7B,MAAOkC,KAER,GAAoB,QAAhB5L,GAAEf,MAAMC,KAAgB,CAC/B,GAAI2M,GAAW7L,GAAEf,MAAMG,KAEvB,IADAc,IACgB,YAAZ2L,GAA2C,QAAhB7L,GAAEf,MAAMC,MAAmC,OAAjBc,GAAEf,MAAMG,MAE1D,CAAA,GAAIgM,EAAeS,KAActG,EAAG,OAAQ,KAAM,CAErD,GAAIuG,EAMJ,OALIvG,GAAG,OAAQ,QACXrF,IACA4L,EAAS9L,GAAEf,MAAMG,MACjBc,KAEGoG,EAAG,UAAWuF,EAAUC,EAAQX,KAGvC,GAAI5F,EAAG,OAAQ,KAAM,CAIjBrF,GACA,IAAI6L,GAAU/L,GAAEf,MAAMG,KACtBc,KACAgG,EAAO,KACPlG,GAAE0L,aACF,IAAIhC,GAAO1J,GAAEf,MAAMP,IACfyI,EAAOC,KACPuC,EAAK3J,GAAEf,MAAMP,GAEjB,OADAsB,IAAE0L,cACKpF,EAAG,YAAauF,EAAUE,EAAS5E,EACtCnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAC1B,GAAInE,EAAG,OAAQ,KAClB,MAAOe,GAAG,SAAUuF,EAAUV,IAG9BjF,GAAO,KACPlG,GAAE0L,aACF,IAAIhC,GAAO1J,GAAEf,MAAMP,IACfyI,EAAOC,KACPuC,EAAK3J,GAAEf,MAAMP,GAEjB,OADAsB,IAAE0L,cACKpF,EAAG,UAAWuF,EAAU1E,EAC3BnH,GAAEV,KAAKpB,OAAOwL,EAAMC,EAAKD,IAtCjC,MAAO6B,KAyCR,MAAIhG,GAAG,UAAW,WACdoG,QAEPK,MAIR,QAASC,KAEL/L,GACA,IAAIgM,GAAalM,GAAEf,MAAMG,MACrB+M,EAAoC,QAAhBnM,GAAEf,MAAMC,IAGhC,KAFAgB,IAEOqF,EAAG,OAAQ,MACdrF,IACAgM,GAAc,IAAMlM,GAAEf,MAAMG,MAC5Bc,GAEJ,IAAIqF,EAAG,OAAQ,CACX,GAAI6G,GAAUpM,GAAEf,MAAMG,KACtBc,KAEJ,GAAImM,GAAY,EAMhB,OALI9G,GAAG,OAAQ,QACXrF,IACAmM,EAAYrM,GAAEf,MAAMG,MACpBc,KAEGoG,EAAG,YAAa4F,EAAYE,EAASC,EAAWF,GAG3D,QAASG,KAEL,IADA,GAAIC,MACGhH,EAAG,OAAQ,WACdgH,EAAQvI,KAAKiI,IAEjB,IAAIO,GAAOlB,GAIX,OAHK/F,GAAG,QACJS,IAEGM,EAAG,WAAYiG,EAASC,GAGnC,QAASC,MAEL,IADA,GAAIC,OACInH,EAAG,QACPmH,EAAW1I,KAAKoD,KAEpB,OAAOd,GAAG,aAAcoG,GAG5B,QAASC,IAAKC,GACVC,SAAWA,QAAQC,IAAIF,EAAGjQ,MAAMqD,IAAIA,GAAEf,MAAMC,KAAMc,GAAEf,MAAMG,OAE9D,QAAS4M,MACLW,GAAK,eACLzM,IAzyBJ,GAAIF,KACIV,KAAcQ,EAAM8E,QAAQ,0BAA2B,MAAMA,QAAQ,UAAW,IAChFa,MAA8B,gBAAT3F,GAAoBD,UAAUC,GAAO,GAAQA,EAClEb,MAAc,KACdyG,KAAc,KACdF,OAAc,KACdkG,YAAc,EACd/D,QAAc,EACdT,UAGRlH,IAAEf,MAAQiB,GAwFV,IAAIkH,IAAYR,EAAmB,WAK3B,OAJIrB,EAAG,WAAY,OACXvF,GAAEwF,OAAS,KACXxF,GAAEf,MAAQe,GAAEyF,OAAM,IAElBzF,GAAEf,MAAMC,MACZ,IAAK,MACL,IAAK,SACL,IAAK,SACL,IAAK,WACL,IAAK,OACD,MAAOqI,IAEX,KAAK,OACD,MAAOvI,UAASe,IAAQ,OAAQ,KACtBiH,EAAkBQ,MAAMxH,GAAEf,MAAMG,MAAOc,EAAMA,IAC7CqH,GAEd,KAAK,OACD,OAAQvH,GAAEf,MAAMG,OACZ,IAAK,IACD,MAAOkH,GAAG,QAASiC,IACvB,KAAK,IACL,IAAK,IACD,MAAOhB,IACX,KAAK,IAED,MADArH,KACOoG,EAAG,QACd,SACIN,IAGZ,IAAK,UACD,OAAQwB,MAAMxH,GAAEf,MAAMG,MAAOc,IACzB,IAAK,QACD,MAAOuH,GAAW,QAEtB,KAAK,WACD,MAAOA,GAAW,WAEtB,KAAK,WAED,MADApB,KACOC,EAAG,WAEd,KAAK,KACD,MAAO,UAAUgC,GAET,MADArC,GAAa,UAAW,SACjBK,EAAG,KAAMkB,MAAMf,EAAeJ,GAAYiC,IACtDX,EAAQP,IAEf,KAAK,MACD,MAAOQ,IAEX,KAAK,WACD,MAAOmC,KAAU,EAErB,KAAK,KACD,MAAO5B,IAEX,KAAK,SAGD,MAFqB,IAAjBnI,GAAE0L,aACE/F,EAAM,gCACPW,EAAG,SACAf,EAAG,OAAQ,MACRrF,IAAQ,MACTkG,IACA,KACAoB,MAAMd,GAAYL,GAElC,KAAK,SACD,MAAOC,GAAG,SAAUG,IAAiBsG,KAEzC,KAAK,QACD,MAAOzG,GAAG,QAASkB,MAAMd,GAAYL,GAEzC,KAAK,MACD,MAAOoC,IAEX,KAAK,MACD,MAAOjB,OAAMM,EAAMzB,EAEvB,KAAK,QACD,MAAOmB,OAAMsB,EAAQzC,EAEzB,KAAK,QACD,MAAOC,GAAG,QAASG,IAAiBkB,EAAQP,IAEhD,KAAK,OACD,MAAOd,GAAG,OAAQG,IAAiBW,KAEvC,SACIpB,QA6DpB+D,GAAYnD,EAAmB,SAASoG,GACpC,GAAI5J,GAAOmC,EAAG,QAAUiC,MAAMxH,GAAEf,MAAMG,MAAOc,GAAQ,IAIrD,OAHI8M,KAAiB5J,GACb4C,IACRE,EAAO,KACAI,EAAG0G,EAAe,QAAU,WACzB5J,EAEA,SAAUoG,EAAOhB,GACT,MAAQjD,EAAG,OAAQ,MACPiE,EAAOA,GAAQ,EAAYtD,EAAO,KACjCX,EAAG,SAASS,IACjBwC,EAAExE,KAAKhE,GAAEf,MAAMG,OACfc,GAGR,OADAA,KACOsI,IACZ,MAEH,aACUxI,GAAE0L,WACJ,IAAIuB,GAAOjN,GAAE2H,OACb3H,IAAE2H,QAAU,CACZ,IAAIa,GAAID,GAGR,SAFEvI,GAAE0L,YACJ1L,GAAE2H,QAAUsF,EACLzE,QAwB7BuE,GAAgB7C,MAAMvC,EAAS,WAC3BzB,EAAO,IAEP,KADA,GAAIsC,MAAQ0E,EAAM,MACV3H,EAAG,OAAQ,MACPA,EAAG,QAAQS,IACXT,EAAG,UAAW,SACVrF,IACAgN,KACA1E,EAAExE,MAAO0C,KAAcwG,IACvBhH,EAAO,MAENX,EAAG,UAAW,YACfrF,IACAgG,EAAO,KACPgH,KACA1E,EAAExE,MAAO,KAAMkJ,MAGVA,GAAKlH,IACVkH,EAAIlJ,KAAKoD,MAIzB,OADAlH,KACOsI,IA+DXU,GAAYtC,EAAmB,SAASqD,GACpC,GAAI1E,EAAG,WAAY,OAEX,MADArF,KACO6I,GAEf,IAAIxD,EAAG,aAAexE,IAAIoM,aAAcnN,GAAEf,MAAMG,OACxC,MAAO+K,GAAW,eACA3C,MAAMxH,GAAEf,MAAMG,MAAOc,GACrBgJ,GAAUe,GAEpC,IAAI1E,EAAG,QAAS,CACR,OAAQvF,GAAEf,MAAMG,OACZ,IAAK,IAED,MADAc,KACOkJ,EAAW5B,MAAMd,GAAYwD,MAAMhE,EAAQ,MAAO+D,EAC7D,KAAK,IAED,MADA/J,KACOkJ,EAAWK,IAAUQ,EAChC,KAAK,IAED,MADA/J,KACOkJ,EAAWQ,IAAWK,GAErCjE,IAER,GAAIT,EAAG,UAAW,YAEV,MADArF,KACOkJ,EAAWW,IAAU,GAAQE,EAE5C,IAAIlJ,IAAIqM,mBAAoBpN,GAAEf,MAAMC,MAAO,CACnC,GAAImO,GAAuB,UAAhBrN,GAAEf,MAAMC,KACToH,EAAG,SAAUtG,GAAEf,MAAMG,MAAM,GAAIY,GAAEf,MAAMG,MAAM,IAC7CkH,EAAGtG,GAAEf,MAAMC,KAAMc,GAAEf,MAAMG,MACnC,OAAOgK,GAAW5B,MAAM6F,EAAMnN,GAAO+J,GAE7CjE,MAuJJU,GAAaE,EAAmB,SAAS0G,EAAQzE,GACrB,GAApBrC,UAAU7G,SACN2N,GAAS,EACjB,IAAItD,GAAOiB,EAAcpC,EACzB,OAAIyE,IAAU/H,EAAG,OAAQ,MACjBrF,IACOoG,EAAG,MAAO0D,EAAMtD,IAAW,EAAMmC,KAEzCmB,GAwOf,OAAI5E,KAAkBD,aAAaoI,WACxBd,KAEAH,IAOnB,QAASpC,OAAMsD,GACP,GAAIxE,GAAOzC,MAAMC,UAAW,EAC5B,OAAO,YAAa,MAAOgH,GAAEzG,MAAMnI,KAAMoK,EAAKyE,OAAOlH,MAAMC,cAGnE,QAASgB,OAAMrG,GACHA,YAAeuM,YACXvM,EAAMA,IACd,KAAK,GAAIzB,GAAI,EAAG8C,EAAIgE,UAAU7G,SAAU6C,EAAI,IAAK9C,EACzC8G,UAAU9G,IAClB,OAAOyB,GAGf,QAASwM,eAAcnF,GAEf,IAAK,GADDrH,MACKzB,EAAI,EAAGA,EAAI8I,EAAE7I,SAAUD,EACxByB,EAAIqH,EAAE9I,KAAM,CACpB,OAAOyB,GAGf,QAASoF,OAAMiC,EAAGvD,GACV,MAAO2I,OAAMC,UAAUtH,MAAMuH,KAAKtF,EAAY,MAATvD,EAAgB,EAAIA,GAGjE,QAAS8I,YAAW/I,GACZ,MAAOA,GAAIvF,MAAM,IAGzB,QAASiI,QAAOtE,EAAM4K,GACd,IAAK,GAAItO,GAAIsO,EAAMrO,SAAUD,GAAK,GAC1B,GAAIsO,EAAMtO,KAAO0D,EACT,OAAO,CACvB,QAAO,EAGf,QAASrC,KAAInE,EAAKqR,GACV,MAAOC,QAAOL,UAAUM,eAAeL,KAAKlR,EAAKqR,GAMzD,QAASG,WAAUC,GACfzP,KAAKyP,IAAMA,EASf,QAASC,uBAAsBpP,EAAME,GACjCR,KAAKM,KAAOA,EACZN,KAAKQ,MAAQA,EAGjB,QAASmP,oBAAmB/C,EAASC,GACjC7M,KAAK4P,WAAahD,EAClB5M,KAAK6P,aAAehD,EAQxB,QAASiD,qBAAoBC,GACzB/P,KAAKgQ,WAAaD,EAOtB,QAASE,yBAOT,QAASC,gBAAe5P,EAAM4M,GAC1BlN,KAAKmQ,OAAS7P,EACdN,KAAKoQ,aACLpQ,KAAKqQ,IAAMnD,EAIf,QAASoD,iBAAgBC,GAkIrB,QAASC,GAAKD,GACV,GAAIjQ,GAAOiQ,EAAK,GACZE,EAASC,EAAQpQ,EACrB,OAAKmQ,GAIMA,EAAOtI,MAAM7H,EAAMiQ,EAAK5I,MAAM,QAHrCsG,SAAQC,IAAI,iBAAmB5N,GAUvC,QAASqQ,GAAQJ,EAAMK,GACH,SAAZL,EAAK,KACLA,EAAOA,EAAK,GAChB,IAAIjQ,GAAOiQ,EAAK,GACZE,EAASC,EAAQpQ,EACrB,OAAImQ,GACOA,EAAOtI,MAAM7H,EAAMiQ,EAAK5I,MAAM,IAE9B,GAAIkJ,YAAWD,EAASL,GAhJvC,GAAIG,IACAI,SAAY,SAASnD,EAASnF,GAC1B,GAAIuI,IAASZ,OAAQ,cAGrB,OAFAY,GAAKC,SAAWrD,EAChBoD,EAAKX,WAAcI,EAAKhI,IACjBuI,GAEXE,QAAW,SAASC,EAAMhE,EAAQY,GAC9B,GAAIiD,GAAO,GAAIb,gBAAegB,EAAMhE,EAEpC,KAAK,GAAIpM,KAAKgN,GAAY,CACtB,GAAItF,GAAYsF,EAAWhN,GACvB0D,EAAOgE,EAAU,GACjBjI,EAAMiQ,EAAKhI,EACf,QAAQA,EAAU,IACd,IAAK,iBACDuI,EAAKI,iBAAmB3M,CAC5B,KAAK,UACL,IAAK,aACL,IAAK,cACL,IAAK,YACL,IAAK,eACDuM,EAAKvM,GAAQjE,CACb,MACJ,KAAK,UACDwQ,EAAKX,UAAUhL,KAAK7E,EACpB,MACJ,KAAK,YAEDwQ,EAAKvM,GAAQuM,EAAKvM,IAAS,GAAIyL,sBAC/Bc,EAAKvM,GAAMgE,EAAU,IAAMjI,CAC3B,MACJ,KAAK,SAEDwQ,EAAKvM,GAAQuM,EAAKvM,IAAS,GAAIyL,qBAC/B,KAAK,GAAInP,KAAKP,GACVwQ,EAAKvM,GAAM1D,GAAKP,EAAIO,EACxB,MACJ,SACImN,QAAQC,IAAI,oBAAqB1F,IAQ7C,MAH8B,KAA1BuI,EAAKX,UAAUrP,SACfgQ,EAAKX,UAAYW,EAAKX,UAAU,IAE7BW,GAEXK,QAAW,SAAS5M,EAAM+L,EAAMd,GAC5B,MAAY,MAARjL,EAEO+L,EAAK,GAAG,GAEZI,EAAQJ,EAAMd,IAEzB4B,UAAa,SAAS7M,EAAM8M,EAAUf,EAAMd,GACxC,MAAOkB,GAAQJ,EAAMd,IAEzB8B,OAAU,SAASL,EAAMpD,GACrB,GAAIiD,KAEJ,KAAK,GAAIjQ,KAAKgN,GAAY,CACtB,GAAItF,GAAYsF,EAAWhN,GACvB0D,EAAOgE,EAAU,GACjBjI,EAAMiQ,EAAKhI,EACK,YAAhBA,EAAU,KACVuI,EAAKvM,GAAQjE,GAGrB,MAAOwQ,IAEXS,UAAa,SAAShN,EAAM+L,EAAMd,GAC9B,MAAO,IAAID,WAAUC,IAEzB9C,WAAc,SAASnI,EAAMlE,EAAMiQ,EAAMd,GACrC,MAAO,IAAIC,uBAAsBpP,EAAMiQ,EAAOI,EAAQJ,EAAMd,GAAO,KAEvEgC,YAAe,SAASjN,EAAMoI,EAASC,GACnC,MAAO,IAAI8C,oBAAmB/C,EAASC,IAE3CG,aAAgB,SAASxI,EAAMuL,GAC3B,MAAO,IAAID,qBAAoBC,IAEnChD,eAAkB,SAASwD,GACvB,MAAOC,GAAKD,IAEhB/L,KAAQ,SAASiL,GACb,MAAW,QAAPA,GAAwB,SAAPA,EACH,QAAPA,EACJ,GAAIoB,YAAWpB,GAAM,OAAQA,KAExCtQ,IAAO,SAASsQ,GACZ,OAAQA,GAEZiC,OAAU,SAASjC,GACf,MAAOhM,QAAOgM,IAElBL,MAAS,SAASmB,EAAMd,GACpB,GAAI7F,MACA+H,GAAS,EACTC,GAAa,CACjB,KAAK,GAAI9Q,KAAKyP,GAAM,CAChB,GAAIhQ,GAAMoQ,EAAQJ,EAAKzP,GACvB8I,GAAExE,KAAK7E,GAEHA,YAAe2P,gBACfyB,GAAS,EACJpR,YAAesQ,cACpBe,GAAa,GAGrB,GAAIA,EAAY,CACZ,GAAID,EACA,KAAM,IAAIE,WAAU,+DACxB,OAAO,IAAIhB,YAAWpB,EAAKc,GAG/B,MAAO3G,IAef,OAAO4G,GAAKD,GAkBhB,QAASuB,UAASrC,GACd,GAAIsC,GAAYxL,aAAakJ,EAAKlJ,aAAayL,YAC/C,OAAO1B,iBAAgByB,GA+F3B,QAASE,YAAW/J,GACZ,QAASgK,GAASC,GACV,OAASnS,KAAK,GAAIoS,IAAID,EAAM,SAASE,GAC7B,GAAIzI,IAAMyI,EAAI,GAGd,OAFIA,GAAItR,OAAS,IACT6I,EAAE,GAAK4G,EAAK6B,EAAI,KACjBzI,KAGvB,QAAS0I,GAAOxE,GACR,GAAIyE,IAAQvS,KAAK,GAGjB,OAFkB,OAAd8N,GACIyE,EAAInN,KAAKgN,IAAItE,EAAY0C,IAC1B+B,EA6Hf,QAAS/B,GAAKtI,GACN,GAAW,MAAPA,EACI,MAAO,KACf,KACQhI,EAAMkF,KAAK8C,EACX,IAAI5H,GAAO4H,EAAI,GACXsK,EAAMC,EAAKnS,EACf,IAAIkS,EAAK,CACD,GAAIjQ,GAAMiQ,EAAIrK,MAAMD,EAAKA,EAAIP,MAAM,GACnC,IAAW,MAAPpF,EACI,MAAOA,GAGvB,MADAiQ,GAAM9B,EAAQpQ,GACPkS,EAAIrK,MAAMD,EAAKA,EAAIP,MAAM,IACtC,QACMzH,EAAMwI,OAItB,QAASgK,GAAahC,EAAS9K,GACvB,GAAe9E,GAAX6R,IACJ,KAAK7R,IAAK4P,GAAavO,IAAIuO,EAAS5P,KAC5B6R,EAAK7R,GAAK2R,EAAK3R,GACf2R,EAAK3R,GAAK4P,EAAQ5P,GAE1B,IAAIyB,GAAMqD,GACV,KAAK9E,IAAK6R,GAAUxQ,IAAIwQ,EAAM7R,KACjB6R,EAAK7R,GACL2R,EAAK3R,GAAK6R,EAAK7R,SADC2R,GAAK3R,GAGlC,OAAOyB,GAzJf,GAAImO,IACIgB,OAAU,SAAStL,GACX,OAASpG,KAAK,GAAIoG,IAE1BjH,IAAO,SAASA,GACR,OAASa,KAAK,GAAIb,IAE1BqF,KAAQ,SAASA,GACT,OAASxE,KAAK,GAAIwE,IAE1BsM,SAAY,SAAShD,GACb,OAAS9N,KAAK,GAAIoS,IAAItE,EAAY0C,KAE1CoC,MAASN,EACTO,OAAUP,EACVQ,MAAOZ,EACPa,QAASb,EACTc,MAAO,SAASC,EAAGC,EAAGtE,GACd,OACQ5O,KAAK,GACLoS,IAAIa,EAAGzC,GACF,MAAL0C,GAAcA,EAAE,GAAId,IAAIc,EAAE,GAAI1C,IAAU,KACnC,MAAL5B,EAAYwD,IAAIxD,EAAG4B,GAAQ,OAG3C2C,QAAS,SAAS/H,GACV,OAASpL,KAAK,GAAIwQ,EAAKpF,KAE/BgI,MAAO,SAASC,EAAMjJ,GACd,OAASpK,KAAK,GAAIwQ,EAAK6C,GAAOjB,IAAIhI,EAAMoG,KAEhD8C,SAAU,SAASlI,EAAM1B,GACjB,OAAS1J,KAAK,GAAIwQ,EAAKpF,GAAOgH,IAAI1I,EAAM,SAAS6J,GACzC,OAASA,EAAO,GAAK/C,EAAK+C,EAAO,IAAM,KAC9BnB,IAAImB,EAAO,GAAI/C,QAGxCgD,QAAS,SAASnL,GACV,OAASrI,KAAK,GAAIqI,IAE1BoL,WAAY,SAASpL,GACb,OAASrI,KAAK,GAAIqI,IAE1BqL,YAAe,SAASjK,EAAMwJ,EAAGU,GACzB,OAAS3T,KAAK,GAAIwQ,EAAK/G,GAAO+G,EAAKyC,GAAIzC,EAAKmD,KAEpDC,OAAU,SAAS5O,EAAI6O,EAAQC,GACvB,OAAS9T,KAAK,GAAIgF,EAAIwL,EAAKqD,GAASrD,EAAKsD,KAEjDC,IAAO,SAAS3I,GACR,OAASpL,KAAK,GAAIwQ,EAAKpF,IAAQyD,OAAOlH,MAAMC,UAAW,KAE/DsH,KAAQ,SAAS9D,EAAMhB,GACf,OAASpK,KAAK,GAAIwQ,EAAKpF,GAAOgH,IAAIhI,EAAMoG,KAEhDwD,WAAY,SAASxP,EAAM4F,EAAMV,GACzB,OAAS1J,KAAK,GAAIwE,EAAM4F,EAAKzC,QAASyK,IAAI1I,EAAM8G,KAExDyD,MAAS,SAASzP,EAAM4F,EAAMV,GACtB,OAAS1J,KAAK,GAAIwE,EAAM4F,EAAKzC,QAASyK,IAAI1I,EAAM8G,KAExD0D,KAAM,SAASR,EAAaT,EAAGU,GACvB,OAAS3T,KAAK,GAAIwQ,EAAKkD,GAAclD,EAAKyC,GAAIzC,EAAKmD,KAE3DQ,MAAO,SAASlL,EAAMQ,EAAMJ,EAAMuJ,GAC1B,OAAS5S,KAAK,GAAIwQ,EAAKvH,GAAOuH,EAAK/G,GAAO+G,EAAKnH,GAAOmH,EAAKoC,KAEnEwB,SAAU,SAASC,EAAMnW,EAAKoW,EAAM1B,GAC5B,OAAS5S,KAAK,GAAIwQ,EAAK6D,GAAO7D,EAAKtS,GAAMsS,EAAK8D,GAAO9D,EAAKoC,KAElE2B,QAAS,SAAS9K,EAAMmJ,GAChB,OAAS5S,KAAK,GAAIwQ,EAAK/G,GAAO+G,EAAKoC,KAE3C4B,KAAM,SAAS/K,EAAMmJ,GACb,OAAS5S,KAAK,GAAIwQ,EAAK/G,GAAO+G,EAAKoC,KAE3C6B,SAAU,SAASrJ,GACX,OAASpL,KAAK,GAAIwQ,EAAKpF,KAE/BsJ,OAAU,SAAS1P,EAAI2G,EAAMI,GACrB,OAAS/L,KAAK,GAAIgF,EAAIwL,EAAK7E,GAAO6E,EAAKzE,KAE/C4I,eAAgB,SAAS3P,EAAIoG,GACrB,OAASpL,KAAK,GAAIgF,EAAIwL,EAAKpF,KAEnCwJ,gBAAiB,SAAS5P,EAAIoG,GACtB,OAASpL,KAAK,GAAIgF,EAAIwL,EAAKpF,KAEnCyJ,IAAO,SAASzJ,EAAM0J,GACd,OAAS9U,KAAK,GAAIwQ,EAAKpF,GAAOoF,EAAKsE,KAE3CC,OAAU,SAASC,GACX,OAAShV,KAAK,GAAIoS,IAAI4C,EAAO,SAASC,GAC9B,MAAmB,IAAZA,EAAElU,QACGkU,EAAE,GAAIzE,EAAKyE,EAAE,MACbA,EAAE,GAAIzE,EAAKyE,EAAE,IAAKA,EAAE,QAGhDtQ,OAAU,SAASuQ,EAAIrQ,GACf,OAAS7E,KAAK,GAAIkV,EAAIrQ,IAE9BuK,MAAS,SAAS+F,GACV,OAASnV,KAAK,GAAIoS,IAAI+C,EAAU3E,KAExCjI,KAAQ,SAASA,GACT,OAASvI,KAAK,GAAIwQ,EAAKjI,KAE/B6M,IAAO,WACC,OAASpV,KAAK,IAAK6O,OAAOuD,IAAIzK,MAAMC,WAAY4I,KAExDnI,MAAS,SAAS7D,EAAMoO,GAChB,OAAS5S,KAAK,GAAIwE,EAAMgM,EAAKoC,KAErCyC,OAAQ,SAASjK,EAAMwH,GACf,OAAS5S,KAAK,GAAIwQ,EAAKpF,GAAOoF,EAAKoC,KAE3CnE,KAAQ,SAASjK,GACT,OAASxE,KAAK,GAAIwE,KAI9BiO,KACAvS,IAkCJ,QACQsQ,KAAMA,EACNkC,aAAcA,EACd4C,OAAQ,WACA,MAAOpV,GAAMA,EAAMa,OAAS,IAEpCb,MAAO,WACC,MAAOA,KAO/B,QAASqV,OAAMD,GACPtV,KAAKwV,SACLxV,KAAKyV,WACLzV,KAAK0V,eACL1V,KAAK2V,MAAQ,GACb3V,KAAK4V,QACL5V,KAAK6V,WAAY,EACjB7V,KAAK8V,WAAY,EACjB9V,KAAKsV,OAASA,EACdtV,KAAK+V,YACDT,GACItV,KAAKgW,MAAQV,EAAOU,MAAQ,EAC5BV,EAAOS,SAAS3Q,KAAKpF,OAErBA,KAAKgW,MAAQ,EAkG7B,QAASC,eAAc/N,GAMf,QAASgO,GAAetQ,GAChBuQ,EAAgB,GAAIZ,OAAMY,EAC1B,IAAI5T,GAAM4T,EAAczM,KAAO9D,GAG/B,OAFArD,GAAI6T,MAAQD,EACZA,EAAgBA,EAAcb,OACvB/S,EAGf,QAAS8T,GAAO7R,EAAMlE,GACd,MAAO6V,GAAcE,OAAO7R,EAAMlE,GAG1C,QAASgW,GAAU9R,GACX2R,EAAcP,KAAKpR,IAAQ,EAGnC,QAAS+R,GAAQ/R,EAAM4F,EAAMV,GACrB,GAAI8M,GAAsB,SAAXxW,KAAK,EACpB,QAASA,KAAK,GAAIwW,EAAWH,EAAO7R,EAAM,SAAWA,EAAM4F,EAAM8L,EAAe,WAGxE,MAFKM,IAAUH,EAAO7R,EAAM,UAC5B4N,IAAIhI,EAAM,SAAS5F,GAAO6R,EAAO7R,EAAM,SAChC4N,IAAI1I,EAAM8G,MAIjC,QAAS0B,GAAS5R,GACV,MAAO,UAAS6R,GACRC,IAAID,EAAM,SAASsE,GACXJ,EAAOI,EAAE,GAAInW,GACTmW,EAAE,IAAIH,EAAUG,EAAE,OAjC9C,GAAIN,GAAgB,KAChBO,EAAIzE,aAAczB,EAAOkG,EAAElG,KAC3BmG,IAoCJ,OAAOT,GAAe,WA+Cd,QAASU,GAAQR,EAAOtV,GAEhB,IAAKA,EAAIsV,EAAML,SAAShV,SAAUD,GAAK,GAC/B8V,EAAQR,EAAML,SAASjV,GAC/B,KAAKA,IAAKsV,GAAMR,KAAM,GAAIzT,IAAIiU,EAAMR,KAAM9U,GAElC,IAAK,GAAI+V,GAAST,EAAMU,IAAIhW,GAAIkN,EAAIoI,EAAOpI,IACnCA,EAAE4H,KAAK9U,GAAK+V,EACR7I,IAAM6I,GAF4B7I,EAAIA,EAAEsH,SAnDpE,GAAI/S,GAAMmU,EAAEhE,cACJsB,WAAYuC,EACZtC,MAASsC,EACTlO,MAAS,SAAS7D,EAAM+D,GAAQ8N,EAAO7R,EAAM,UAC7CgP,QAAS,SAASnL,GAAaA,GAAOiO,EAAUjO,IAChDoL,WAAY,SAASpL,GAAaA,GAAOiO,EAAUjO,IACnDgN,OAAQ,SAASjK,EAAMwH,GACf,IAAK,GAAI5E,GAAImI,EAAenI,EAAGA,EAAIA,EAAEsH,OAC7BtH,EAAE6H,WAAY,GAE9B/C,MAAOZ,EAAS,OAChBa,QAASb,EAAS,SAClBc,MAAO,SAASC,EAAGC,EAAGtE,GACd,MAAS,OAALsE,GACIlT,KAAK,GACLoS,IAAIa,EAAGzC,IACL6F,EAAOnD,EAAE,GAAI,SAAUd,IAAIc,EAAE,GAAI1C,IAC9B,MAAL5B,EAAYwD,IAAIxD,EAAG4B,GAAQ,MAJnC,QAORhM,KAAQ,SAASA,GACG,QAARA,GACImS,EAAYvR,KAAK+Q,GACzBG,EAAU9R,KAEvB,WACK,MAAOgM,GAAKtI,IAiCpB,OAxBAkK,KAAIuE,EAAa,SAASP,GAClB,IAAKA,EAAMU,IAAI,QAAS,KAAOV,GACvBA,EAAMN,WAAY,EAClBM,EAAQA,EAAMd,SAmB9BsB,EAAQT,GAED5T,IAOvB,QAASwU,YAAW7O,EAAK8O,GAIjB,QAASC,GAAYzS,EAAM0S,GACnB,MAAKF,GAAQlG,UAAasF,EAAMd,OAC5B0B,EAAQG,QAAUrO,OAAOtE,EAAMwS,EAAQG,QAC5B3S,EACR4R,EAAMa,YAAYzS,EAAM0S,GAHgB1S,EAMvD,QAAS4S,GAAW5S,GACZ,MAAIwS,GAAQK,SAGCjB,EAAMU,IAAItS,IACHrC,IAAI6U,EAAQK,QAAS7S,GACVwS,EAAQK,QAAQ7S,GAGhC,KARf,OAYR,QAAS+R,GAAQ/R,EAAM4F,EAAMV,GACrB,GAAmC4N,GAA/Bd,EAAsB,SAAXxW,KAAK,EAepB,OAdIwE,KACQgS,EAAUhS,EAAOyS,EAAYzS,IAEzB8S,KACMlB,EAAMN,WAAaM,EAAMP,UAGvByB,EAAM9S,GAAQA,EAFdA,EAAO8S,EAAM9S,GAAQ4R,EAAMmB,iBAKnD7N,EAAO8N,EAAW9N,EAAK0M,MAAO,WAEtB,MADAhM,GAAOgI,IAAIhI,EAAM,SAAS5F,GAAO,MAAOyS,GAAYzS,KAC7C4N,IAAI1I,EAAM8G,IACtB8G,IACMtX,KAAK,GAAIwE,EAAM4F,EAAMV,GAGtC,QAAS8N,GAAWxJ,EAAGpI,EAAM0R,GACrB,GAAIG,GAASrB,CAEb,IADAA,EAAQpI,EACJsJ,EAAO,IAAK,GAAIxW,KAAKwW,GAAWnV,IAAImV,EAAOxW,IACvCkN,EAAE0J,WAAW5W,EAAGwW,EAAMxW,GAE9B,KAAK,GAAIA,KAAKkN,GAAEwH,MAAWrT,IAAI6L,EAAEwH,MAAO1U,IAChCmW,EAAYnW,GAAG,EAEvB,IAAIyB,GAAMqD,GAGV,OAFArD,GAAI6T,MAAQpI,EACZoI,EAAQqB,EACDlV,EAGf,QAAS2P,GAASC,GACV,OAASnS,KAAK,GAAIoS,IAAID,EAAM,SAASsE,GAC7B,OAASQ,EAAYR,EAAE,IAAKjG,EAAKiG,EAAE,QA3DnD,GAAqCL,GAAjCM,EAAIzE,aAAczB,EAAOkG,EAAElG,IA+D/B,OA9DAwG,GAAUA,MA8DHN,EAAEhE,cACDsB,WAAYuC,EACZtC,MAAS,WAGD,GAAI/L,GAAMqO,EAAQpO,MAAMnI,KAAM4H,UAC9B,QAAQ8O,EAAEpB,SAAS,IACf,IAAK,WACL,IAAK,WACL,IAAK,QACD,MAAOlD,KAAIuF,OAAOzP,GAE1B,MAAOA,IAEfG,MAAS,SAASA,EAAOE,GAAQ,OAASvI,KAAK,GAAIiX,EAAY5O,GAAQmI,EAAKjI,KAC5EiL,QAAS,SAASnL,GAAS,MAAIA,IAAgBrI,KAAK,GAAIiX,EAAY5O,IAAzC,QAC3BoL,WAAY,SAASpL,GAAS,MAAIA,IAAgBrI,KAAK,GAAIiX,EAAY5O,IAAzC,QAC9ByK,MAAOZ,EACPa,QAASb,EACT1N,KAAQ,SAASA,GACT,MAAO4S,GAAW5S,KAAWxE,KAAK,GAAIiX,EAAYzS,KAE1DwO,MAAO,SAASC,EAAGC,EAAGtE,GACd,OAAS5O,KAAK,GACLoS,IAAIa,EAAGzC,GACF,MAAL0C,GAAc+D,EAAY/D,EAAE,IAAKd,IAAIc,EAAE,GAAI1C,IAAU,KAChD,MAAL5B,EAAYwD,IAAIxD,EAAG4B,GAAQ,OAE5CM,SAAY,SAASpH,GACb,GAAIkO,GAAO5X,IACX,OAAOwX,GAAWI,EAAKxB,MAAO,WACtB,OAASwB,EAAK,GAAIxF,IAAI1I,EAAM8G,QAGjD,WACK,MAAOA,GAAKyF,cAAc/N,MAiB1C,QAAS2P,SAAQC,EAAMC,GACf,MAAOC,UAASF,GAAM/W,OAASiX,SAAoB,QAAXD,EAAK,GAAeA,EAAK,GAAKA,GAAMhX,OAASgX,EAAOD,EAGpG,QAASG,WAAUC,GACX,MAAY,SAARA,EAAE,IAAiBA,EAAE,IAAMA,EAAE,GAAGnX,OAAS,EAC9BmX,EAAE,GAAGA,EAAE,GAAGnX,OAAS,GAC3BmX,EAGf,QAASC,QAAOlF,GACR,GAAIA,EAAG,OAAQgF,UAAUhF,GAAG,IACxB,IAAK,SACL,IAAK,QACL,IAAK,WACL,IAAK,QACD,OAAO,GAIvB,QAASmF,cAAahN,GACd,MAAqB,gBAAXA,EAAK,IACFtC,OAAOsC,EAAK,IAAM,IAAK,YAEf,UAAXA,EAAK,IACFtC,OAAOsC,EAAK,IAAM,KAAM,aAAc,KAAM,KAAM,MAAO,MAAO,IAAK,KAAM,KAAM,OAEzE,UAAXA,EAAK,IACFtC,OAAOsC,EAAK,IAAM,KAAM,QACxBgN,aAAahN,EAAK,KAClBgN,aAAahN,EAAK,KAEV,eAAXA,EAAK,IACFgN,aAAahN,EAAK,KAClBgN,aAAahN,EAAK,KAEV,UAAXA,EAAK,IACFA,EAAK,MAAO,GACZgN,aAAahN,EAAK,KAEV,OAAXA,EAAK,IACFgN,aAAahN,EAAKA,EAAKrK,OAAS,IAIrD,QAASsX,kBAAiBnF,EAAGD,EAAGU,GAC5B,GAAI2E,GAAwB,WACxB,MAAY,gBAARpF,EAAE,IAAgC,KAARA,EAAE,GACrBS,GAAM,cAAeT,EAAE,GAAIS,EAAGV,IAAQ,SAAU,KAAMC,EAAE,GAAID,GAE5DU,GAAM,cAAeT,EAAGD,EAAGU,IAAQ,SAAU,KAAMT,EAAGD,GAIrE,OAAOsF,eAAcrF,EAAG,SAAShL,EAAK3H,GAElC,MADAiY,kBAAiBjY,EAAMoT,EAAIV,GACV1S,EAAM0S,EAAIU,GAC5B2E,GAGP,QAASG,OAAMP,GACP,OAAQA,GAAc,SAARA,EAAE,MAAmBA,EAAE,IAAqB,GAAfA,EAAE,GAAGnX,QAGxD,QAAS2X,WAAUC,GACX,MAAmB,UAAXA,EAAK,IACM,gBAAXA,EAAK,IAAmC,UAAXA,EAAK,IACvB,UAAXA,EAAK,IAA6B,KAAXA,EAAK,KAC3BD,UAAUC,EAAK,KAAOD,UAAUC,EAAK,KAkGtD,QAASH,kBAAiBtQ,GACbuQ,MAAMvQ,IACH7D,KAAK,8BAAgC2T,SAAS9P,GAAK,IAGnE,QAAS0Q,aAAY1Q,GAmBb,QAAS2Q,GAAQ/K,GACTA,EAAasE,IAAItE,EAAY0C,EAE7B,KAAK,GAAI1P,GAAI,EAAGA,EAAIgN,EAAW/M,SAAUD,EAAG,CACpC,GAAIgY,GAAKhL,EAAWhN,EACpB,MAAa,MAATgY,EAAG,IAEHA,EAAG,IAAMtI,EAAKsI,EAAG,KAArB,CAEA,GAAI7F,GAAIzC,EAAKsI,EAAG,GAChB,IAAKX,OAAOlF,GAAZ,CAEA,GAAIS,GAAclD,EAAKsI,EAAG,IAEtBC,EAASjL,EAAWnG,MAAM7G,EAAI,GAC9B6S,EAAqB,GAAjBoF,EAAOhY,OAAcgY,EAAO,IAAO,QAASA,GAEhDxW,EAAMuL,EAAWnG,MAAM,EAAG7G,GAAG+N,SACzBiK,EAAG,GACHpF,EACAT,EACAU,IAGR,OAAOkF,GAAQtW,KAGvB,MAAOuL,GAGf,QAASkL,GAAexU,EAAM4F,EAAMV,GAE5B,MADAA,GAAOmP,EAAQnP,IACN1J,KAAK,GAAIwE,EAAM4F,EAAMV,GAGtC,QAASuP,GAAcnL,GACf,OAAS9N,KAAK,GAAkB,MAAd8N,EAAqB+K,EAAQ/K,GAAc,MAtDrE,GAAI4I,GAAIzE,aAAczB,EAAOkG,EAAElG,IAyD/B,OAAOkG,GAAEhE,cACDuB,MAAS+E,EACThF,WAAYgF,EACZpG,MAASqG,EACTpG,OAAUoG,EACVnI,SAAY,SAAShD,GACb,OAAS9N,KAAK,GAAI6Y,EAAQ/K,KAElCkF,MAAO,SAASC,EAAGC,EAAGtE,GACd,OACQ5O,KAAK,GACL6Y,EAAQ5F,GACH,MAALC,GAAcA,EAAE,GAAI2F,EAAQ3F,EAAE,KAAQ,KACjC,MAALtE,EAAYiK,EAAQjK,GAAK,QAG9C,WACK,MAAO4B,GAAKtI,KAI5B,QAASgR,kBAAiBhR,EAAKiR,GAGvB,QAASC,KAAS,KAAMC,GACxB,QAASC,KAAY,KAAMC,GAC3B,QAASC,KAAS,MAAOL,GAAQjK,KAAKlP,KAAMA,KAAM0W,EAAG0C,EAAME,GAC3D,QAASG,GAAMzU,GACP,MAAU,MAANA,GAAoB,MAANA,EACHwU,EAAMrR,MAAMnI,KAAM4H,WADjC,OANR,GAAI8O,GAAIzE,aAAczB,EAAOkG,EAAElG,KAC3B6I,KAAYE,IAQhB,OAAO7C,GAAEhE,cACDM,MAAOwG,EACPrG,QAASqG,EACT/E,SAAU+E,EACVpG,MAAOoG,EACPlG,SAAUkG,EACVhG,QAASgG,EACT/F,WAAY+F,EACZ5F,OAAU4F,EACVtK,KAAQsK,EACRtF,KAAMsF,EACNrF,MAAOqF,EACPpF,SAAUoF,EACVjF,QAASiF,EACThF,KAAMgF,EACN/E,SAAU+E,EACV7E,eAAgB8E,EAChB7E,gBAAiB6E,EACjBxF,MAASuF,GACd,WACK,OAAa,IACLhJ,EAAKtI,EACL,OACN,MAAMjI,GACA,GAAIA,IAAOoZ,EAAO,KAClB,IAAIpZ,IAAOsZ,EAAU,QACrB,MAAMtZ,MAK9B,QAASyZ,oBAAmBxR,GAEpB,QAASyR,GAAQjQ,EAAMkQ,GACf,GAAInC,GAASrB,CACbA,GAAQwD,EACRlQ,EAAO0I,IAAI1I,EAAM8G,EACjB,IAAI8D,MAAWkB,EAAQpD,IAAIwH,EAAIpE,MAAO,SAASlV,EAAMkE,GAC7C,MAAY,OAARlE,EAAsB8R,IAAIyH,KACzBD,EAAIE,WAAWtV,IACpB8P,EAAK9P,IAAQ,GACJA,IAFyB4N,IAAIyH,MA2C9C,OAvCIrE,GAAMzU,OAAS,IAIXmY,kBAAmB,QAASxP,GAAQ,SAASxB,EAAKuI,EAAQ2I,EAAME,GACxD,GAAc,UAAVpR,EAAI,IACDA,EAAI,MAAO,GACE,QAAbA,EAAI,GAAG,IACP/F,IAAImS,EAAMpM,EAAI,GAAG,IAAK,CAErB,IAAK,GAAIpH,GAAI0U,EAAMzU,SAAUD,GAAK,GAC1B,GAAI0U,EAAM1U,GAAG,IAAMoH,EAAI,GAAG,GAAI,CAClBsN,EAAM1U,GAAG,IACLsY,IACR5D,EAAM1U,GAAG,GAAKoH,EAAI,GAClBsN,EAAMpQ,KAAKoQ,EAAM3C,OAAO/R,EAAG,GAAG,GAC9B,OAIhB,GAAImU,GAAIxE,EAAO6E,QACf,IAAY,OAARL,EAAE,GAAa,CACX,GAAIrL,GAAIqL,EAAE,EACVrL,GAAEmQ,QAAQ,EAAG9E,EAAElU,QACfkU,EAAEpC,OAAO1K,MAAM8M,EAAGrL,OAET,QAARqL,EAAE,GACHA,EAAEpC,OAAO,EAAGoC,EAAElU,OAAQ,SAGtBqY,GAERE,KAERF,MAER1P,EAAKqQ,SAAU,MAAOvE,KAE9BY,EAAQqB,EACD/N,EAEf,QAASwI,GAASC,GAEV,IAAK,GADD5P,GAAM,KACDzB,EAAIqR,EAAKpR,SAAUD,GAAK,GAAI,CAC7B,GAAI2V,GAAItE,EAAKrR,EACR2V,GAAE,KACPA,GAAM,UAAU,GAAQ,OAAQA,EAAE,IAAMA,EAAE,IACzBlU,EAAN,MAAPA,EAAmBkU,GACV,MAAOA,EAAGlU,IAE/B,MAAW,OAAPA,EACyB,UAAjBmU,EAAEpB,SAAS,IACE,OAAQnD,EAAK,GAAG,IAC1BC,IAAIyH,MAEV,OAAQtX,GAEzB,QAASyX,GAAUtQ,GACX,OAAS1J,KAAK,GAAI2Z,EAAQjQ,EAAM1J,KAAKoW,QArE7C,GAAqCA,GAAjCM,EAAIzE,aAAczB,EAAOkG,EAAElG,IAuE/B,OAAOkG,GAAEhE,cACDsB,WAAY,SAASxP,EAAM4F,EAAMV,GACzB,IAAK,GAAI5I,GAAIsJ,EAAKrJ,SAAUD,GAAK,IAAM4I,EAAK0M,MAAM0D,WAAW1P,EAAKtJ,KAC1DsJ,EAAK1B,KAEb,OADKgB,GAAK0M,MAAM0D,WAAWtV,KAAOA,EAAO,OAChCxE,KAAK,GAAIwE,EAAM4F,EAAMuP,EAAQjQ,EAAMA,EAAK0M,SAEzDnC,MAAS,SAASzP,EAAM4F,EAAMV,GACtB,IAAK0M,EAAM0D,WAAWtV,GAAO,MAAO4N,KAAIyH,IACxC,KAAK,GAAI/Y,GAAIsJ,EAAKrJ,SAAUD,GAAK,IAAM4I,EAAK0M,MAAM0D,WAAW1P,EAAKtJ,KAC1DsJ,EAAK1B,KACb,QAAS1I,KAAK,GAAIwE,EAAM4F,EAAMuP,EAAQjQ,EAAMA,EAAK0M,SAEzDtD,MAAOZ,EACPpB,SAAYkJ,GACjB,WACK,MAAOxJ,GAAKyF,cAAc/N,MAI1C,QAAS+R,aAAY/R,EAAK8O,GAUlB,QAASkD,GAAOhH,GACR,GAAIiH,IAAU,eAAgB,IAAKjH,EACnC,QAAQA,EAAE,IACN,IAAK,eACD,MAAe,KAARA,EAAE,IAAakF,aAAalF,EAAE,IAAMA,EAAE,GAAKiH,CACtD,KAAK,MAGD,MAFAjH,GAAIvL,MAAMuL,GACVA,EAAEA,EAAEnS,OAAS,GAAKmZ,EAAOhH,EAAEA,EAAEnS,OAAS,IAC/BmS,CACX,KAAK,cACD,MAAO2E,SAAQsC,GAAS,cAAejH,EAAE,GAAIgH,EAAOhH,EAAE,IAAKgH,EAAOhH,EAAE,KACxE,KAAK,SACD,GAAIlO,GAAKkO,EAAE,GAAIvH,EAAOuH,EAAE,GAAInH,EAAQmH,EAAE,EACtC,KAAK8D,EAAQoD,WAAY,OAAQpV,GAC7B,IAAK,KAAQ,OAAS,SAAU,IAAK2G,EAAMI,EAC3C,KAAK,IAAQ,OAAS,SAAU,KAAMJ,EAAMI,EAC5C,KAAK,KAAQ,OAAS,SAAU,IAAKJ,EAAMI,EAC3C,KAAK,IAAQ,OAAS,SAAU,KAAMJ,EAAMI,GAEhD,OAAQ/G,GACJ,IAAK,KAAQ,OAAS,SAAU,KAAM2G,EAAMI,EAC5C,KAAK,KAAQ,OAAS,SAAU,KAAMJ,EAAMI,EAC5C,KAAK,MAAQ,OAAS,SAAU,MAAOJ,EAAMI,EAC7C,KAAK,MAAQ,OAAS,SAAU,MAAOJ,EAAMI,EAC7C,KAAK,KAAQ,MAAO8L,SAAQsC,GAAS,SAAU,KAAMD,EAAOvO,GAAOuO,EAAOnO,IAC1E,KAAK,KAAQ,MAAO8L,SAAQsC,GAAS,SAAU,KAAMD,EAAOvO,GAAOuO,EAAOnO,MAItF,MAAOoO,GAGf,QAAS3C,GAAWxJ,EAAGpI,GACf,GAAI6R,GAASrB,CACbA,GAAQpI,CACR,IAAIzL,GAAMqD,GAGV,OAFArD,GAAI6T,MAAQpI,EACZoI,EAAQqB,EACDlV,EAGf,QAAS8X,GAAQzH,GAOT,MANa,OAATA,GAA6B,SAAZA,EAAM,IAAiBA,EAAM,KACnB,GAAnBA,EAAM,GAAG7R,OACL6R,EAAQA,EAAM,GAAG,GACG,GAAnBA,EAAM,GAAG7R,SACV6R,GAAU,WAEnBA,EAGf,QAAS2D,GAAQ/R,EAAM4F,EAAMV,GACrB,GAAI8M,GAAsB,SAAXxW,KAAK,EAOpB,OANA0J,GAAO8N,EAAW9N,EAAK0M,MAAO,WACtB,GAAI7T,GAAM+X,EAAQ5Q,EAAM,SAGxB,OAFK8M,KAAYhS,GAAS4R,EAAM0D,WAAWtV,KACnCA,EAAO,MACRjC,KAENvC,KAAK,GAAIwE,EAAM4F,EAAMV,GAStC,QAAS4Q,GAAQxM,EAAYyM,GAiGrB,MAhGAzM,GAAasE,IAAItE,EAAY0C,GAE7B1C,EAAaA,EAAW0M,OAAO,SAAS5Q,EAAGrB,GAQnC,MAPe,SAAXA,EAAK,GACGA,EAAK,IACDqB,EAAExE,KAAK+C,MAAMyB,EAAGrB,EAAK,IAG7BqB,EAAExE,KAAKmD,GAERqB,OAGfkE,EAAa,SAAUlE,EAAG9C,GAUlB,MATAgH,GAAW2M,QAAQ,SAASnM,GAChBxH,IAAoB,OAAVwH,EAAI,IAA0B,OAAXxH,EAAK,IACd,SAAVwH,EAAI,IAA4B,SAAXxH,EAAK,IAChCA,EAAK,GAAKA,EAAK,GAAG+H,OAAOP,EAAI,KAE7B1E,EAAExE,KAAKkJ,GACPxH,EAAOwH,KAGhB1E,OAGXoN,EAAQ0D,YAAW5M,EAAa,SAAUlE,EAAG+Q,GAyBzC,MAxBA7M,GAAW2M,QAAQ,SAASG,GAChBD,EACiB,YAATC,EAAG,IAA6B,SAATA,EAAG,GACtBhR,EAAExE,KAAKwV,GAEG,OAATA,EAAG,IAAwB,SAATA,EAAG,IACjB5D,EAAQ6D,aACLxW,KAAK,0CACbuW,EAAG,GAAKxI,IAAIwI,EAAG,GAAI,SAASvI,GAGpB,MAFIA,GAAI,KAAO2E,EAAQ6D,aACfrC,kBAAmB,UAAU,GAAQ,OAAQnG,EAAI,IAAMA,EAAI,MAC1DA,EAAI,MAErBzI,EAAExE,KAAKwV,IAEL5D,EAAQ6D,aACVrC,iBAAiBoC,IAGzBhR,EAAExE,KAAKwV,GACH9R,OAAO8R,EAAG,IAAM,SAAU,QAAS,QAAS,eACxCD,GAAW,MAG5B/Q,QAGXoN,EAAQ8D,YAAWhN,EAAa,SAAUlE,EAAG9C,GAkBzC,MAjBAgH,GAAW2M,QAAQ,SAASnM,GAChBxH,GAAmB,QAAXA,EAAK,IAA0B,QAAVwH,EAAI,GAC7BxH,EAAK,IAAO,MAAOA,EAAK,GAAIwH,EAAI,KAEhC1E,EAAExE,KAAKkJ,GACPxH,EAAOwH,KAGnB1E,EAAE7I,QAAU,GACW,QAApB6I,EAAEA,EAAE7I,OAAO,GAAG,KACO,UAApB6I,EAAEA,EAAE7I,OAAO,GAAG,IAAsC,SAApB6I,EAAEA,EAAE7I,OAAO,GAAG,KAC/C6I,EAAEA,EAAE7I,OAAO,GAAG,IAEb6I,EAAEiJ,OAAOjJ,EAAE7I,OAAS,EAAG,GACZ6I,EAAEA,EAAE7I,OAAO,GAAG,IACZ,MAAO6I,EAAEA,EAAE7I,OAAO,GAAG,GAAI6I,EAAEA,EAAE7I,OAAO,GAAG,MAErD6I,QAwBRkE,EAGf,QAASiN,GAAQ7H,EAAGD,EAAGU,GACf,MAAO4E,eAAcrF,EAAG,SAAShL,EAAK3H,GAC9B,MAAIA,IACIiY,iBAAiB7E,GACVV,IAEPuF,iBAAiBvF,GACVU,IAEpB,WACK,MAAOqH,GAAa9H,EAAGD,EAAGU,KAI1C,QAASqH,GAAa9H,EAAGD,EAAGU,GAyBpB,GAxBAT,EAAI1C,EAAK0C,GACTD,EAAIzC,EAAKyC,GACTU,EAAInD,EAAKmD,GAEL8E,MAAMxF,IACFC,EAAIgH,EAAOhH,GACXD,EAAIU,EACJA,EAAI,MACD8E,MAAM9E,GACTA,EAAI,MAGJ,WACQ,GAAI/J,GAAIoO,SAAS9E,GACbtP,EAAIsW,EAAOhH,GACXgF,EAAIF,SAASpU,EACjB,IAAIsU,EAAEnX,OAAS6I,EAAE7I,OAAQ,CACjB,GAAIka,GAAMhI,CACVA,GAAIU,EACJA,EAAIsH,EACJ/H,EAAItP,MAIxB6U,MAAM9E,IAAM8E,MAAMxF,GACd,OAAS,OAAQC,EACzB,IAAI3Q,IAAQ,KAAM2Q,EAAGD,EAAGU,EAoCxB,OAnCY,MAARV,EAAE,IAAcwF,MAAMxF,EAAE,KAAOwF,MAAM9E,GACjCpR,EAAMsV,QAAQtV,EAAKiO,GAAO,MAAQ,SAAU,KAAM0C,EAAGD,EAAE,IAAMA,EAAE,MAEtD,QAARA,EAAE,GACCU,EACgB,QAARA,EAAE,KACEpR,EAAMsV,QAAQtV,GAAO,OAAQ8V,iBAAiBnF,EAAGD,EAAE,GAAIU,EAAE,OAIjEpR,EAAMsV,QAAQtV,GAAO,OAAQ8V,iBAAiBnF,EAAGD,EAAE,MAG1DU,GAAKV,EAAE,IAAMU,EAAE,KAAe,UAARV,EAAE,IAA0B,SAARA,EAAE,KAAkBA,EAAE,IAAMU,EAAE,GACzEpR,EAAMsV,QAAQtV,GAAO0Q,EAAE,GAAIoF,iBAAiBnF,EAAGD,EAAE,GAAIU,EAAE,MAEtDA,GAAKwE,OAAOlF,IACb1Q,IAAU,KAAM2Q,EAAGD,IACP,SAARU,EAAE,GACMA,EAAE,KAAIpR,EAAMA,EAAIsM,OAAO8E,EAAE,KAG7BpR,EAAI6C,KAAKuO,GAEjBpR,EAAMiO,GAAO,QAASjO,KAErB0Q,GAAKkF,OAAOxE,KACbpR,IAAU,KAAM2X,EAAOhH,GAAIS,IACf,SAARV,EAAE,GACMA,EAAE,KAAI1Q,EAAMA,EAAIsM,OAAOoE,EAAE,KAE7B1Q,EAAI6C,KAAK6N,GAEjB1Q,EAAMiO,GAAO,QAASjO,KAEvBA,EAGf,QAAS2Y,GAAUzR,EAAMC,GACjB,MAAO6O,eAAc9O,EAAM,SAASA,EAAMlJ,GAClC,MAAKA,IAIY,MAAO,KAAM,KAAM,KAAMiQ,EAAK9G,KAHvC8O,iBAAiB9O,IACR,YArQjCsN,EAAUmE,SAASnE,GACX8D,WAAc,EACdJ,WAAc,EACdN,YAAc,EACdS,aAAc,GAGtB,IAAqCzE,GAAjCM,EAAIzE,aAAczB,EAAOkG,EAAElG,IAqQ/B,OAAOkG,GAAEhE,cACDmC,IAAO,SAASzJ,EAAM0J,GACd,GAAoB,UAAhBA,EAAU,GAAgB,CACtB,GAAItQ,GAAOsQ,EAAU,EACrB,IAAIsG,cAAc5W,GACV,OAAS,MAAOgM,EAAKpF,GAAO5G,EAC/B,IAAI,gBAAgBjG,KAAKiG,IAAkB,MAATA,EAC/B,OAAS,MAAOgM,EAAKpF,IAAS,MAAO/L,SAASmF,EAAM,QAG5E0P,KAAM6G,EACNjK,SAAY,SAASpH,GACb,OAAS,WAAY8N,EAAWxX,KAAKoW,MAAO,WACpC,MAAOkE,GAAQ5Q,OAG/B4J,SAAU,SAASlI,EAAM1B,GACjB,GAAI2R,GAAO3R,EAAK3I,OAAS,CACzB,QAAS,SAAUyP,EAAKpF,GAAOgH,IAAI1I,EAAM,SAAS6J,EAAQzS,GAClD,GAAI8R,GAAQ0H,EAAQ/G,EAAO,GAC3B,IAAIzS,GAAKua,GAAQzI,EAAM7R,OAAS,EAAG,CAC3B,GAAI4X,GAAO/F,EAAMA,EAAM7R,OAAS,EACjB,UAAX4X,EAAK,IAAkBA,EAAK,IACxB/F,EAAMlK,MAEtB,OAAS6K,EAAO,GAAK/C,EAAK+C,EAAO,IAAM,KAAMX,OAG7DoB,WAAYuC,EACZtC,MAASsC,EACT3D,MAAS,SAASlJ,GACV,MAAIA,GAAa2Q,GAAU,QAASC,EAAQ5Q,KAA5C,QAERgL,OAAU,SAAS1P,EAAI2G,EAAMI,GACrB,MAAOwM,gBAAgB,SAAUvT,EAAIwL,EAAK7E,GAAO6E,EAAKzE,IAAU,SAAamH,GACrE,MAAO2E,SAAQrH,EAAK0C,GAAIlT,OAC7B,WACK,MAAOA,SAGvB0T,YAAe,SAASR,EAAGD,EAAGU,GACtB,MAAO0E,kBAAiB7H,EAAK0C,GAAI1C,EAAKyC,GAAIzC,EAAKmD,KAEvDX,MAAO,SAASC,EAAGC,EAAGtE,GACd,OACQ,MACA0L,EAAQrH,GACH,MAALC,GAAcA,EAAE,GAAIoH,EAAQpH,EAAE,KAAQ,KACjC,MAALtE,EAAY0L,EAAQ1L,GAAK,OAGzC+F,eAAgB,SAAS3P,EAAIoG,GACrBA,EAAOoF,EAAKpF,EACZ,IAAI7I,IAAQ,eAAgByC,EAAIoG,EAGhC,OAFU,KAANpG,IACIzC,EAAMsV,QAAQtV,EAAK2X,EAAO9O,KAC3BmN,cAAchW,EAAK,SAAS2F,EAAK3H,GAChC,MAAOiQ,GAAKtI,IACjB,WAAa,MAAO3F,MAE/BiC,KAAQ,SAASA,GACT,OAAQA,GACJ,IAAK,OAAQ,OAAS,eAAgB,KAAO,MAAO,GACpD,KAAK,QAAS,OAAS,eAAgB,KAAO,MAAO,MAGjE4O,MAAO,SAASC,EAAMjJ,GACd,MAAe,QAAXiJ,EAAK,IAA2B,SAAXA,EAAK,IAAkB+C,EAAMU,IAAI,SAA1D,OAC2B,GAAf1M,EAAKrJ,QACQ,QAASqJ,IAET,QAAU,OAAQ,SAAWA,IAI9D8E,KAAQ,SAAS9D,EAAMhB,GACf,MAAe,QAAXgB,EAAK,IAA2B,SAAXA,EAAK,IAAgC,GAAfhB,EAAKrJ,QAAgBqV,EAAMU,IAAI,SAA9E,QACiB,QAAS1M,IAGlCmK,QAAS2G,GACd,WACK,IAAK,GAAIpa,GAAI,EAAO,EAAJA,IAASA,EACjBoH,EAAM0Q,YAAY1Q,GAClBA,EAAM+N,cAAc/N,GACpBA,EAAMsI,EAAKtI,EAEnB,OAAOA,KAiBvB,QAASoT,aAAYlV,EAAKmV,GAClB,GAAIC,GAAK,EAAGC,EAAK,CAiBjB,OAhBArV,GAAMA,EAAIJ,QAAQ,sCAAuC,SAASgI,GAC1D,OAAQA,GACJ,IAAK,KAAM,MAAO,MAClB,KAAK,KAAM,MAAO,KAClB,KAAK,KAAM,MAAO,KAClB,KAAK,KAAM,MAAO,KAClB,KAAK,KAAM,MAAO,KAClB,KAAK,IAAM,MAAO,KAClB,KAAK,SAAU,MAAO,SACtB,KAAK,SAAU,MAAO,SACtB,KAAK,IAAW,QAAJwN,EAAW,GACvB,KAAK,IAAW,QAAJC,EAAW,IAE3B,MAAOzN,KAEXuN,IAAYnV,EAAMsV,SAAStV,IAC3BoV,EAAKC,EAAW,IAAMrV,EAAIJ,QAAQ,QAAS,OAAS,IAC5C,IAAMI,EAAIJ,QAAQ,QAAS,OAAS,IAGxD,QAAS0V,UAAStV,GACV,MAAOA,GAAIJ,QAAQ,mBAAoB,SAAS5H,GAExC,IADA,GAAIud,GAAOvd,EAAGK,WAAW,GAAGmd,SAAS,IAC9BD,EAAK5a,OAAS,GAAG4a,EAAO,IAAMA,CACrC,OAAO,MAAQA,IAM/B,QAAS3D,UAAS9P,EAAK8O,GAef,QAAS6E,GAAczV,GACf,GAAI7D,GAAM+Y,YAAYlV,EAAK4Q,EAAQuE,WAGnC,OAFIvE,GAAQ8E,gBACJvZ,EAAMA,EAAIyD,QAAQ,gCAAgC,iBACnDzD,EAGf,QAASwZ,GAAUvX,GAIX,MAHAA,GAAOA,EAAKoX,WACR5E,EAAQuE,aACJ/W,EAAOkX,SAASlX,IACjBA,EAGf,QAASwX,GAAOpc,GAKR,MAJY,OAARA,IACIA,EAAO,IACXqc,IACIrc,EAAOsc,cAAc,IAAKlF,EAAQmF,aAAeC,EAAcpF,EAAQqF,cAAgBzc,GACxFA,EAGf,QAAS0c,GAAY1W,EAAM2W,GACP,MAARA,IAAcA,EAAO,GACzBH,GAAeG,CACf,KAAM,MAAO3W,GAAKuC,MAAM,KAAMR,MAAMC,UAAW,IAC/C,QAAUwU,GAAeG;AAGjC,QAASC,GAAW5S,GACZ,GAAIqS,EACI,MAAOrS,GAAE6S,KAAK,IAEtB,KAAK,GADDvE,MACKpX,EAAI,EAAGA,EAAI8I,EAAE7I,SAAUD,EAAG,CAC3B,GAAIQ,GAAOsI,EAAE9I,EAAI,EACjBoX,GAAE9S,KAAKwE,EAAE9I,IACLQ,IACE,kBAAkB/C,KAAKqL,EAAE9I,GAAG8a,aAAe,kBAAkBrd,KAAK+C,EAAKsa,aACvE,UAAUrd,KAAKqL,EAAE9I,GAAG8a,aAAe,UAAUrd,KAAK+C,EAAKsa,cACrD1D,EAAE9S,KAAK,KAGvB,MAAO8S,GAAEuE,KAAK,IAGtB,QAASC,GAAW9S,GACZ,MAAOA,GAAE6S,KAAK,IAAME,GAG5B,QAASC,GAAaxR,GAEd,IAAK,GADDoH,GAAMqK,EAAKzR,GACNtK,EAAI,EAAGA,EAAI8G,UAAU7G,SAAUD,EAAG,CACnC,GAAIgc,GAAKlV,UAAU9G,EACnB,IAAKgc,YAAchO,WAAYgO,EAAG1R,IAAUA,EAAK,IAAM0R,EAC/C,MAAO,IAAMtK,EAAM,IAEnC,MAAOA,GAGf,QAASqF,GAAQjO,GACT,GAAgB,GAAZA,EAAE7I,OACE,MAAO6I,GAAE,EAEjB,IAAgB,GAAZA,EAAE7I,OAAa,CACX,GAAImX,GAAItO,EAAE,EAEV,OADAA,GAAIA,EAAE,GACCA,EAAE7I,QAAUmX,EAAEnX,OAAS6I,EAAIsO,EAE1C,MAAOL,IAAUjO,EAAE,GAAIiO,EAAQjO,EAAEjC,MAAM,MAG/C,QAASoV,GAAa3R,GACd,GAAe,YAAXA,EAAK,IAA+B,UAAXA,EAAK,GAU1B,IADA,GAAIxB,GAAIjC,MAAM+O,EAAExW,SAAU0X,EAAOhO,EAAElB,MAAOuM,EAAIrL,EAAElB,MACzCuM,GAAG,CACF,GAAY,QAARA,EAAE,GAAc,OAAO,CAC3B,KAAc,OAARA,EAAE,IAAuB,QAARA,EAAE,IAAwB,OAARA,EAAE,IAAuB,OAARA,EAAE,IAAuB,eAARA,EAAE,IAAwBA,EAAE,KAAO2C,KAChG,UAAR3C,EAAE,IAA0B,UAARA,EAAE,IAA0B,iBAARA,EAAE,IAA0BA,EAAE,KAAO2C,GAI3E,OAAO,CAHPA,GAAO3C,EACPA,EAAIrL,EAAElB,MAM9B,OAAQvG,IAAI6a,mBAAoB5R,EAAK,IAG7C,QAAS6R,GAAS9d,GACV,GAA8D+d,GAA1D9W,EAAMjH,EAAIyc,SAAS,IAAKhS,GAAMxD,EAAIJ,QAAQ,OAAQ,KAWtD,OAVImX,MAAKC,MAAMje,KAASA,GAChByK,EAAExE,KAAK,KAAOjG,EAAIyc,SAAS,IAAIyB,cACxB,IAAMle,EAAIyc,SAAS,KACrBsB,EAAI,cAAcI,KAAKne,KACpByK,EAAExE,KAAK8X,EAAE,GAAK,IAAMA,EAAE,GAAGnc,UAE7Bmc,EAAI,iBAAiBI,KAAKne,KAC9ByK,EAAExE,KAAK8X,EAAE,GAAK,MAAQA,EAAE,GAAGnc,OAASmc,EAAE,GAAGnc,QAClCqF,EAAI9G,OAAO8G,EAAIxE,QAAQ,OAE/BiW,EAAQjO,GA6OvB,QAAS2T,GAAUC,GACX,GAAa,MAATA,EAAG,GAKC,MAAOC,IAAaD,GAG5B,KADA,GAAItF,GAAIsF,IACK,CACL,GAAIld,GAAO4X,EAAE,EACb,IAAY,MAAR5X,EAAc,CACV,IAAK4X,EAAE,GAEC,MAAO2E,IAAO,SAAWW,IACjCtF,GAAIA,EAAE,OAET,IAAY,SAAR5X,GAA2B,MAARA,EAAc4X,EAAIA,EAAE,OAC3C,CAAA,GAAY,OAAR5X,GAAyB,UAARA,EACrB,KADuC4X,GAAIA,EAAE,IAG1D,MAAO2E,GAAKW,GAGpB,QAASE,GAAclZ,EAAM4F,EAAMV,EAAMiU,GACjC,GAAIpL,GAAMoL,GAAW,UAKrB,OAJInZ,KACI+N,GAAO,IAAMwJ,EAAUvX,IAE/B+N,GAAO,IAAMmK,EAAWtK,IAAIhI,EAAM2R,IAAc,IACzCS,GAAajK,EAAKkL,EAAW/T,KAG5C,QAASkU,GAAmBjF,GACpB,OAAQA,EAAK,IACT,IAAK,OACL,IAAK,QACD,MAAOF,OAAME,EAAK,GACtB,KAAK,MACL,IAAK,SACD,MAAOF,OAAME,EAAK,GACtB,KAAK,KACD,MAAIF,OAAME,EAAK,MAAQA,EAAK,IAAW,EACnCA,EAAK,GACGF,MAAME,EAAK,KAAY,EACpBiF,EAAmBjF,EAAK,IAEhCiF,EAAmBjF,EAAK,KAI/C,QAASkF,GAAsB/P,EAAYgQ,GACnC,IAAK,GAAIlU,MAAQyR,EAAOvN,EAAW/M,OAAS,EAAGD,EAAI,EAAQua,GAALva,IAAaA,EAAG,CAC9D,GAAIyH,GAAOuF,EAAWhN,GAClB6a,EAAOkB,EAAKtU,EACJ,MAARoT,IACSM,GAAYnb,GAAKua,GAASuC,EAAmBrV,KAC1CoT,EAAOA,EAAK3V,QAAQ,SAAU,KAEtC4D,EAAExE,KAAKuW,IAGvB,MAAOmC,GAAWlU,EAAIwI,IAAIxI,EAAGoS,GAGrC,QAAS+B,GAAkBrU,GACnB,GAAI9F,GAAI8F,EAAK3I,MACb,OAAS,IAAL6C,EAAe,KACZ,IAAMoa,EAAU5L,IAAI1I,EAAM,SAAS6J,EAAQzS,GAC1C,GAAImd,GAAW1K,EAAO,GAAGxS,OAAS,EAAG4a,EAAOW,EAAY,WAChD,MAAON,GAAOzI,EAAO,GACLiJ,GAAa,OAAQK,EAAKtJ,EAAO,IAAM,MACvC,aACrB,KAAQ0K,EAAWD,EAAU1B,EAAY,WACpC,MAAOuB,GAAsBtK,EAAO,IAAIkJ,KAAKuB,KAChD,GAGL,QAFK/B,GAAYgC,GAAgBra,EAAI,EAAR9C,IACrB6a,GAAQ,KACTA,IACZc,KAAKuB,GAAWA,EAAUhC,EAAO,KAG5C,QAASyB,GAAW3P,GACZ,MAAKA,GACoB,GAArBA,EAAW/M,OAAoB,KAC5B,IAAMid,EAAU1B,EAAY,WAC3B,MAAOuB,GAAsB/P,GAAY2O,KAAKuB,KACjDA,EAAUhC,EAAO,KAJE,IAOhC,QAASkC,GAAa7L,GACd,GAAI7N,GAAO6N,EAAI,GAAI9R,EAAM8R,EAAI,EAG7B,OAFW,OAAP9R,IACIiE,EAAOgY,GAAaT,EAAUvX,GAAO,IAAKoY,EAAarc,EAAK,UAC7DiE,EArcfwS,EAAUmE,SAASnE,GACXmF,aAAe,EACfE,aAAe,EACf8B,YAAe,EACfC,aAAe,EACfnC,UAAe,EACfV,YAAe,EACfO,eAAe,GAEvB,IAAIG,KAAajF,EAAQiF,SACrBG,EAAc,EACd4B,EAAU/B,EAAW,KAAO,GAC5BU,EAAQV,EAAW,IAAM,GAiHzBvF,EAAIzE,aACJ4K,EAAOnG,EAAElG,IACb,OAAOkG,GAAEhE,cACDhB,OAAUmK,EACV1c,IAAO8d,EACPzY,KAAQuX,EACRjL,SAAY,SAAShD,GACb,MAAO+P,GAAsB/P,GACpB2O,KAAKuB,EAAUA,IAEhCnL,OAAU,SAAS/E,GACX,GAAIwH,GAASoB,EAAEpB,QACf,OAAInT,KAAIkc,sBAAuB/I,GAEhBmI,EAAWtV,MAAMnI,KAAM4H,WAEvBwK,IAAIyL,EAAsB/P,GAAY,GAClC,SAASlO,EAAMkB,GAEP,MAAOA,GAAI,EAAIkb,EAAOpc,GAAQA,IACnC6c,KAAKuB,IAGnCpL,MAAS6K,EACT3K,MAAO,SAASX,GACR,MAAO,OAASuK,EAAWtK,IAAID,EAAM+L,IAAiB,KAE9DnL,QAAS,SAASZ,GACV,MAAO,SAAWuK,EAAWtK,IAAID,EAAM+L,IAAiB,KAEhElL,MAAO,SAASsL,EAAIC,EAAIzF,GAChB,GAAIvG,IAAQ,MAAOkL,EAAWa,GAG9B,OAFIC,IAAIhM,EAAInN,KAAK,QAAS,IAAMmZ,EAAG,GAAK,IAAKd,EAAWc,EAAG,KACvDzF,GAAIvG,EAAInN,KAAK,UAAWqY,EAAW3E,IAChC0D,EAAWjK,IAE1BY,QAAS,SAAS/H,GACV,MAAOoR,IAAa,QAASK,EAAKzR,KAAW,KAErDgI,MAAO,SAASC,EAAMjJ,GAEd,MADAA,GAAOA,EAAKrJ,OAAS,EAAI,IAAM2b,EAAWtK,IAAIhI,EAAMyS,IAAS,IAAM,GAC5DL,GAAa,MAAOI,EAAavJ,EAAM,MAAO,SAAU,cAAe,SAAU,SAASjI,GACzF,GAAIsL,GAAIzE,aAAcuM,IACtB,KACQ9H,EAAEhE,cACMxD,KAAQ,WAAa,KAAMsP,IAC3BxK,WAAY,WAAa,MAAOhU,QACrC,WACK0W,EAAElG,KAAKpF,KAErB,MAAMnL,GACA,GAAIA,IAAOue,EACH,OAAO,CACf,MAAMve,MAEjBmK,KAEbkJ,SAAU,SAASlI,EAAM1B,GACjB,MAAO8S,IAAa,SAAU,IAAMK,EAAKzR,GAAQ,IAAK2S,EAAkBrU,MAEhF8J,QAAS,SAASnL,GACV,GAAIkK,GAAM,OAGV,OAFa,OAATlK,IACIkK,GAAO,IAAMwJ,EAAU1T,IACxBkK,EAAM,KAErBkB,WAAY,SAASpL,GACb,GAAIkK,GAAM,UAGV,OAFa,OAATlK,IACIkK,GAAO,IAAMwJ,EAAU1T,IACxBkK,EAAM,KAErBmB,YAAe,SAAS+K,EAAIjB,EAAIV,GACxB,MAAON,IAAaI,EAAa6B,EAAI,SAAU,MAAO,eAAgB,IAClD7B,EAAaY,EAAI,OAAQ,IACzBZ,EAAaE,EAAI,UAE7ClJ,OAAU,SAAS5O,EAAI6O,EAAQC,GAGvB,MAFI9O,IAAMA,KAAO,EAAMA,GAAM,IACxBA,EAAK,IACHwX,GAAaK,EAAKhJ,GAAS7O,EAAI4X,EAAa9I,EAAQ,UAEnEC,IAAO,SAAS3I,GACR,GAAImH,GAAMsK,EAAKzR,GAAOtK,EAAI,CAM1B,KALe,OAAXsK,EAAK,GACI,KAAK7M,KAAK6M,EAAK,MACZmH,GAAO,KACZwK,EAAa3R,KAChBmH,EAAM,IAAMA,EAAM,KACnBzR,EAAI8G,UAAU7G,QACbwR,GAAO,IAAMwJ,EAAUnU,UAAU9G,KACzC,OAAOyR,IAEfrD,KAAQ,SAASwP,EAAMtU,GACf,GAAIwE,GAAIiO,EAAK6B,EAGb,OAFI3B,GAAa2B,KACT9P,EAAI,IAAMA,EAAI,KACfA,EAAI,IAAM8N,EAAWtK,IAAIhI,EAAM,SAASgB,GACvC,MAAOwR,GAAaxR,EAAM,UAC5B,KAEd4I,WAAY0J,EACZzJ,MAASyJ,EACTxJ,KAAM,SAASuK,EAAIjB,EAAIV,GACf,GAAIvK,IAAQ,KAAM,IAAMsK,EAAK4B,GAAM,IAAK3B,EAAKS,EAAUC,GAAMX,EAAKW,GAIlE,OAHIV,IACIvK,EAAInN,KAAK,OAAQyX,EAAKC,IAEvBN,EAAWjK,IAE1B4B,MAAO,SAASlL,EAAMQ,EAAMJ,EAAMuJ,GAC1B,GAAIL,IAAQ,MACZtJ,IAAgB,MAARA,EAAe4T,EAAK5T,GAAQ,IAAIjD,QAAQ,SAAU,IAAM2W,GAChElT,GAAgB,MAARA,EAAeoT,EAAKpT,GAAQ,IAAIzD,QAAQ,SAAU,IAAM2W,GAChEtT,GAAgB,MAARA,EAAewT,EAAKxT,GAAQ,IAAIrD,QAAQ,SAAU,GAC1D,IAAIoE,GAAOnB,EAAOQ,EAAOJ,CAGzB,OAFY,QAARe,IAAgBA,EAAO,MAC3BmI,EAAInN,KAAK,IAAMgF,EAAO,IAAKyS,EAAKjK,IACzB4J,EAAWjK,IAE1B6B,SAAU,SAASC,EAAMnW,EAAKoW,EAAM1B,GAC5B,MAAO4J,IAAa,MAAO,KACNnI,EAAOwI,EAAKxI,GAAMrO,QAAQ,MAAO,IAAM6W,EAAK3e,IAC7C,KACA2e,EAAKvI,GAAQ,IAAKuI,EAAKjK,MAEnD2B,QAAS,SAASoK,EAAW/L,GACrB,MAAO4J,IAAa,QAAS,IAAMK,EAAK8B,GAAa,IAAK9B,EAAKjK,MAEvE4B,KAAM,SAASmK,EAAW/L,GAClB,MAAO4J,IAAa,KAAMK,EAAKjK,GAAQ,QAAS,IAAMiK,EAAK8B,GAAa,MAAS,KAEzFlK,SAAU,SAASrJ,GACX,GAAImH,IAAQ,SAEZ,OADY,OAARnH,GAAcmH,EAAInN,KAAKyX,EAAKzR,IACzBoR,EAAWjK,GAAO,KAEjCmC,OAAU,SAASkK,EAAU/K,EAAQC,GAC7B,GAAInI,GAAOkR,EAAKhJ,GAAS9H,EAAQ8Q,EAAK/I,EAiBtC,QAbIhL,OAAO+K,EAAO,IAAM,SAAU,cAAe,SAChC,UAAbA,EAAO,IAAkB/H,WAAW8S,GAAY9S,WAAW+H,EAAO,OAC9DlI,EAAO,IAAMA,EAAO,KAExB7C,OAAOgL,EAAO,IAAM,SAAU,cAAe,SAChC,UAAbA,EAAO,IAAkBhI,WAAW8S,IAAa9S,WAAWgI,EAAO,MACjEA,EAAO,IAAM8K,IAAY9V,OAAO8V,GAAY,KAAM,KAAM,OACtD7S,EAAQ,IAAMA,EAAQ,IAEpBkQ,IAAYjF,EAAQ8E,eAA8B,KAAZ8C,GAA+B,MAAZA,GAC1C,UAAb9K,EAAO,KAAkB,WAAWvV,KAAKuV,EAAO,MACpD/H,EAAQ,IAAMA,GAEfyQ,GAAa7Q,EAAMiT,EAAU7S,KAE5C4I,eAAgB,SAASiK,EAAUxT,GAC3B,GAAI7K,GAAMsc,EAAKzR,EAGf,OAFiB,OAAXA,EAAK,KAA2B,gBAAXA,EAAK,IAAyBjJ,IAAI+C,UAAW0Z,EAAWxT,EAAK,MAAS2R,EAAa3R,KACtG7K,EAAM,IAAMA,EAAM,KACnBqe,GAAYC,IAAIngB,qBAAqBkgB,EAASvd,OAAO,IAAM,IAAM,IAAMd,GAEtFqU,gBAAiB,SAASgK,EAAUxT,GAC5B,GAAI7K,GAAMsc,EAAKzR,EAGf,OAFiB,OAAXA,EAAK,KAA2B,iBAAXA,EAAK,IAA0BjJ,IAAI+C,UAAW0Z,EAAWxT,EAAK,MAAS2R,EAAa3R,KACvG7K,EAAM,IAAMA,EAAM,KACnBA,EAAMqe,GAErB/J,IAAO,SAASzJ,EAAM0J,GACd,GAAIR,GAAOuI,EAAKzR,EAGhB,OAFI2R,GAAa3R,KACTkJ,EAAO,IAAMA,EAAO,KACrBA,EAAO,IAAMuI,EAAK/H,GAAa,KAE9CC,OAAU,SAASC,GACX,MAAoB,IAAhBA,EAAMjU,OACK,KACR,IAAMid,EAAU1B,EAAY,WAC3B,MAAOlK,KAAI4C,EAAO,SAASC,GACnB,GAAgB,GAAZA,EAAElU,OAGE,MAAOib,GAAO0B,EAAczI,EAAE,GAAIA,EAAE,GAAG,GAAIA,EAAE,GAAG,GAAIA,EAAE,IAE9D,IAAI/W,GAAM+W,EAAE,GAAI1U,EAAMqc,EAAa3H,EAAE,GAAI,MASzC,OARI+B,GAAQmH,WACJjgB,EAAM2d,EAAc3d,IACF,gBAAPA,KAAoB+d,IAAa/d,EAAM,IAAMA,IAClDuB,WAAWvB,IAAQ,EACzBA,EAAM+e,GAAU/e,GACZkd,cAAcld,KAClBA,EAAM2d,EAAc3d,IAErB8d,EAAOQ,EAAWP,GAAYjF,EAAQoH,aAChBlgB,EAAK,IAAKqC,IACVrC,EAAM,IAAKqC,OAC7Ckc,KAAK,IAAMuB,KACjBA,EAAUhC,EAAO,MAE9BrX,OAAU,SAASuQ,EAAIrQ,GACf,MAAO,IAAMqQ,EAAK,IAAMrQ,GAEhCuK,MAAS,SAAS+F,GACV,MAAuB,IAAnBA,EAASpU,OAAoB,KAC1Byb,GAAa,IAAKE,EAAWtK,IAAI+C,EAAU,SAAS2H,GACnD,MAAKb,IAAqB,QAATa,EAAG,IAAyB,aAATA,EAAG,GAChCF,EAAaE,EAAI,OADyC,MAEpE,OAEbvU,KAAQ,SAASuW,GACT,MAAOjC,GAAKiC,GAAM9Y,QAAQ,SAAU,MAE5CoP,IAAO,WACC,MAAOsH,GAAWtK,IAAIzK,MAAMC,WAAYiV,KAEhDxU,MAAS,SAAS7D,EAAMoO,GAChB,MAAO4J,IAAaT,EAAUvX,GAAO,IAAKqY,EAAKjK,MAEvDyC,OAAQ,SAASjK,EAAMwH,GACf,MAAO4J,IAAa,OAAQ,IAAMK,EAAKzR,GAAQ,IAAKyR,EAAKjK,MAEjEnE,KAAQ,SAASjK,GACT,MAAOuX,GAAUvX,KAE9B,WAAY,MAAOqY,GAAK3U,KA4GnC,QAAS6W,aAAYpD,EAAMqD,GACnB,GAAIC,IAAW,EAqCf,OApCAJ,KAAIK,MAAM,WAIF,QAASC,GAAe/a,GAChB,MAAOA,GAAItE,IAAMsf,EAEzB,QAASC,GAAWjb,GACZgb,EAAahb,EAAItE,IACjBmf,EAAO7Z,KAAKga,GAEpB,QAASE,KACD,GAAIlb,GAAMiB,EAAW8C,MAAMnI,KAAM4H,UACjC2K,GACQ,KAAIgN,GAC2B,WAAnBA,EAAWjf,OAEnB6e,EAAe/a,GAAO4a,EAClB,OAAQ5a,EAAI9D,MACR,IAAK,UACL,IAAK,OACL,IAAK,OACL,IAAK,OACD+e,EAAWjb,EACX,MAAMmO,GAK9B,MADAgN,GAAanb,EACNA,EA5Bf,GAEImb,GAFAla,EAAawZ,IAAI5d,UAAU0a,GAC3ByD,EAAa,CAgCjB,OAHAE,GAAOrZ,QAAU,WACT,MAAOZ,GAAWY,QAAQkC,MAAMnI,KAAM4H,YAEvC0X,MAERL,EAAOO,IAAI,SAAS1f,EAAKgB,GACxB,MAAO6a,GAAKzX,UAAUpE,EAAKmf,EAAOne,EAAI,IAAM6a,EAAK5a,UACtD0b,KAAK,MAKhB,QAASP,eAAc9V,EAAKtF,GACpB,GAAS,GAALA,EAAQ,MAAO,EACnB,IAAS,GAALA,EAAQ,MAAOsF,EACnB,IAAIqQ,GAAIyF,cAAc9V,EAAKtF,GAAK,EAGhC,OAFA2V,IAAKA,EACG,EAAJ3V,IAAO2V,GAAKrQ,GACTqQ,EAGf,QAAS0E,UAAS/Q,EAAM+H,GAChB,GAAI5P,KACA6H,MAAS,IACLA,KACR,KAAK,GAAItJ,KAAKqR,GAAUhQ,IAAIgQ,EAAMrR,KAC1ByB,EAAIzB,GAAMsJ,GAAQjI,IAAIiI,EAAMtJ,GAAMsJ,EAAKtJ,GAAKqR,EAAKrR,GAEzD,OAAOyB,GAGf,QAAS6Y,eAAc5W,GACf,MAAO,wBAAwBjG,KAAKiG,IACjB,QAARA,IACCrC,IAAI0c,IAAInZ,cAAelB,KACvBrC,IAAI0c,IAAIY,eAAgBjb,KACxBrC,IAAI0c,IAAIpZ,SAAUjB,GAGtC,QAASrC,KAAInE,EAAKqR,GACV,MAAOC,QAAOL,UAAUM,eAAeL,KAAKlR,EAAKqR,GAy4BzD,QAASqQ,WAAUC,GACf,GAAI5O,GACA6O,CAEJ,IAAID,EAAK5K,OAAO5E,SAAU0P,cACtB9O,EAAO,GAAI8O,cAAaF,EAAK5K,OAAO5E,QAAQwP,OAE3C,CASD,GAAIG,GAAWC,OAAOC,QAAQL,EAAK5K,OAAO5E,OAQ1C,IALIyP,EAFAE,EAEYG,GAAGC,gBAAiB,IAAMJ,EAASK,IAAKR,EAAK1Z,SAG7Cga,GAAGC,gBAAgBP,EAAK5K,OAAO5E,OAAS,OAAQwP,EAAK1Z,UAEjE2Z,EAQA,WADA3R,SAAQC,IAAI,4BAA8ByR,EAAK5K,OAAO5E,OANtD,IAAIY,GAAO6O,EAAUQ,aAAaT,EAAKrK,OAEhB,oBAAZvE,GAAKsP,MACZtP,EAAKsP,IAAIC,WAAa,IAAMX,EAAK5K,OAAO5E,QAAUwP,EAAK5K,OAAOwL,GAAK,IAAMZ,EAAK5K,OAAOwL,GAAK,KAkBtG,MATIZ,GAAK5K,OAAOwL,KACZZ,EAAK1Z,QAAQ0Z,EAAK5K,OAAOwL,IAAMxP,GAGnCA,EAAKyP,SAAoB,UAAIT,OAAOU,UAGpCC,gBAAgBf,EAAK5K,OAAQhE,EAAMA,EAAMA,EAAKyP,UAEvCzP,EASX,QAAS4P,sBAAqBrgB,EAAMtC,EAAK6O,EAAUmK,GAC/C,GACI4J,GAAQC,EADRxR,EAAO,GAAIyR,aAAYxgB,EAAMtC,EAAK6O,EAGhB,oBAAXmK,GACTA,KACyB,gBAAXA,KACdA,GAAY+J,UAAS/J,IAEvBhZ,EAAI6O,EAAW,WAAawC,EAAK2R,QACjChjB,EAAIijB,YAAYpU,GAAYwC,EAC5BrR,EAAIijB,YAAYpU,GAAUqU,IAAIlK,EAAAA,YAC9B4J,EAAS,WAAmB,MAAO5iB,GAAIijB,YAAYpU,GAAUsU,OAI3DN,EAHG7J,EAAQoK,SAGF,SAASC,GAChB,GAAsC,GAAlCrjB,EAAIsjB,2BACN,KAAM,aAAezU,EAAW,wBAClC,OAAO7O,GAAIijB,YAAYpU,GAAUqU,IAAIG,IAL9B,SAASA,GAAU,MAAOrjB,GAAIijB,YAAYpU,GAAUqU,IAAIG,IAQnEE,kBAAkBvjB,EAAK6O,EAAU+T,EAAQC,GACrC7iB,EAAIwjB,kBACJD,kBAAkBvjB,EAAIwiB,SAAU3T,EAAU+T,EAAQC,GA6D1D,QAASH,iBAAgBe,EAAY1Q,EAAM2Q,EAAaC,GACpD,GAAI7gB,EACJ4gB,GAAcA,GAAe3Q,CAC7B,KAAKjQ,IAAK2gB,GAAY,CAClB,GAAIjhB,GAAQihB,EAAW3gB,EAEvB,IAAS,MAALA,GAAqB,KAARA,EAAE,GAInB,GAAuB,GAAnBA,EAAEc,QAAQ,OAAcd,EAAE,GAAG2L,eAAiB3L,EAAE,GAApD,CAwBA,GAAIN,YAAiB8O,QAAQ,CACzB,GAAI9O,YAAiBsP,qBAAqB,CACtCiB,EAAKjQ,GAAK8gB,OAAOphB,EAAMwP,YACnBe,EAAKyQ,mBACLG,EAAe7gB,GAAKiQ,EAAKjQ,GAC7B,UACG,GAAIN,YAAiBgP,WAAW,CACnChP,EAAMqhB,UACN9Q,EAAKjQ,GAAKN,EAAMshB,KAAKJ,EAAaC,GAC9B5Q,EAAKyQ,mBACLG,EAAe7gB,GAAKiQ,EAAKjQ,GAC7B,UACG,GAAIN,YAAiBmP,oBAAoB,CAC5CgR,qBAAqB,QAAS5P,EAAMjQ,GACpCiQ,EAAKkQ,YAAYngB,GAAG6gB,eAAiBA,EACrC5Q,EAAKkQ,YAAYngB,GAAGP,IAAMC,EAC1BuQ,EAAKkQ,YAAYngB,GAAGqgB,IAAM,WACtB,GAAInjB,GAAMgC,KAAK2hB,eAAe3hB,KAAKO,IAAIqP,WACvC,OAAO5P,MAAKO,IAAIsP,aAAe7R,EAAIijB,YAAYjhB,KAAKO,IAAIsP,cAAcsR,MAAQnjB,GAElF+S,EAAKkQ,YAAYngB,GAAGogB,IAAM,SAASG,EAAQU,EAAeL,EAAaC,GACnE,IAAK3hB,KAAKO,IAAIsP,aACV,KAAM,sDACV7P,MAAK2hB,eAAe3hB,KAAKO,IAAIqP,YAAYqR,YAAYjhB,KAAKO,IAAIsP,cAAcqR,IAAIG,EAAQU,EAAeL,EAAaC,GAExH,UACG,GAAInhB,YAAiBkP,uBAAuB,CAC/CiR,qBAAqBngB,EAAMF,KAAMyQ,EAAMjQ,GACvCiQ,EAAKkQ,YAAYngB,GAAGogB,IAAI1gB,EAAMA,OAAO,EAAMkhB,EAAaC,EACxD,UACG,GAAI5Q,EAAKjQ,IAAMN,YAAiByP,sBAAsB,CAEzDyQ,gBAAgBlgB,EAAOuQ,EAAKjQ,GAAI4gB,EAAaC,EAC7C,WAGJ5Q,EAAKkQ,aAAengB,IAAKiQ,GAAKkQ,YAC9BlQ,EAAKkQ,YAAYngB,GAAGogB,IAAI1gB,GAAO,EAAMkhB,EAAaC,GAC7C7gB,IAAKiQ,GACVA,EAAKjQ,GAAKN,EACLuQ,EAAKiR,eACVjR,EAAKiR,eAAelhB,EAAGN,GAEvByN,QAAQ5J,KAAK,2CAA8CvD,EAAI,+BAnEnE,CACI,GAAImhB,GAAcnhB,EAAE,GAAGuc,cAAgBvc,EAAE6G,MAAM,EAC/C,KAAKoJ,EAAKkR,GAAa,CACnBhU,QAAQ5J,KAAK,oBAAsB4d,EAAa,UAChD,UAEC,GAAuC,kBAA5BlR,GAAKkR,GAAYC,QAAuB,CACpDjU,QAAQ5J,KAAK4d,EAAa,oBAC1B,UAEJ,IAAKzhB,EAAMshB,KAAM,CACb,GAAI/R,GAAS,EACb,KAAK,GAAIoS,KAAKpR,GAAKkR,GAAYjS,WAC3BD,GAAa,GAAHoS,EAAO,GAAK,KACtBpS,GAAUgB,EAAKkR,GAAYjS,WAAWmS,GAAG3d,IAE7ChE,GAAMiP,IAAM,aAAeM,EAAS,MAAQvP,EAAMiP,IAAM,KACxDjP,EAAAA,aAAiB,EACjBA,EAAMqhB,UAEV9Q,EAAKkR,GAAYC,QAAQnR,EAAMvQ,EAAMshB,KAAKJ,EAAaC,KAiD/D,GAAIF,EAAWrR,WAA6C,IAAhCqR,EAAWrR,UAAUrP,OAAc,CAC3D,IAAIgQ,EAAKI,iBAGL,KAAM,8CAFNJ,GAAKkQ,YAAYlQ,EAAKI,kBAAkB+P,IAAIO,EAAWrR,WAAW,EAAMsR,EAAaC,GAMzFF,EAAWtQ,mBACXJ,EAAKI,iBAAmBsQ,EAAWtQ,kBACV,mBAAlBJ,GAAKqR,WAA2D,GAA/BrR,EAAKsR,yBAC/CtR,EAAKsR,wBAAyB,EAC9BtR,EAAKqR,aAqCX,QAASE,iBACLrU,QAAQC,IAAI,qBAAsBlO,MAqCtC,QAASuiB,eAAc5C,GACnB6C,QAAQtT,KAAKlP,KAAM2f,EAAKrK,OACxB,IAAIxU,EAGJd,MAAKyiB,MAAQ,aACbziB,KAAKwhB,iBAAmB7B,EAAK+C,gBAC7B1iB,KAAKwgB,SAAWb,EAAK1Z,QAGrBjG,KAAK2iB,UAAY,GAAIH,SAAQxiB,MAC7BA,KAAK2iB,UAAUP,UAAYR,WAC3B7B,OAAO6C,iBAAiBxd,KAAKpF,KAAK2iB,UAAUP,WAC5CpiB,KAAKoiB,UAAYpiB,KAAK2iB,UAAUP,UAEhCpiB,KAAK2iB,UAAUE,YAAcjB,WAC7B5hB,KAAK6iB,YAAc7iB,KAAK2iB,UAAUE,WAGlC,IAAIC,KACJ,KAAK,GAAI5kB,KAAOyhB,GAAK5K,QACf4K,EAAK5K,OAAOxF,eAAerR,IACA,mBAApByhB,GAAK5K,OAAO7W,IAA2C,MAApByhB,EAAK5K,OAAO7W,IACN,yBAA/CyhB,EAAK5K,OAAO7W,GAAK6kB,UAAUC,YAAYxe,MACQ,sBAA/Cmb,EAAK5K,OAAO7W,GAAK6kB,UAAUC,YAAYxe,MAC1Cse,EAAW1d,KAAKlH,EAIpB8B,MAAKijB,KAAO,GAAIT,SAAQxiB,MACxBA,KAAKijB,KAAKC,eAAiBtB,SAC3B5hB,KAAKijB,KAAKE,YAAcvB,SACxB5hB,KAAKijB,KAAKG,eAAiBxB,SAC3B5hB,KAAKijB,KAAKI,YAAczB,SACxB5hB,KAAKijB,KAAKK,cAAgB1B,SAC1B5hB,KAAKijB,KAAKM,cAAgB3B,QAC1B,KAAK,GAAI9gB,GAAI,EAAQ,GAAJA,IAAWA,EAC1Bd,KAAKijB,KAAK,QAAQniB,EAAE,WAAa8gB,QACnC5hB,MAAKijB,KAAKO,cAAgB5B,SAC1B5hB,KAAKijB,KAAKQ,YAAc7B,SACxB5hB,KAAKijB,KAAKS,cAAgB9B,SAC1B5hB,KAAKijB,KAAKU,YAAc/B,SACxB5hB,KAAKijB,KAAKW,YAAchC,SACxB5hB,KAAKijB,KAAKY,UAAYjC,SACtB5hB,KAAKijB,KAAKa,QAAUlC,SACpB5hB,KAAKijB,KAAKc,SAAWnC,SACrB5hB,KAAKijB,KAAKe,cAAgBpC,SAC1B5hB,KAAKijB,KAAKgB,aAAerC,SACzB5hB,KAAKijB,KAAKiB,cAAgBtC,SAC1B5hB,KAAKijB,KAAKkB,aAAevC,SACzB5hB,KAAKijB,KAAKmB,WAAaxC,SACvB5hB,KAAKijB,KAAKoB,UAAYzC,SACtB5hB,KAAKijB,KAAKqB,kBAAoB1C,SAC9B5hB,KAAKijB,KAAKsB,gBAAkB3C,SAC5B5hB,KAAKijB,KAAKuB,WAAa5C,SAEvB5hB,KAAKykB,cAAgB,WAAa,MAAO,IAW7C,QAASC,UAASnkB,GAChB,GAAmB,gBAARA,GAGTA,EAAM,KAAO4c,KAAKwH,MAAMpkB,GAAO,UAAWqb,SAAS,IAAItc,OAAO,IAAImN,kBAElE,IAAkB,eAARlM,IAAmBA,EAAIQ,QAAU,EAAG,CAE5C,GAAImc,GAAI,GACR3c,GAAM,OAAS4c,KAAKwH,MAAMzH,EAAI3c,EAAI,IAAM,IAAM4c,KAAKwH,MAAMzH,EAAI3c,EAAI,IAAM,IAAM4c,KAAKwH,MAAMzH,EAAI3c,EAAI,IAAM,IAG1G,MAAOA,GAGT,QAASqkB,cACL5kB,KAAK6kB,cAAgB,SAAS7mB,GAC1B,IAAK,GAAIwG,KAAQxE,MACb,GAAIA,KAAKwE,IAASxG,EACd,MAAOwG,IA0BvB,QAASsgB,cAAanF,GACdE,aAAaF,EAAK5K,OAAO5E,SAAW2U,aACpC9kB,KAAK+kB,YAAcpF,EAAK5K,OAAO3E,UAAU,GAEzCpQ,KAAK+kB,YAAcpF,EAAK5K,OAC5B/U,KAAKwgB,SAAWb,EAAK1Z,OAErB,IAAI+e,KAuBJ,IArBAhlB,KAAKilB,gBAAkB,SAAUzE,GAC/B,IAAK,GAAI1f,GAAI,EAAIA,EAAIkkB,EAAUjkB,SAAWD,EAAG,CAC3C,GAEIokB,GAFAC,EAAaH,EAAUlkB,GACvB2O,EAAM0V,EAAW,EAGa,oBAAvBC,WAAU3E,YACnBhR,EAAM2V,UAAU3E,UAAYhR,GAE5ByV,EADqB,mBAAZG,KAAI5V,GACR4V,IAAI5V,GAEJ3R,OAAOwnB,QAAQC,eAAe9V,IACf,KAAlB0V,EAAW,IACb3E,EAAS2E,EAAW,OACpBK,0BAA0BN,EAAI1E,EAAS2E,EAAW,MAGlDK,0BAA0BN,EAAI1E,KAEjCiF,KAAKzlB,MAEJ2f,EAAK5K,OAAO/D,mBAAoBhC,OACpC,CASE,IAAK,GARD0W,MACAC,EAAgB,SAAUR,GACxB,QAAQ5mB,KAAK4mB,EAAW,IAC1BH,EAAU5f,KAAK+f,GAEfO,EAActgB,KAAK+f,IACpBM,KAAKzlB,MAECc,EAAI,EAAIA,EAAI6e,EAAK5K,OAAO/D,SAASjQ,SAAWD,EACnD6kB,EAAWhG,EAAK5K,OAAO/D,SAASlQ,GAElC8kB,aAAY5lB,KAAM0lB,GACU,mBAAjB1lB,MAAKwgB,UAA4C,MAAjBxgB,KAAKwgB,UAC9CxgB,KAAKilB,gBAAgBjlB,KAAKwgB,WAqoBlC,QAASqF,YAAWtlB,GAChB,MAAY,GAAJA,EAGZ,QAASulB,SAAQnG,GACb4C,cAAcrT,KAAKlP,KAAM2f,EAOzB,IAHA3f,KAAKoiB,UAAYR,SACjB5hB,KAAKqiB,wBAAyB,EAET,OAAjBriB,KAAK+lB,QAAkB,CACvB/lB,KAAKqgB,IAAMN,OAAOiG,aAAeC,SAASvc,KAC1C1J,KAAKqgB,IAAI6F,UAAY,EACrB,IAAItO,GAAO5X,IACXA,MAAKqgB,IAAI8F,MAAMC,SAAW,WAC1BpmB,KAAKqgB,IAAI8F,MAAME,IAAM,IACrBrmB,KAAKqgB,IAAI8F,MAAMxa,KAAO,IACtB3L,KAAKqgB,IAAI8F,MAAMG,SAAW,aAErBtmB,MAAKqgB,MACNrgB,KAAKqgB,IAAM4F,SAASM,cAAc,QACtCvmB,KAAKqgB,IAAI8F,MAAMC,SAAW,UAE9BpmB,MAAKqgB,IAAI8F,MAAMK,cAAgB,OAC/BxmB,KAAKqgB,IAAIC,UAAYX,EAAK5K,OAAO5E,QAAUnQ,KAAKugB,GAAK,IAAMvgB,KAAKugB,GAAK,IACrEvgB,KAAKqgB,IAAIoG,IAAMzmB,KACfA,KAAK0mB,IAAM1mB,KAAKqgB,IAAI8F,MAEpBnmB,KAAK0mB,IAAIC,UAAY,aAErBhG,qBAAqB,OAAQ3gB,KAAM,QACnCA,KAAKmR,iBAAmB,OACxBwP,qBAAqB,OAAQ3gB,KAAM,YACnC2gB,qBAAqB,OAAQ3gB,KAAM,aACnC2gB,qBAAqB,OAAQ3gB,KAAM,UACnCA,KAAK+V,YACL/V,KAAK4mB,aACL5mB,KAAK6mB,cAAc3E,QAAQliB,KAAM,SAAS8mB,EAAWC,GAC7CA,IACAA,EAAUhR,SAASlD,OAAOkU,EAAUhR,SAASnU,QAAQ5B,MAAO,GAC5D+mB,EAAUC,kBACVD,EAAU1G,IAAI4G,YAAYjnB,KAAKqgB,MAE/ByG,GAAiD,IAApCA,EAAU/Q,SAASnU,QAAQ5B,QACxC8mB,EAAU/Q,SAAS3Q,KAAKpF,MACxB8mB,EAAUE,mBAEVF,GACAA,EAAUzG,IAAI6G,YAAYlnB,KAAKqgB,OAEvCrgB,KAAK6mB,cAAc3E,QAAQliB,KAAMmnB,iBACjCnnB,KAAK6mB,cAAc3E,QAAQliB,KAAMonB,iBACjCpnB,KAAKqnB,YAAYnF,QAAQliB,KAAM,SAASsnB,GACpC,IAAK,GAAIxmB,KAAKwmB,GAAS,CACnB,GAAIC,GAAQD,EAAQxmB,EAChBymB,GAAMhY,eAAe,UACrBgY,EAAMjS,OAAStV,KAEfA,KAAK4mB,UAAUxhB,KAAKmiB,MAI5BvnB,KAAKwhB,kBACPb,qBAAqB,MAAO3gB,KAAM,eACpC2gB,qBAAqB,OAAQ3gB,KAAM,KACnC2gB,qBAAqB,OAAQ3gB,KAAM,KACnC2gB,qBAAqB,OAAQ3gB,KAAM,SACnC2gB,qBAAqB,OAAQ3gB,KAAM,UACnC2gB,qBAAqB,OAAQ3gB,KAAM,iBACnC2gB,qBAAqB,OAAQ3gB,KAAM,kBACnC2gB,qBAAqB,OAAQ3gB,KAAM,QACnC2gB,qBAAqB,OAAQ3gB,KAAM,SACnC2gB,qBAAqB,OAAQ3gB,KAAM,OACnC2gB,qBAAqB,OAAQ3gB,KAAM,UACnC2gB,qBAAqB,OAAQ3gB,KAAM,oBACnC2gB,qBAAqB,OAAQ3gB,KAAM,kBACnC2gB,qBAAqB,OAAQ3gB,KAAM,YACnC2gB,qBAAqB,OAAQ3gB,KAAM,SACnC2gB,qBAAqB,OAAQ3gB,KAAM,KACnC2gB,qBAAqB,OAAQ3gB,KAAM,aACnC2gB,qBAAqB,OAAQ3gB,KAAM,WACnC2gB,qBAAqB,OAAQ3gB,KAAM,WACnC2gB,qBAAqB,OAAQ3gB,KAAM,QACnC2gB,qBAAqB,OAAQ3gB,KAAM,SACnCA,KAAKwnB,SAAStF,QAAQliB,KAAMmnB,iBAC5BnnB,KAAKynB,SAASvF,QAAQliB,KAAMonB,iBAC5BpnB,KAAK0nB,aAAaxF,QAAQliB,KAAMmnB,iBAChCnnB,KAAK2nB,cAAczF,QAAQliB,KAAMonB,iBACjCpnB,KAAK4nB,qBAAqB1F,QAAQliB,KAAMmnB,iBACxCnnB,KAAK6nB,sBAAsB3F,QAAQliB,KAAMonB,iBACzCpnB,KAAK8nB,OAAQ,EAEb9nB,KAAK+nB,gBAAkB,SAAUC,GAC/B,GAAIC,GAAc,WAChB,GAAIC,GAAWjC,SAASkC,eAAiBnoB,KAAKqgB,KAAO4F,SAASkC,eAAiBnoB,KAAKqgB,IAAI+H,UAEpFpoB,MAAK8nB,OAASI,IAChBloB,KAAK8nB,MAAQI,IACdzC,KAAKzlB,KACRgoB,GAAQK,iBAAiB,QAASJ,GAClCD,EAAQK,iBAAiB,OAASJ,IACjCxC,KAAKzlB,MAERA,KAAKsoB,aAAapG,QAAQliB,KAAM,SAAUqhB,GAC1B,GAAVA,GACyB,MAAvBrhB,KAAKqgB,IAAI+H,YACXpoB,KAAKqgB,IAAI+H,WAAWN,QACtB7B,SAASsC,SAAWvoB,KACpBA,KAAKwgB,SAASgI,YAAcxoB,MACnBimB,SAASsC,UAAYvoB,OAC9BimB,SAASwC,qBAAqB,QAAQ,GAAGX,QACzC7B,SAASsC,SAAWnD,UAAUsD,cAAcC,KAC5C3oB,KAAKwgB,SAASgI,YAAc,OAE7B/C,KAAKzlB,OAERA,KAAK4oB,uBAAwB,EAC7B5oB,KAAK6oB,wBAAyB,EAE9B7oB,KAAK8oB,QAAU,GAAItG,SAAQxiB,MAC3B2gB,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,QAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,SAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,OAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,UAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,oBAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,kBAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,QAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,YAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,WAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,cAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,eAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,aAC3CnI,qBAAqB,OAAQ3gB,KAAK8oB,QAAS,gBAC3C9oB,KAAK8oB,QAAQC,YAAY7G,QAAQliB,KAAMmnB,iBACvCnnB,KAAK8oB,QAAQE,aAAa9G,QAAQliB,KAAMmnB,iBACxCnnB,KAAK8oB,QAAQG,WAAW/G,QAAQliB,KAAMonB,iBACtCpnB,KAAK8oB,QAAQI,cAAchH,QAAQliB,KAAMonB,iBACzCpnB,KAAK8oB,QAAQK,wBAAwBjH,QAAQliB,KAAMmnB,iBACnDnnB,KAAK8oB,QAAQM,sBAAsBlH,QAAQliB,KAAMonB,iBACjDpnB,KAAK8oB,QAAQO,YAAYnH,QAAQliB,KAAMmnB,iBACvCnnB,KAAK8oB,QAAQO,YAAYnH,QAAQliB,KAAMonB,iBACvCpnB,KAAK8oB,QAAQQ,gBAAgBpH,QAAQliB,KAAMmnB,iBAC3CnnB,KAAK8oB,QAAQQ,gBAAgBpH,QAAQliB,KAAMonB,iBAC3CpnB,KAAK8oB,QAAQS,kBAAkBrH,QAAQliB,KAAMmnB,iBAC7CnnB,KAAK8oB,QAAQU,mBAAmBtH,QAAQliB,KAAMmnB,iBAC9CnnB,KAAK8oB,QAAQW,iBAAiBvH,QAAQliB,KAAMonB,iBAC5CpnB,KAAK8oB,QAAQY,oBAAoBxH,QAAQliB,KAAMonB,iBAC/CpnB,KAAK8oB,QAAQa,eAAezH,QAAQliB,KAAMmnB,iBAC1CnnB,KAAK8oB,QAAQa,eAAezH,QAAQliB,KAAMonB,iBAE1CzG,qBAAqB,OAAQ3gB,KAAM,UACnC2gB,qBAAqB,SAAU3gB,KAAM,SACrC2gB,qBAAqB,OAAQ3gB,KAAM,eACnCA,KAAK4pB,aAAa1H,QAAQliB,KAAM,SAASqhB,EAAQwI,GAC7C,GAAIC,GAAUC,EAAUjpB,EAAGqhB,EAAG6H,CAC9B,KAAKlpB,EAAI,EAAGA,EAAId,KAAKiqB,OAAOlpB,OAAQD,IAC5Bd,KAAKiqB,OAAOnpB,GAAG0D,OAAS6c,EACxB0I,EAAW/pB,KAAKiqB,OAAOnpB,GAClBd,KAAKiqB,OAAOnpB,GAAG0D,OAASqlB,IAC7BC,EAAW9pB,KAAKiqB,OAAOnpB,GAE/B,IAAIopB,GAAUlqB,KAAKmqB,eAAexiB,OAGlC,KAAK7G,IAAKopB,GAAS,CACf,GAAIE,GAAUF,EAAQppB,EACtBspB,GAAOtf,KAAOsf,EAAOC,OAAOD,EAAO9Y,UAEvC,GAAIyY,EAAU,CACV,GAAIO,GAAUP,EAASQ,gBAGvB,KAAKzpB,EAAI,EAAGA,EAAIwpB,EAAQvpB,OAAQD,IAAK,CACjC,GAAI0pB,GAASF,EAAQxpB,EAErB,KAAKqhB,EAAI,EAAGA,EAAIqI,EAAOC,SAAS1pB,OAAQohB,IAAK,CACzC,GAAIpR,GAAOyZ,EAAOC,SAAStI,GAEvBiI,GACAC,OAAQG,EAAOH,OACf/Y,SAAUP,EAAKO,SACfoZ,UAAWF,EAAOH,OAAOpJ,YAAYlQ,EAAKO,UAAUV,SACrC4Z,EAAOH,OAAOpJ,YAAYlQ,EAAKO,UAAU/Q,IACxDC,MAAOuQ,EAAKvQ,MACZsK,KAAM0f,EAAOH,OAAOtZ,EAAKO,UACzBvG,GAAIuB,OACJqe,SAAUH,EAAOG,UAEjBnR,GAAQ,CACZ,KAAKwQ,IAAKE,GACN,GAAIA,EAAQF,GAAGK,QAAUD,EAAOC,QACzBH,EAAQF,GAAG1Y,UAAY8Y,EAAO9Y,SAAU,CAC3CkI,GAAQ,EACR0Q,EAAQF,GAAKI,CACb,OAEH5Q,GACD0Q,EAAQ9kB,KAAKglB,EAGjB,IAAI5Q,IAAQ,CACZ,KAAKwQ,EAAI,EAAGA,EAAIhqB,KAAKmqB,eAAeppB,OAAQipB,IACxC,GAAIhqB,KAAKmqB,eAAeH,GAAGK,QAAUG,EAAOH,QACrCrqB,KAAKmqB,eAAeH,GAAG1Y,UAAYP,EAAKO,SAAU,CAChDkZ,EAAOI,oBACR5qB,KAAKmqB,eAAetX,OAAOmX,EAAG,GAClCxQ,GAAQ,CACR,QAEHA,GAASgR,EAAOI,oBACjB5qB,KAAKmqB,eAAe/kB,MAChBilB,OAAQG,EAAOH,OACf/Y,SAAUP,EAAKO,SACf9Q,MAAOgqB,EAAOH,OAAOpJ,YAAYlQ,EAAKO,UAAUV,SACjC4Z,EAAOH,OAAOpJ,YAAYlQ,EAAKO,UAAU/Q,IACxDuK,KAAMwB,OACNvB,GAAIyf,EAAOH,OAAOtZ,EAAKO,cAS3C,IAAKxQ,IAAKopB,GAAS,CACf,GAAIE,GAASF,EAAQppB,EACrBspB,GAAOC,OAAOpJ,YAAYmJ,EAAO9Y,UAAU4P,IAAIkJ,EAAO5pB,OAAO,EAAO4pB,EAAOC,OAC5BN,EAAWA,EAASvJ,SAAU4J,EAAOC,OAAO7J,UAE/F,IAAK1f,IAAKopB,GAAS,CACf,GAAIE,GAASF,EAAQppB,EACrBspB,GAAOrf,GAAKqf,EAAOC,OAAOD,EAAO9Y,UAC7B8Y,EAAOO,WACPP,EAAOC,OAAOD,EAAO9Y,UAAY8Y,EAAOC,OAAOD,EAAO9Y,UACtD8Y,EAAO5pB,MAAQ4pB,EAAOC,OAAOD,EAAO9Y,WAO5C,IAAK,GAFDuZ,GACAC,EAAS,EACJhqB,EAAI,EAAGA,EAAId,KAAK+qB,YAAYhqB,OAAQD,IAAK,CAC9Cd,KAAK+qB,YAAYjqB,GAAGuY,OAEpB,IAAI2R,GAAgBhrB,KAAK+qB,YAAYjqB,GACjCmqB,EAAY,CAChB,IAAID,EAAclgB,MAAQ+e,GAAUmB,EAAcE,YAAcF,EAAclgB,MAAQuW,EAClF4J,GAAa,MACZ,CAAA,GAA0B,KAAtBD,EAAclgB,KAGnB,QAFAmgB,KAGJ,GAAID,EAAcjgB,IAAMsW,GAAU2J,EAAcE,YAAcF,EAAcjgB,IAAM8e,EAC9EoB,GAAa,MACZ,CAAA,GAAwB,KAApBD,EAAcjgB,GAGnB,QAFAkgB,KAGAA,EAAYH,IACZA,EAASG,EACTJ,EAAaG,GAGjBH,GACAA,EAAWM,OAAOjB,IAG1B,IAAIkB,GAAeC,eAAe,UAAW,MAAO,YAChDC,EAAeD,eAAe,UAAW,MAAO,SAChDE,EAAeF,eAAe,UAAW,MAAO,YAEpDrrB,MAAKwrB,iBAAmB,WAKhB,IAAK,GAJDC,GAAY,UAAYzrB,KAAK0rB,SAAW,cAAgB1rB,KAAK2rB,MAAQ,IACrEC,EAAS,GACTC,EAAiB,cAEZ/qB,EAAI,EAAGA,EAAId,KAAKyrB,UAAU1qB,OAAQD,IAAK,CAC5C,GAAImS,GAAIjT,KAAKyrB,UAAU3qB,EACnBmS,aAAamY,GACbK,GAAa,aAAexY,EAAE6Y,KAAKC,EAAI,KAAO9Y,EAAE6Y,KAAKE,EAAI,KAAO/Y,EAAE6Y,KAAKG,EAAI,KAAOhZ,EAAEiZ,MAAQ,OACvFjZ,YAAaqY,GAClBG,GAAa,UAAYxY,EAAEkZ,OAAS,KAAOlZ,EAAEmZ,OAAS,IACjDnZ,YAAasY,GAClBE,GAAa,cAAgBxY,EAAE8Y,EAAI,OAAS9Y,EAAE+Y,EAAI,MACnB,mBAAnB/Y,GAAEoZ,cACS,UAAnBpZ,EAAEoZ,gBACJT,GAAU3Y,EAAEqZ,UAAY,IAAMrZ,EAAEjD,WAAa,MAE9B,gBAALiD,KACZwY,GAAaxY,GAEA,gBAAVjT,MAAKisB,IACdR,GAAa,sBAAwBzrB,KAAKisB,EAAI,OAChDjsB,KAAKqgB,IAAI8F,MAAMsF,UAAYA,EAC3BzrB,KAAKqgB,IAAI8F,MAAM0F,eAAiBA,EAChC7rB,KAAKqgB,IAAI8F,MAAMoG,aAAed,EAC9BzrB,KAAKqgB,IAAI8F,MAAMqG,gBAAkBf,EACjCzrB,KAAKqgB,IAAI8F,MAAMsG,qBAAuBZ,EACtC7rB,KAAKqgB,IAAI8F,MAAMuG,WAAajB,EAC5BzrB,KAAKqgB,IAAI8F,MAAMwG,YAAclB,EAC7BzrB,KAAKqgB,IAAI8F,MAAMyF,OAASA,EACxB5rB,KAAKqgB,IAAI8F,MAAMyG,SAAWhB,EAC1B5rB,KAAKqgB,IAAI8F,MAAM0G,aAAejB,EAC9B5rB,KAAKqgB,IAAI8F,MAAM2G,UAAYlB,GAEnC5rB,KAAK+sB,gBAAgB7K,QAAQliB,KAAMA,KAAKwrB,kBACxCxrB,KAAKgtB,aAAa9K,QAAQliB,KAAMA,KAAKwrB,kBACrCxrB,KAAKitB,iBAAiB/K,QAAQliB,KAAMA,KAAKwrB,kBACzCxrB,KAAKktB,eAAehL,QAAQliB,KAAM,SAASqhB,GACvCrhB,KAAK0mB,IAAIyG,WAAa9L,EAAS,UAAY,WAE/CrhB,KAAKotB,eAAelL,QAAQliB,KAAM,SAASqhB,GACvCrhB,KAAK0mB,IAAI2G,QAAUhM,IAEvBrhB,KAAKstB,YAAYpL,QAAQliB,KAAM,SAASqhB,GACpCrhB,KAAK0mB,IAAIJ,SAAWjF,EAAS,SAAW,YAE5CrhB,KAAKutB,SAASrL,QAAQliB,KAAM,SAASqhB,GACjCrhB,KAAKwrB,qBAETxrB,KAAKwnB,SAAStF,QAAQliB,KAAM,SAASqhB,GACjCrhB,KAAK0mB,IAAI/a,KAAO0V,EAAS,OAE7BrhB,KAAKynB,SAASvF,QAAQliB,KAAM,SAASqhB,GACjCrhB,KAAK0mB,IAAIL,IAAMhF,EAAS,OAE5BrhB,KAAK0nB,aAAaxF,QAAQliB,KAAM,SAASqhB,GACrCrhB,KAAK0mB,IAAI8G,MAAQnM,EAASA,EAAS,KAAO,SAE9CrhB,KAAK2nB,cAAczF,QAAQliB,KAAM,SAASqhB,GACtCrhB,KAAK0mB,IAAI+G,OAASpM,EAASA,EAAS,KAAO,SAG/CrhB,KAAK0tB,eAAiB,EACtB1tB,KAAK2tB,cAAgB,EACrB3tB,KAAK4tB,QAAU,EACf5tB,KAAK+rB,EAAI,EACT/rB,KAAKgsB,EAAI,EACThsB,KAAK8oB,QAAQ+E,QAAU,EACvB7tB,KAAK8tB,SAAU,EACf9tB,KAAKqtB,QAAU,EACfrtB,KAAKmqB,kBACLnqB,KAAKiqB,UACLjqB,KAAK+qB,eACL/qB,KAAK+tB,MAAQ,GACb/tB,KAAKyrB,aACLzrB,KAAK0rB,SAAW,EAChB1rB,KAAK2rB,MAAQ,EAGQ,OAAjB3rB,KAAK+lB,UACqBzZ,QAAtByT,OAAOiG,aACPgI,OAAOC,SAAW,WACdrW,EAAK8V,eAAiBM,OAAOE,YAC7BtW,EAAK+V,cAAgBK,OAAOG,YAEhCH,OAAOC,aAEPjuB,KAAK0tB,eAAiB1tB,KAAKqgB,IAAI+N,aAC/BpuB,KAAK2tB,cAAgB3tB,KAAKqgB,IAAIgO,cAItCruB,KAAKyiB,MAAQ,SAASvP,GAClB,GAAIpS,EACJ,IAAId,KAAK8tB,WAAY,EAAO,CACxB,GAAI9tB,KAAKsuB,UAAY,CACjB,GAAIC,IAAUvuB,KAAK0rB,UAAY,GAAK,IAAMvO,KAAKqR,GAC3CC,EAAatR,KAAKuR,IAAIH,GAAUvuB,KAAKwtB,MACrCmB,EAAaxR,KAAKuR,IAAIH,GAAUvuB,KAAKytB,MACzCva,GAAEP,OAIFO,EAAE0b,YAAc5uB,KAAKqtB,QACrBna,EAAE2b,UAAU7uB,KAAK2L,KAAO8iB,EAAYzuB,KAAKqmB,IAAMsI,GAC/Czb,EAAE4b,OAAOP,GACTrb,EAAE2b,WAAW7uB,KAAK2L,MAAO3L,KAAKqmB,KAE9BrmB,KAAKsuB,UAAUpb,GACfA,EAAE2b,WAAWJ,GAAaE,GAC1Bzb,EAAE6b,UAEN,IAAKjuB,EAAI,EAAGA,EAAId,KAAK+V,SAAShV,OAAQD,IAC9Bd,KAAK+V,SAASjV,IACXd,KAAK+V,SAASjV,GAAG2hB,OACpBziB,KAAK+V,SAASjV,GAAG2hB,MAAMvP,KAW3C,QAAS8b,SAAQrP,GACb,GAAIsP,KACJ,IAAItP,EAAK5K,iBAAkB/F,OACvB,IAAK,GAAIlO,KAAK6e,GAAK5K,OACfka,EAAK7pB,KAAKsa,WAAW3K,OAAQ4K,EAAK5K,OAAOjU,GAAIwU,OAAQqK,EAAKrK,OAAQrP,QAAS0Z,EAAK1Z,eAC/E0Z,GAAK5K,iBAAkB7E,iBAC5B+e,EAAK7pB,KAAKsa,WAAW3K,OAAQ4K,EAAK5K,OAAQO,OAAQqK,EAAKrK,OAAQrP,QAAS0Z,EAAK1Z,UAEjF,OAAOgpB,GASX,QAASC,eAAcvP,GACnBmG,QAAQ5W,KAAKlP,KAAM2f,GAEnBgB,qBAAqB,MAAO3gB,KAAM,WAClCA,KAAKmvB,eAAejN,QAAQliB,KAAMA,KAAKovB,gBACvCpvB,KAAKgnB,gBAAgB9E,QAAQliB,KAAMA,KAAKovB,gBACxCpvB,KAAKgnB,gBAAgB9E,QAAQliB,KAAMkvB,cAAcG,qBAEjDrvB,KAAK4tB,QAAU,EAmBnB,QAAS9M,aAAYxgB,EAAMtC,EAAKwG,GAC5BxE,KAAKhC,IAAMA,EACXgC,KAAKwE,KAAOA,EACZxE,KAAKghB,QAAUY,WAAY5jB,IAAIA,IAC/BgC,KAAK4Q,QAAU,KACf5Q,KAAK0hB,YAAc,KACnB1hB,KAAK2hB,eAAiB,KACtB3hB,KAAKQ,MAAQ8L,OACbtM,KAAKM,KAAOA,EACZN,KAAKsvB,UAAY,KAIjBtvB,KAAKuvB,eAsGT,QAASC,oBAAmB7P,GACxB4C,cAAcrT,KAAKlP,KAAM2f,GAEzBgB,qBAAqB,WAAY3gB,KAAM,UACvC2gB,qBAAqB,OAAQ3gB,KAAM,YACnC2gB,qBAAqB,OAAQ3gB,KAAM,sBAEnCA,KAAK2qB,UAAW,EAChB3qB,KAAK4qB,oBAAqB,EAC1B5qB,KAAKyqB,YAELzqB,KAAKgiB,eAAiB,SAASnV,EAAUrM,GACrCR,KAAKyqB,SAASrlB,MACVkM,SAAUzE,EACVrM,MAAOA,KAQnB,QAASivB,YAAWlvB,GAChB,MAAOA,GAKX,QAASiiB,SAAQlN,GACbtV,KAAK+lB,QAAUzQ,EACXA,GAAUA,EAAOia,aACjBja,EAAOia,YAAYnqB,KAAKpF,MAE5BA,KAAKuvB,eACLvvB,KAAKihB,eAELjhB,KAAK0vB,SAAWC,YAChB3vB,KAAK4vB,QAAU,WAIX,IAHI5vB,KAAK6vB,YACP7vB,KAAK6vB,WAAWhN,cAEX7iB,KAAKuvB,YAAYxuB,OAAS,GAAG,CAChC,GAAIgQ,GAAO/Q,KAAKuvB,YAAY,EACxBxe,GAAK6e,QACL7e,EAAK6e,UAEL7e,EAAK+e,WAAW9vB,MAGxB,IAAK,GAAIc,KAAKd,MAAKihB,YAEf,IADA,GAAI5R,GAAOrP,KAAKihB,YAAYngB,GACrBuO,EAAKkgB,YAAYxuB,OAAS,GAC7BsO,EAAKkgB,YAAY,GAAGO,WAAWzgB,EAGnCrP,MAAK+lB,SAAW/lB,KAAK+lB,QAAQwJ,aAC7BvvB,KAAK+lB,QAAQwJ,YAAY1c,OAAO7S,KAAK+lB,QAAQwJ,YAAY3tB,QAAQ5B,MAAO,GAK5EA,KAAKsV,OAAShJ,QAItB,QAAS6a,iBAAgB9F,EAAQwI,EAAQhd,GACrC,GAAIic,GAAU9oB,KAAK8oB,SAAW9oB,IAC9B,KAAIA,KAAK+vB,kBAAT,CAEA/vB,KAAK+vB,mBAAoB,CAEzB,IAAI9c,GAAGyD,EAAG8W,EAAOzB,EAAGpgB,EAAMqkB,EAAIjkB,EAC1BkkB,EAAKnH,EAAQoH,YAAcpH,EAAQ+E,QACnCsC,EAAKrH,EAAQsH,aAAetH,EAAQ+E,OAGpC7tB,MAAK4oB,uBAAqC,iBAAZ/b,EAC9B2gB,EAAQxtB,KAAK2tB,cACI,SAAZ9gB,IACL7M,KAAK4oB,uBAAwB,GAGNtc,UAAtB2G,EAAI6V,EAAQuH,OACRpd,EAAEgO,YAAYtV,KAAKqV,QAAQsP,YAAYtwB,KAAMmnB,kBAC9ClU,EAAEgO,YAAYtV,KAAKqV,QAAQkB,QAAQliB,KAAMmnB,iBACxClU,EAAEgO,YAAYuM,MAAMxM,QAAQsP,YAAYtwB,KAAMmnB,kBAC/ClU,EAAEgO,YAAYuM,MAAMxM,QAAQkB,QAAQliB,KAAMmnB,iBAE9CnnB,KAAK4oB,uBAAwB,EAC7B4E,EAAQva,EAAEua,MAAQyC,EAAKE,EACvBpE,EAAI9Y,EAAEtH,MAAQ3L,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAAKskB,EACpDtkB,EAAOsH,EAAEtH,KAAOskB,EAChBlkB,EAAQkH,EAAElH,MAAQokB,EAClBH,GAAMrkB,EAAOI,GAAS,GACYO,UAA1B2G,EAAI6V,EAAQyH,WACftd,EAAEgO,YAAYuP,iBAAiBxP,QAAQsP,YAAYtwB,KAAMmnB,kBAC1DlU,EAAEgO,YAAYuP,iBAAiBxP,QAAQkB,QAAQliB,KAAMmnB,iBAEzDzQ,EAAI8W,GAASxtB,KAAKwtB,MAClBwC,EAAK/c,EAAEud,iBACPzE,EAAIiE,EAAKtZ,EAAI,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GACnDA,EAAOqkB,EAAKtZ,EAAI,EAChB3K,EAAQikB,EAAKtZ,EAAI,GACapK,UAAtB2G,EAAI6V,EAAQnd,OACpBA,EAAOsH,EAAIgd,EACiB3jB,UAAvBmkB,EAAI3H,EAAQ/c,QACbA,EAAQ0kB,EAAIN,EACZnwB,KAAK4oB,uBAAwB,EAC7B4E,EAAQzhB,EAAQJ,EAChBogB,EAAIpgB,GAAQ3L,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAC7CqkB,GAAMjkB,EAAQJ,GAAQ,GACqBW,UAAnC0jB,EAAKlH,EAAQ0H,mBACrBxwB,KAAK4oB,uBAAwB,EAC7B4E,EAAsB,GAAbwC,EAAKrkB,GACdogB,EAAIpgB,GAAQ3L,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAC7CI,EAAQ,EAAIikB,EAAKrkB,IAEjB+K,EAAI8W,GAASxtB,KAAKwtB,MAClBzB,EAAIpgB,GAAQ3L,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAC7CI,EAAQJ,EAAO+K,EACfsZ,EAAKrkB,EAAO+K,EAAI,IAEWpK,UAAvB2G,EAAI6V,EAAQ/c,QACpBA,EAAQkH,EAAIkd,EAC4B7jB,UAAnC0jB,EAAKlH,EAAQ0H,mBACdxwB,KAAK4oB,uBAAwB,EAC7B4E,EAAuB,GAAdzhB,EAAQikB,GACjBjE,EAAI,EAAIiE,EAAKjkB,GAAS/L,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GACvDA,EAAO,EAAIqkB,EAAKjkB,IAEhB2K,EAAI8W,GAASxtB,KAAKwtB,MAClBzB,EAAIhgB,EAAQ2K,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAClDA,EAAOI,EAAQ2K,EACfsZ,EAAKjkB,EAAQ2K,EAAI,IAEsBpK,UAAnC0jB,EAAKlH,EAAQ0H,mBACrB9Z,EAAI8W,GAASxtB,KAAKwtB,MAClBzB,EAAIiE,EAAKtZ,EAAI,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GACnDA,EAAOqkB,EAAKtZ,EAAI,EAChB3K,EAAQikB,EAAKtZ,EAAI,IAEb1W,KAAKsV,SAAWtV,KAAKsV,OAAO2L,YAAYtV,KAAKqV,QAAQsP,YAAYtwB,KAAMmnB,kBACvEnnB,KAAKsV,OAAO2L,YAAYtV,KAAKqV,QAAQkB,QAAQliB,KAAMmnB,iBAEvDzQ,EAAI8W,GAASxtB,KAAKwtB,MAClB7hB,EAAO3L,KAAK+rB,GAAK/rB,KAAKsV,OAAStV,KAAKsV,OAAO3J,KAAO,GAClDI,EAAQJ,EAAO+K,EACfsZ,EAAKrkB,EAAO+K,EAAI,GAGPpK,SAATX,IACA3L,KAAK2L,KAAOA,GACLW,SAAP0jB,IACAhwB,KAAKwwB,iBAAmBR,GACd1jB,SAAVP,IACA/L,KAAK+L,MAAQA,GACPO,SAANyf,IACA/rB,KAAK+rB,EAAIA,GACCzf,SAAVkhB,IACAxtB,KAAKwtB,MAAQA,GAEjBxtB,KAAK+vB,mBAAoB,GAG7B,QAAS3I,iBAAgB/F,EAAQwI,EAAQhd,GACrC,GAAIic,GAAU9oB,KAAK8oB,SAAW9oB,IAC9B,KAAIA,KAAK+vB,kBAAT,CAEA/vB,KAAK+vB,mBAAoB,CAEzB,IAAI9c,GAAGyD,EAAG+W,EAAQzB,EAAG3F,EAAKqK,EAAIC,EAC1BC,EAAK9H,EAAQ+H,WAAa/H,EAAQ+E,QAClCiD,EAAKhI,EAAQiI,cAAgBjI,EAAQ+E,OAGrC7tB,MAAK6oB,wBAAsC,kBAAZhc,EAC/B4gB,EAASztB,KAAK0tB,eACG,UAAZ7gB,IACL7M,KAAK6oB,wBAAyB,GAGPvc,UAAtB2G,EAAI6V,EAAQuH,OACRpd,EAAEgO,YAAYoF,IAAIrF,QAAQsP,YAAYtwB,KAAMonB,kBAC7CnU,EAAEgO,YAAYoF,IAAIrF,QAAQkB,QAAQliB,KAAMonB,iBACvCnU,EAAEgO,YAAYwM,OAAOzM,QAAQsP,YAAYtwB,KAAMonB,kBAChDnU,EAAEgO,YAAYwM,OAAOzM,QAAQkB,QAAQliB,KAAMonB,iBAE/CpnB,KAAK6oB,wBAAyB,EAC9B4E,EAASxa,EAAEwa,OAASmD,EAAKE,EACzB9E,EAAI/Y,EAAEoT,KAAOrmB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAAKuK,EAClDvK,EAAMpT,EAAEoT,IAAMuK,EACdD,EAAS1d,EAAE0d,OAASG,EACpBJ,GAAMrK,EAAMsK,GAAU,GACYrkB,UAA1B2G,EAAI6V,EAAQyH,WACftd,EAAEgO,YAAY+P,eAAehQ,QAAQsP,YAAYtwB,KAAMonB,kBACxDnU,EAAEgO,YAAY+P,eAAehQ,QAAQkB,QAAQliB,KAAMonB,iBAEvD1Q,EAAI+W,GAAUztB,KAAKytB,OACnBiD,EAAKzd,EAAE+d,eACPhF,EAAI0E,EAAKha,EAAI,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAClDA,EAAMqK,EAAKha,EAAI,EACfia,EAASD,EAAKha,EAAI,GACWpK,UAArB2G,EAAI6V,EAAQzC,MACpBA,EAAMpT,EAAI2d,EACmBtkB,UAAxBmkB,EAAI3H,EAAQ6H,SACbA,EAASF,EAAIK,EACb9wB,KAAK6oB,wBAAyB,EAC9B4E,EAASkD,EAAStK,EAClB2F,EAAI3F,GAAOrmB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAC3CqK,GAAMC,EAAStK,GAAO,GACmB/Z,UAAjCokB,EAAK5H,EAAQkI,iBACrBhxB,KAAK6oB,wBAAyB,EAC9B4E,EAAsB,GAAZiD,EAAKrK,GACf2F,EAAI3F,GAAOrmB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAC3CsK,EAAS,EAAID,EAAKrK,IAElB3P,EAAI+W,GAAUztB,KAAKytB,OACnBzB,EAAI3F,GAAOrmB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAC3CsK,EAAStK,EAAM3P,EACfga,EAAKrK,EAAM3P,EAAI,IAEapK,UAAxB2G,EAAI6V,EAAQ6H,SACpBA,EAAS1d,EAAI6d,EACyBxkB,UAAjCokB,EAAK5H,EAAQkI,iBACdhxB,KAAK6oB,wBAAyB,EAC9B4E,EAAyB,GAAfkD,EAASD,GACnB1E,EAAI,EAAI0E,EAAKC,GAAU3wB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GACvDA,EAAM,EAAIqK,EAAKC,IAEfja,EAAI+W,GAAUztB,KAAKytB,OACnBzB,EAAI2E,EAASja,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAClDA,EAAMsK,EAASja,EACfga,EAAKC,EAASja,EAAI,IAEmBpK,UAAjCokB,EAAK5H,EAAQkI,iBACrBta,EAAI+W,GAAUztB,KAAKytB,OACnBzB,EAAI0E,EAAKha,EAAI,GAAK1W,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAClDA,EAAMqK,EAAKha,EAAI,EACfia,EAASD,EAAKha,EAAI,IAEd1W,KAAKsV,SAAWtV,KAAKsV,OAAO2L,YAAYoF,IAAIrF,QAAQsP,YAAYtwB,KAAMonB,kBACtEpnB,KAAKsV,OAAO2L,YAAYoF,IAAIrF,QAAQkB,QAAQliB,KAAMonB,iBAEtD1Q,EAAI+W,GAAUztB,KAAKytB,OACnBpH,EAAMrmB,KAAKgsB,GAAKhsB,KAAKsV,OAAStV,KAAKsV,OAAO+Q,IAAM,GAChDsK,EAAStK,EAAM3P,EACfga,EAAKrK,EAAM3P,EAAI,GAGPpK,SAAR+Z,IACArmB,KAAKqmB,IAAMA,GACJ/Z,SAAPokB,IACA1wB,KAAKgxB,eAAiBN,GACXpkB,SAAXqkB,IACA3wB,KAAK2wB,OAASA,GACRrkB,SAAN0f,IACAhsB,KAAKgsB,EAAIA,GACE1f,SAAXmhB,IACAztB,KAAKytB,OAASA,GAElBztB,KAAK+vB,mBAAoB,GAp6M7BjyB,OAAO+S,WAAa,SAAStQ,EAAKgQ,GAK9BvQ,KAAAA,YAAgBuQ,GAAmB,SAAXA,EAAK,IAAiBA,EAAK,GAAG,IAAwB,UAAlBA,EAAK,GAAG,GAAG,GACvEvQ,KAAKyP,IAAMlP,GAGfzC,OAAO+S,WAAW5B,UAAUgiB,OAAS,WACjC,OAAQxhB,IAAKzP,KAAKyP,IACdyhB,KAAMC,KAAKC,UAAUpxB,KAAKkxB,MAC1B3gB,KAAM4gB,KAAKC,UAAUpxB,KAAKuQ,QAMlCM,WAAW5B,UAAU4S,QAAU,WAC3B7hB,KAAK8hB,KAAO,GAAIhT,UAAS,oBAAqB,qBAAsB,qDAAwD9O,KAAAA,YAAgB,GAAK,WAAcA,KAAKyP,KAiFxK,IAAIhK,UAAWsJ,eACP,QACA,OACA,QACA,QACA,WACA,UACA,SACA,KACA,OACA,UACA,MACA,WACA,KACA,KACA,aACA,MACA,SACA,SACA,QACA,MACA,SACA,MACA,OACA,QACA,SAGJ0Q,eAAiB1Q,eACb,WACA,UACA,OACA,OACA,QACA,WACA,SACA,OACA,SACA,UACA,QACA,QACA,OACA,aACA,SACA,MACA,YACA,OACA,SACA,UACA,UACA,YACA,SACA,QACA,SACA,QACA,eACA,SACA,YACA,aAGJ1M,2BAA6B0M,eACzB,SACA,MACA,SACA,QACA,OACA,SAGJrJ,cAAgBqJ,eACZ,QACA,OACA,OACA,cAGJhJ,eAAiBgJ,cAAcI,WAAW,kBAE1C/P,cAAgB,iBAChBG,cAAgB,YAChBC,cAAgB,+CAEhB0F,UAAY6J,eACR,KACA,aACA,SACA,MACA,OACA,SACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,MACA,KACA,MACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,OACA,KACA,KACA,KACA,KACA,OAGJpM,iBAAmBoM,cAAcI,WAAW,YAE5C7M,uBAAyByM,cAAcI,WAAW,aAElDrJ,WAAaiJ,cAAcI,WAAW,cAEtCkiB,iBAAmBtiB,cAAcI,WAAW,UAK5C9Q,SACIC,OAAQ,GAAIgzB,QAAO;AACnB1yB,iBAAkB,GAAI0yB,QAAO,2kEAC7BzyB,qBAAsB,GAAIyyB,QAAO,msCACjCvyB,sBAAuB,GAAIuyB,QAAO,sEA6D1C5xB,gBAAeuP,UAAU2M,SAAW,WAC5B,MAAO5b,MAAKL,QAAU,WAAaK,KAAKJ,KAAO,UAAYI,KAAKH,IAAM,UAAYG,KAAKF,IAAM,MAAaE,KAAKD,QAAU,KAAOC,KAAKE,MAyB7I,IAAIsB,WAoUA+M,aAAeQ,eACX,SACA,OACA,SACA,KACA,KACA,IACA,IACA,IACA,MAGJ3M,cAAgB2M,eAAgB,KAAM,OAEtC3C,WAAa,SAAUxC,EAAGrH,EAAKzB,GAC3B,KAAOA,EAAI8I,EAAE7I,QACLwB,EAAIqH,EAAE9I,IAAM8I,EAAE9I,GAAGxB,OAAO,EAAGsK,EAAE9I,GAAGC,OAAS,GACzCD,GAER,OAAOyB,KAEN,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,OAAQ,KAAM,KAAM,OAC/DgvB,KAAK,GACP,GAGJzlB,WAAa,SAAUlC,EAAGrH,GACtB,IAAK,GAAIzB,GAAI,EAAG8C,EAAI,EAAG9C,EAAI8I,EAAE7I,SAAUD,IAAK8C,EAEpC,IAAK,GADDsU,GAAItO,EAAE9I,GACDqhB,EAAI,EAAGA,EAAIjK,EAAEnX,SAAUohB,EACxB5f,EAAI2V,EAAEiK,IAAMve,CAG5B,OAAOrB,MAGE,OACA,OACA,MACA,MACA,MACA,KAAM,MAAO,KAAM,QACnB,IAAK,IAAK,KAAM,KAAM,KAAM,eAC5B,KAAM,KAAM,QACZ,IAAK,MACL,IAAK,IAAK,UAKvBkG,uBAAyBsG,eAAgB,MAAO,KAAM,QAAS,WAE/DP,mBAAqBO,eAAgB,OAAQ,MAAO,SAAU,SAAU,QAU5E5I,eAAc8I,UAAU2M,SAAW,WAAa,MAAO5b,MAAKwE,MAE5D+B,aAAairB,YAAc,EAC3BjrB,aAAaoI,WAAa,CAg2B1B,IAAItK,MAAO,YAEXmL,WAAUP,UAAY,GAAI4B,YAoNL,mBAAV/S,UACTA,OAAOyI,aAAeA,aAsSxB,IAAIkrB,QAAS,WACL,GAAIC,GAAS,wDACb,OAAO,UAASvyB,GACR,GAAIoD,GAAM,EACV,GACQA,GAAMmvB,EAAOrwB,OAAOlC,EAAM,IAAMoD,EAChCpD,EAAMge,KAAKC,MAAMje,EAAM,UACtBA,EAAM,EACf,OAAOoD,MAIvBgT,OAAMtG,WACE6H,IAAK,SAAStS,GACN,IAAK,GAAIwJ,GAAIhO,KAAMgO,EAAGA,EAAIA,EAAEsH,OACpB,GAAInT,IAAI6L,EAAEwH,MAAOhR,GACT,MAAOwJ,IAE/B2jB,YAAa,SAASC,GACd,IAAK,GAAI5jB,GAAIhO,KAAMgO,EAAGA,EAAIA,EAAEsH,OACpB,GAAInT,IAAI6L,EAAE0H,YAAakc,GACf,MAAO5jB,IAE/BijB,OAAQ,WACA,OACQzb,MAAOxV,KAAKwV,MACZM,UAAW9V,KAAK8V,UAChBD,UAAW7V,KAAK6V,YAIhC0B,aAAc,WAeN,OAAS,CACD,GAA8Bsa,GAA1B3U,EAAIuU,SAASzxB,KAAK2V,MAItB,IADAkc,EAAQ7xB,KAAK2xB,YAAYzU,KACrB2U,GAAS7xB,KAAK4V,KAAKic,EAAMnc,YAAYwH,MAAQ2U,KAIjDA,EAAQ7xB,KAAK8W,IAAIoG,KACb2U,GAASA,IAAU7xB,MAAQA,KAAK4V,KAAKsH,KAAO2U,GAAUA,EAAMF,YAAYzU,OAIxE/a,IAAInC,KAAK4V,KAAMsH,IAAsB,MAAhBld,KAAK4V,KAAKsH,KAI9B9B,cAAc8B,IAGnB,MAAOA,KAGvBxF,WAAY,SAASlT,EAAM0Y,GAEnB,MADAld,MAAK0V,YAAYwH,GAAK1Y,EACfxE,KAAKyV,QAAQjR,GAAQ0Y,GAEpCjG,YAAa,SAASzS,EAAM0S,GACpB,GAAIlX,KAAK8V,WAAa9V,KAAK6V,UAAW,MAAOrR,EAC7C,IAAIwJ,GAAIhO,KAAK8W,IAAItS,EACjB,OAAKwJ,GACD7L,IAAI6L,EAAEyH,QAASjR,GAAcwJ,EAAEyH,QAAQjR,GACtC0S,EACElJ,EAAE0J,WAAWlT,EAAMwJ,EAAEuJ,gBADL/S,EAFRA,GAKvBsV,WAAY,SAAStV,GACb,MAAOA,KAASxE,KAAKsV,QAAUtV,KAAK6V,WAAa7V,KAAK8V,WAAa9V,KAAK4V,KAAKpR,IAErF6R,OAAQ,SAAS7R,EAAMlE,GACf,MAAY,OAARkE,GACgB,OAARlE,GAAkB6B,IAAInC,KAAKwV,MAAOhR,KAC9BxE,KAAKwV,MAAMhR,GAAQlE,GAAQ,OAC5BkE,GAHf,QAsOhB,IAAIH,MAAO,aAyEPkU,cAAgB,WAMZ,QAASuZ,GAAS1mB,GACV,OAAQA,EAAK,IACT,IAAK,SACL,IAAK,MACD,MAAOA,GAAK,EAChB,KAAK,OACL,IAAK,OACD,OAAQA,EAAK,IACT,IAAK,OAAQ,OAAO,CACpB,KAAK,QAAS,OAAO,EAEzB,KACJ,KAAK,eACD,OAAQA,EAAK,IACT,IAAK,IAAK,OAAQ0mB,EAAS1mB,EAAK,GAChC,KAAK,SAAU,aAAc0mB,GAAS1mB,EAAK,GAC3C,KAAK,IAAK,OAAQ0mB,EAAS1mB,EAAK,GAChC,KAAK,IAAK,OAAQ0mB,EAAS1mB,EAAK,GAChC,KAAK,IAAK,OAAQ0mB,EAAS1mB,EAAK,IAEpC,KACJ,KAAK,SACD,GAAIO,GAAOP,EAAK,GAAIW,EAAQX,EAAK,EACjC,QAAQA,EAAK,IACT,IAAK,KAAe,MAAO0mB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,MAAe,MAAO+lB,GAASnmB,KAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,MAAe,MAAO+lB,GAASnmB,KAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,MAAe,MAAO+lB,GAASnmB,KAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,IAAe,MAAO+lB,GAASnmB,GAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,EAAS/lB,EAC9D,KAAK,KAAe,MAAO+lB,GAASnmB,IAAiBmmB,GAAS/lB,EAC9D,KAAK,aAAe,MAAO+lB,GAASnmB,YAAiBmmB,GAAS/lB,IAG1E,KAAMgmB,GApDd,GAAIA,KAuDJ,OAAO,UAAS3mB,EAAMc,EAAK8lB,GACnB,IACQ,GAA0B9pB,GAAtB3H,EAAMuxB,EAAS1mB,EACnB,cAAe7K,IACX,IAAK,SAAU2H,GAAS,SAAU3H,EAAO,MACzC,KAAK,SAAU2H,GAAS,MAAO3H,EAAO,MACtC,KAAK,UAAW2H,GAAS,OAAQzE,OAAOlD,GAAQ,MAChD,SAAS,KAAM,IAAI0xB,OAAM,wCAA4C1xB,IAEzE,MAAO2L,GAAIgD,KAAK9D,EAAMlD,EAAK3H,GACjC,MAAMN,GACA,GAAIA,IAAO8xB,EAAe,CAClB,GAAe,UAAX3mB,EAAK,IACU,OAAXA,EAAK,IAA0B,OAAXA,EAAK,MACxBsN,UAAUtN,EAAK,KAAOsN,UAAUtN,EAAK,KAClCgN,aAAahN,EAAK,KAAOgN,aAAahN,EAAK,MAGlD,GAAI4mB,GAAiB,UAAX5mB,EAAK,KACI,MAAXA,EAAK,IAAyB,MAAXA,EAAK,IAEjC,IACI,GAAI8mB,GAAOJ,EAAS1mB,EAAK,GACzBA,GAAoB,MAAXA,EAAK,KAAe8mB,EAAO9mB,EAAK,GAAK8mB,IAC1B,MAAX9mB,EAAK,KAAe8mB,EAAOA,EAAU9mB,EAAK,KAC3CA,EACV,MAAM+mB,SAVJ/mB,GAAK,GAAKA,EAAK,GAAG9L,OAAO,EAAG,EAcpC,OAAO0yB,GAAKA,EAAG9iB,KAAK9D,EAAMA,GAAQ,KAErC,KAAMnL,QAykB/B+c,mBAA6BjO,eACzB,OACA,QACA,SACA,SACA,MACA,MACA,OACA,WAiCJsP,sBAAgCtP,eAAgB,KAAM,QAAS,KAAM,MAAO,SAAU,SA2hBtFqD,KAEJ,WA4BQ,QAASggB,GAAM7xB,GAAOP,KAAKqyB,EAAI9xB,EAC/B,QAAS+xB,GAAO/xB,GAAOP,KAAKqyB,EAAI9xB,EA5BhC6R,IAAM,SAASxI,EAAGgF,EAAG2jB,GAEb,QAASC,KACD,GAAIjyB,GAAMqO,EAAEM,KAAKqjB,EAAG3oB,EAAE9I,GAAIA,EACtBP,aAAe6xB,IACX7xB,EAAMA,EAAI8xB,EACN9xB,YAAe+xB,GACXjM,EAAIjhB,KAAK+C,MAAMke,EAAK9lB,EAAI8xB,GAExBhM,EAAIjhB,KAAK7E,IAGhBA,GAAOsZ,IACJtZ,YAAe+xB,GACX/vB,EAAI6C,KAAK+C,MAAM5F,EAAKhC,EAAI8xB,GAExB9vB,EAAI6C,KAAK7E,IAfjC,GAAwBO,GAApByB,KAAU8jB,IAmBd,IAAIzc,YAAaoF,OAAO,IAAKlO,EAAI,EAAGA,EAAI8I,EAAE7I,SAAUD,EAAG0xB,QAClD,KAAK1xB,IAAK8I,GAAOzH,IAAIyH,EAAG9I,IAAI0xB,GACjC,OAAOnM,GAAIxX,OAAOtM,IAE1B6P,IAAIuF,OAAS,SAASpX,GAAO,MAAO,IAAI6xB,GAAM7xB,IAC9C6R,IAAIS,OAAS,SAAStS,GAAO,MAAO,IAAI+xB,GAAO/xB,GAC/C,IAAIsZ,GAAOzH,IAAIyH,WAwEvB,WAqLA,QAAS4Y,GAAYhjB,GAGjB,QAASijB,GAASjjB,EAAKrJ,EAAKusB,GACxB,GAAI7xB,EACJ,IAAK6xB,EAQD,IADA7xB,EAAI,EACGA,EAAI2O,EAAI1O,QACP0O,EAAInQ,OAAOwB,EAAGsF,EAAIrF,SAAWqF,GAGjC,OAAOqJ,EAAI3O,IACV,IAAK,IACF2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,KAAK,GACvCA,EAAI,CACJ,MACH,KAAK,IACF2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,KAAK,GACvCA,EAAI,CACJ,MACH,KAAK,IACgB,KAAd2O,EAAI3O,EAAI,IACR2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,MAClCA,EAAI,GACiB,KAAd2O,EAAI3O,EAAI,IACf2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,MAClCA,EAAI,GAEJA,GAEJ,MACH,SACGA,QA/BR,IADAA,EAAI2O,EAAI7N,QAAQwE,GACP,IAALtF,EAEA,MADAmN,SAAQC,IAAI,oBAAsB9H,EAAM,cACjC,EAiCf,OAAOqJ,GAAInQ,OAAOwB,EAAIsF,EAAIrF,QAe9B,IATA,GAKI6xB,GACA3X,EANAna,EAAI,EAEJ+xB,EAAO,GAEPC,EAAU,4BAGVC,KAEGjyB,EAAI2O,EAAI1O,QACX,OAAQ0O,EAAI3O,IACX,IAAK,IACF2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,KAAK,GACvCA,EAAI,CACJ,MACH,KAAK,IACF2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,KAAK,GACvCA,EAAI,CACJ,MACH,KAAK,IACgB,KAAd2O,EAAI3O,EAAI,IACR2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,MAClCA,EAAI,GACiB,KAAd2O,EAAI3O,EAAI,IACf2O,EAAMijB,EAASjjB,EAAInQ,OAAOwB,EAAI,GAAI,MAClCA,EAAI,IAEJ+xB,GAAQpjB,EAAI3O,GACZA,IAEJ,MACJ,SACI+xB,GAAQpjB,EAAI3O,GACZA,IAWR,IALA8xB,EAAUC,EAAKG,MAAMF,GAKhBhyB,EAAI,EAAGA,EAAI8xB,EAAQ7xB,OAAQD,IAC5Bma,EAAM,cAAcqC,KAAKsV,EAAQ9xB,IAC7Bma,GACA8X,EAAQ3tB,KAAK6V,EAAI,GAGzB,OAAO8X,GAtPXxN,eAAiB,SAAUpF,EAAK8S,GAC5B,GAAmC,mBAAxBC,iBAAgB/S,GAAqB,CAC9C,GAAIgT,GAAM,GAAIC,eAGd,IAFAD,EAAIE,KAAK,MAAOlT,GAAK,GAEjB8S,EACA,IAAME,EAAIG,KAAK,MAAS,MAAO3f,GAAK,OAAO,MAE7Cwf,GAAIG,KAAK,KAEX,IAAkB,KAAdH,EAAII,QAA+B,GAAdJ,EAAII,OAEzB,MADAtlB,SAAQC,IAAI,cAAgBiS,EAAM,YAAcgT,EAAIK,aAAcL,IAC3D,CAEXD,iBAAgB/S,GAAOgT,EAAIK,aAE7B,MAAON,iBAAgB/S,IAEU,mBAA1BriB,QAAOo1B,kBAChBp1B,OAAOo1B,oBAwBTO,WAAa,SAAUtT,GAmBnB,QAASuT,GAASC,GACf,MAAIA,GAAK/xB,QAAQ,OAAS,EAAU+xB,EAC7BxT,EAAM,IAAMwT,EAlBtB,GAGI/yB,GACAhB,EAGAozB,EACAlyB,EARA8yB,EAAgBzT,EAAIpf,OAAS,EAAKof,EAAM,UAAa,SAErD0T,EAAStO,eAAgBqO,GAAe,GAGxCE,KACAC,IAIJ,IAAIF,KAAW,EACX,OAAO,CAWX,KADAjzB,EAAQizB,EAAOhzB,MAAM,SAChBC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAE1BlB,EAAOgB,EAAME,GAAGkF,QAAQ,aAAc,IACjCpG,EAAKmB,QAAqB,KAAXnB,EAAK,KAIzBozB,EAAQpzB,EAAKiB,MAAM,OACC,GAAhBmyB,EAAMjyB,QAA+B,GAAhBiyB,EAAMjyB,OACX,UAAZiyB,EAAM,GACN/kB,QAAQC,IAAIiS,EAAM,uCACC,YAAZ6S,EAAM,GACbc,EAAUd,EAAM,KAAQ7S,IAAKuT,EAASV,EAAM,KAExB,GAAhBA,EAAMjyB,OACNgzB,EAAUf,EAAM,KAAQ7S,IAAKuT,EAASV,EAAM,KAE5Ce,EAAUf,EAAM,KAAQ7S,IAAKuT,EAASV,EAAM,IAAMxlB,QAASwlB,EAAM,IAIzE/kB,QAAQC,IAAIiS,EAAM,gBAAkBvgB,GAG5C,QAAQk0B,UAAWA,EAAWC,UAAWA,IAS7CC,SAAW,SAAUC,GAUjB,GAAInzB,GACA2O,EAAM8V,eAAe0O,GACrBlB,IAEJ,IAAItjB,KAAQ,EAAZ,CAaA,IARAsjB,EAAUN,EAAYhjB,GACtBxB,QAAQC,IAAI+lB,EAAW,YAAalB,GAMpCtjB,GAAO,YACF3O,EAAI,EAAGA,EAAIiyB,EAAQhyB,OAAQD,IAG5B2O,GAAO,OAASsjB,EAAQjyB,GAAK,aAAeiyB,EAAQjyB,GAAK,KACzD2O,GAAO,OAASsjB,EAAQjyB,GAAK,MAAQiyB,EAAQjyB,GAAK,mBAOtD,OAHA2O,IAAO,IAGA,GAAIX,UAASW,UAgHxB3R,OAAOo2B,QACLC,OAAQ,EACRC,OAAQ,EAAYC,QAAS,EAAOC,UAAW,EAAaC,UAAW,EACvEC,QAAS,EAAWC,SAAU,EAAMC,WAAY,EAAYC,WAAY,EACxEC,QAAS,GAAWC,SAAU,GAAMC,WAAY,GAAYC,WAAY,GACxEC,QAAS,GAAWC,SAAU,GAAMC,WAAY,GAAYC,WAAY,GACxEC,OAAQ,GAAYC,QAAS,GAAOC,UAAW,GAAaC,UAAW,GACvEC,OAAQ,GAAYC,QAAS,GAAOC,UAAW,GAAaC,UAAW,GACvEC,OAAQ,GAAYC,QAAS,GAAOC,UAAW,GAAaC,UAAW,GACvEC,UAAW,GAASC,WAAY,GAAIC,aAAc,GAAUC,aAAc,GAC1EC,OAAQ,GAAYC,QAAS,GAAOC,UAAW,GAAaC,UAAW,GACvEC,SAAU,GAAUC,UAAW,GAAKC,YAAa,GAAWC,YAAa,IAG3E74B,OAAO84B,MAELC,UAAW,OACXC,aAAc,YACdC,aAAc,YACdC,UAAW,YACXC,WAAY,aAEZC,MAAO,UACPC,OAAQ,SACRC,SAAU,MACVC,KAAM,OACNC,MAAO,UAGTx5B,OAAOunB,KACLkS,aAAc,SAAS5D,GACrB,MAA2B,mBAAbtO,KAAIsO,KAItB71B,OAAOmiB,IACLuX,KAAM,SAAS72B,EAAE82B,EAAEvf,EAAEtO,GACnB,MAAO,QACHuT,KAAKwH,MAAU,IAAJhkB,GAAW,IACtBwc,KAAKwH,MAAU,IAAJ8S,GAAW,IACtBta,KAAKwH,MAAU,IAAJzM,GAAW,IACtBtO,EAAI,KAEV8tB,kBAAmB,SAASvX,GAC1BwX,KAAO3J,OAAOqF,KAAKlT,EAAK,UACxBwX,KAAK7P,SAIP5H,gBAAiB,SAAS1b,EAAMozB,GAC9B,GAAIpzB,IAAQub,QAAO8X,WACf,MAAO9X,QAAO8X,WAAWrzB,EAE7B,IAAIszB,GAAYtzB,EAAK5C,QAAQ,OAAS,GAAK4C,EAAK5C,QAAQ,OAAS,CAK7D4C,GAAKzD,OAAS,GAAgB,KAAXyD,EAAK,KAC1BszB,GAAY,EACZtzB,EAAOA,EAAKlF,OAAQ,EAAEkF,EAAKzD,OAAO,GAGpC,IAAIg3B,GAAOD,EAAYtzB,EAAOub,OAAOU,UAAYjc,EAE7CiL,EAAM8V,eAAewS,GAAM,EAE/B,IAAS,GAALtoB,IAAeqoB,EAGjB,IAAK,GAFDE,GAAWjY,OAAOkY,iBAEbn3B,EAAE,EAAGA,EAAEk3B,EAASj3B,SACvBg3B,EAAOC,EAASl3B,GAAK0D,EACrBiL,EAAM8V,eAAewS,GAAM,GACvBtoB,KAAQ,GAHmB3O,KAQnC,GAAI2O,KAAQ,EAAZ,CAGA,GAAIc,GAAOuB,SAASrC,EAEU,KAA1Bc,EAAKH,UAAUrP,QACfkN,QAAQiqB,MAAM,sDAElB,IAAItY,GAAY,GAAIkF,eAAe/P,OAAQxE,EAAMtK,QAAS2xB,GAQ1D,OAPAhY,GAAUa,UAAYV,OAAOoY,gBAAiBJ,GAC9CnY,EAAU5O,SAAWT,EAAKS,SAC1B4O,EAAUwY,MAAQL,EAElBhY,OAAO6F,YAAarV,EAAKS,SAAS4O,EAAUa,WAE5CV,OAAO8X,WAAWrzB,GAAQob,EACnBA,IAKTyY,YAAa,SAASlY,GAEpB,IAAKA,IAAQA,EAAI7gB,OACf,MAAO6gB,EAIT,IAAW,IAAPA,GAAkC,IAArBA,EAAIve,QAAQ,OAAmC,GAApBue,EAAIve,QAAQ,KACtD,MAAOme,QAAOuY,kBAAmBnY,EAenC,KAHA,GAAIoY,GAAmB,GACnBC,EAAgBvY,GAAGoY,YAAYI,OAC/BC,EAAW,GACRA,KAAa,GAAKF,GAAe,CACtC,GAAIA,EAAc5wB,UAAU,IAAM4wB,EAAc5wB,UAAU,GAAc,UACxE,CACE2wB,EAAmBC,EAAc5wB,UAAU,GAAc,SACzD,OAEF4wB,EAAgBA,EAAcC,OAGhC,MAAO1Y,QAAOuY,kBAAmBC,EAAmBpY,IAItDwY,WAAY,EACZC,YAAa,EACbC,aAAc,EAEdC,WAAY,EACZC,cAAe,EACfC,gBAAiB,EACjBC,YAAa,EACbC,aAAc,EACdC,eAAgB,GAEhBC,YAAa,EACbC,YAAa,EAEbC,SAAU,EACVC,WAAY,EAEZC,WAAY,GACZC,QAAS,EACTC,YAAa,IACbC,cAAe,EACfC,WAAY,GACZC,UAAW,GACXC,WAAY,GACZC,WAAY,GACZC,UAAW,GACXC,UAAW,GACXC,WAAY,EACZC,UAAW,GACXC,SAAU,GACVC,QAAS,GACTC,SAAU,GACVC,OAAQ,GACRC,UAAW,GACXC,SAAU,GACVC,WAAY,GACZC,aAAc,GACdC,UAAW,GACXC,YAAa,GACbC,SAAU,GACVC,QAAS,GACTC,UAAW,EACXC,aAAc,GACdC,YAAa,IACbC,eAAgB,IAChBC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,OAAQ,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,IAAKC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EAAGC,QAAS,EACxcC,YAAa,EACbC,YAAa,EACbC,SAAU,EACVC,YAAa,EACbC,YAAa,EACbC,SAAU,EACVC,gBAAiB,EACjBC,gBAAiB,EACjBC,UAAW,GACXC,QAAW,GACXC,WAAY,IACZC,aAAc,IACdC,eAAgB,IAChBC,WAAY,IACZC,YAAa,IACbC,cAAe,IACfC,eAAgB,IAChBC,cAAe,IACfC,eAAgB,IAChBC,aAAc,IACdC,SAAU,IACVC,UAAW,IACXC,UAAW,IACXC,WAAY,IACZC,UAAW,IACXC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAC1GC,UAAW,GACXC,cAAe,GACfC,SAAU,GACVC,UAAW,GACXC,YAAa,GACbC,aAAc,GACdC,OAAQ,GACRC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAAIC,MAAO,GAC1RC,gBAAiB,IACjBC,cAAe,IACfC,iBAAkB,IAClBC,gBAAiB,IACjBC,eAAgB,IAChBC,cAAe,EACfC,cAAe,IACfC,QAAS,IACTC,eAAgB,IAChBC,eAAgB,IAChBC,SAAU,EACVC,YAAa,EACbC,SAAU,EACVC,eAAgB,IAChBC,aAAc,IACdC,eAAgB,IAChBC,QAAS,EACTC,aAAc,IACdC,QAAS,IACTC,cAAe,IACfC,WAAY,IACZC,SAAU,EACVC,eAAgB,EAChBC,WAAY,EACZC,UAAW,EACXC,UAAW,EACXC,aAAc,EACdC,UAAW,EACXC,WAAY,EACZC,kBAAmB,EACnBC,eAAgB,EAChBC,eAAgB,EAChBC,SAAU,EACVC,SAAU,EACVC,UAAW,EACXC,gBAAiB,EACjBC,YAAa,EACbC,aAAc,EACdC,aAAc,EACdC,UAAW,EACXC,WAAY,EACZC,UAAW,EACXC,SAAU,EACVC,SAAU,EACVC,WAAY,EACZC,YAAa,EACbC,SAAU,EACVC,cAAe,EACfC,WAAY,EACZC,gBAAiB,EACjBC,aAAc,EACdC,UAAW,EACXC,YAAa,EACbC,cAAe,EACfC,SAAU,EACVC,QAAS,EACTC,iBAAkB,EAClBC,gBAAiB,EACjBC,oBAAqB,EACrBC,aAAc,EACdC,oBAAqB,EACrBC,SAAU,EACVC,cAAe,EACfC,SAAU,EACVC,YAAa,EACbC,cAAe,EACfC,YAAa,EACbC,mBAAoB,EACpBC,cAAe,EACfC,YAAa,GACbC,SAAU,EACVC,WAAY,EACZC,gBAAiB,EACjBC,aAAc,EACdC,aAAc,EACdC,aAAc,EACdC,aAAc,EACdC,SAAU,EACVC,WAAY,EACZC,OAAQ,EACRC,WAAY,GACZhE,QAAS,EACTiE,qBAAsB,EACtBC,cAAe,EACfC,qBAAsB,EACtBC,YAAa,GACbC,YAAa,GACbC,SAAU,IACVC,UAAW,GACXC,SAAU,IACVC,WAAY,GAYdtpC,OAAO8jB,OAAS,SAAgB7R,EAAQiH,GACpCA,EAAUA,KACV,IAAIqwB,MACArpC,EAAMgZ,EAAQhZ,IAEdspC,EAAS,WACT,IAAK,GAAIxmC,KAAKumC,GACV,IACIA,EAAevmC,GAAGymC,KAAKp/B,MAAMk/B,EAAevmC,GAAG0mC,QAAS5/B,WAC1D,MAAM7E,GACJkL,QAAQC,IAAInL,EAAIpD,UA0D5B,OAvDA2nC,GAAOt3B,WAAaD,MACpBu3B,EAAOplB,QAAU,WACW,GAApBta,UAAU7G,OACVsmC,EAAejiC,MAAMoiC,QAAS1pC,OAAQypC,KAAM3/B,UAAU,KAC1B,gBAAhBA,WAAU,IAAkBA,UAAU,YAAcnE,SAC5DmE,UAAU,GAAG2nB,aAAe3nB,UAAU,KAAO5J,GAC7C4J,UAAU,GAAG2nB,YAAYnqB,KAAKpF,MAClCqnC,EAAejiC,MAAMoiC,QAAS5/B,UAAU,GAAI2/B,KAAM3/B,UAAU,GAAGA,UAAU,QAErEA,UAAU,GAAG2nB,eAAiBvxB,GAAQ4J,UAAU,KAAO5J,GAAO4J,UAAU,KAAO5J,EAAI+nB,UACnFne,UAAU,GAAG2nB,YAAYnqB,KAAKpF,MAClCqnC,EAAejiC,MAAMoiC,QAAS5/B,UAAU,GAAI2/B,KAAM3/B,UAAU,MAI5DoP,EAAQhZ,KAAOgZ,EAAQhZ,IAAIypC,gBAC3BzwB,EAAQhZ,IAAIypC,eAAezwB,IAInCswB,EAAOxX,WAAa,WAGhB,IAAK,GAFD4X,GAA+B,GAApB9/B,UAAU7G,OAAe6G,UAAU,YAAckH,UAAW,EAAI,EACtC,gBAAhBlH,WAAU,IAAkBA,UAAU,YAAcnE,QAAU,EAAI,EAClF3C,EAAI,EAAGA,EAAIumC,EAAetmC,OAAQD,IAAK,CAC5C,GAAIiQ,GAAOs2B,EAAevmC,IACT,GAAZ4mC,GAAiB32B,EAAKw2B,MAAQ3/B,UAAU,IACzB,GAAZ8/B,GAAiB32B,EAAKy2B,SAAW5/B,UAAU,IAC/B,GAAZ8/B,GAAiB32B,EAAKy2B,SAAW5/B,UAAU,IAAMmJ,EAAKw2B,MAAQ3/B,UAAU,GAAGA,UAAU,KACrFmJ,EAAKy2B,SAAW5/B,UAAU,IAAMmJ,EAAKw2B,MAAQ3/B,UAAU,MAEvDmJ,EAAKy2B,SACLz2B,EAAKy2B,QAAQjY,YAAY1c,OAAO9B,EAAKy2B,QAAQjY,YAAY3tB,QAAQ5B,MAAO,GAC5EqnC,EAAex0B,OAAO/R,EAAG,GACzBA,KAKJkW,EAAQhZ,KAAOgZ,EAAQhZ,IAAI2pC,mBAC3B3wB,EAAQhZ,IAAI2pC,kBAAkB3wB,IAGtCswB,EAAOhX,YAAc,WACjB,GAAIoX,GAA+B,GAApB9/B,UAAU7G,OAAc,EACE,gBAAhB6G,WAAU,IAAkBA,UAAU,YAAcnE,QAAU,EAAI,CAC3F,KAAK,GAAI3C,KAAKumC,GAAgB,CAC1B,GAAIt2B,GAAOs2B,EAAevmC,EAC1B,IAAiB,GAAZ4mC,GAAiB32B,EAAKw2B,MAAQ3/B,UAAU,IACzB,GAAZ8/B,GAAiB32B,EAAKy2B,SAAW5/B,UAAU,IAAMmJ,EAAKw2B,MAAQ3/B,UAAU,GAAGA,UAAU,KACrFmJ,EAAKy2B,SAAW5/B,UAAU,IAAMmJ,EAAKw2B,MAAQ3/B,UAAU,GAE3D,OAAO,EAEf,OAAO,GAEJ0/B,EAIX,IAAIM,QAAS,mBACTC,OAAS,mBAITC,mBAAqBx7B,OAErBuT,cACEkoB,MAAaliB,WACbmiB,KAAaC,OACbC,SAAaD,OACbv2B,OAAajO,OACb0kC,KAAaC,QACbnZ,KAAaD,QACbqZ,MAAa3jB,SACb4jB,OAAaL,OACb9nB,IAAa1c,OACb8kC,QAAa9Y,WACb3c,MAAa2c,WACb+B,YAAa1M,cAEf0jB,SACAC,KAAM5oB,aAIV/hB,QAAO4qC,sBAAwB,SAAUlkC,EAAMlE,GAC7CxC,OAAOwC,EAAKkE,MAASlE,EACrBuf,aAAarb,GAAQlE,EACrBkoC,QAAQC,KAAKjkC,GAAQlE,GAIvBxC,OAAO6qC,gBAAkB,SAAS3xB,GAChC,GAAsB,gBAAXA,GACT0xB,sBAAsB9gC,UAAU,GAAIA,UAAU,QACzC,CACL,GAAIghC,IACFpkC,KAAawS,EAAQxS,KACrBqkC,SAAa7xB,EAAQ6xB,SACrB7lB,YAAahM,EAAQgM,YAGe,oBAA3BwlB,SAAQxxB,EAAQ8xB,UACzBN,QAAQxxB,EAAQ8xB,YAClBN,QAAQxxB,EAAQ8xB,QAAQ1jC,KAAKwjC,GAEI,mBAAtB5xB,GAAQ+xB,WACjBC,QAAQhyB,EAAQgM,YAAahM,EAAQ+xB,aAK3CjrC,OAAOutB,eAAiB,SAAU/d,EAAYE,EAAShJ,GACrD,GAAkC,mBAAvBgkC,SAAQl7B,GACjB,IAAK,GAAIxM,GAAI,EAAIA,EAAI0nC,QAAQl7B,GAAYvM,SAAWD,EAAG,CACrD,GAAIR,GAAOkoC,QAAQl7B,GAAYxM,EAE/B,IAAIR,EAAKkE,MAAQA,GAAQlE,EAAKuoC,SAAStqC,KAAKiP,GAC1C,MAAOlN,GAAK0iB,YAGlB,MAAO,OAGTllB,OAAOmrC,6BAA+B,SAAU37B,EAAYE,GAC1D,GAAIqS,KAEJ,IAAkC,mBAAvB2oB,SAAQl7B,GAEjB,MADAW,SAAQ5J,KAAK,WAAaiJ,EAAa,eAChCuS,CAET,KAAK,GAAI/e,GAAI,EAAIA,EAAI0nC,QAAQl7B,GAAYvM,SAAWD,EAAG,CACrD,GAAIgoC,GAASN,QAAQl7B,GAAYxM,EAE7BgoC,GAAOD,SAAStqC,KAAKiP,KACvBqS,EAAaipB,EAAOtkC,MAAQskC,EAAO9lB,aAGvC,MAAOnD,IAGT/hB,OAAOorC,aAAe,SAAUC,EAAMC,GACpC,GAAIC,KAEJ,IAAmB,mBAARF,IAA+B,MAARA,EAChC,IAAK,GAAIjrC,KAAOirC,GAAQE,EAAanrC,GAAOirC,EAAKjrC,EAEnD,IAAmB,mBAARkrC,IAA+B,MAARA,EAChC,IAAK,GAAIlrC,KAAOkrC,GAAQC,EAAanrC,GAAOkrC,EAAKlrC,EAEnD,OAAOmrC,IAGTvrC,OAAOwrC,0BAEPxrC,OAAO8nB,YAAc,SAAUhO,EAAMjK,GACnCkS,aAAeqpB,aAAaV,QAAQC,KAAM,KAC1C,KAAK,GAAI3nC,GAAI,EAAIA,EAAI6M,EAAQ5M,SAAWD,EAAG,CACzC,GAAIwM,GAAaK,EAAQ7M,GAAG,GACxByoC,EAAgB57B,EAAQ7M,GAAG,GAC3B0oC,EAAc77B,EAAQ7M,GAAG,GACzB2oC,EAAqBR,6BAA6B37B,EAAYi8B,EAE9C,MAAhBC,EACF3pB,aAAa2pB,GAAeN,aAAarpB,aAAa2pB,GAAcC,GAEpE5pB,aAAeqpB,aAAarpB,aAAc4pB,GAE9CH,uBAAuB1xB,EAAK8X,UAAY7P,cAG1C/hB,OAAOkrC,QAAU,SAAShmB,EAAa+lB,GACrC,GAAIW,GAAW1mB,EAAY/T,SAC3B+T,GAAY/T,UAAYK,OAAOq6B,OAAOZ,EAAU95B,WAChDK,OAAOs6B,KAAKF,GAAUjvB,QAAQ,SAASpL,GACrC2T,EAAY/T,UAAUI,GAAQq6B,EAASr6B,KAEzC2T,EAAY/T,UAAU+T,YAAc+lB,EA6FtC,IAAIc,aACAC,YACAvoB,mBACJ,WAWI,GAAIwoB,KAAsBz6B,OAAOs4B,SAAWt4B,OAAOu4B,QAE/CkC,IAEKz6B,OAAO06B,gBACR/7B,QAAQC,IAAI,oDAGhB27B,YAAc,SAAS7rC,EAAK6O,EAAU6R,GAClCpP,OAAO06B,eAAehsC,EAAK6O,GACrBsU,IAAKzC,EAAMurB,cAAc,EAAMC,YAAY,KAErDJ,YAAc,SAAS9rC,EAAK6O,EAAU6R,GAClCpP,OAAO06B,eAAehsC,EAAK6O,GACrBqU,IAAKxC,EAAMurB,cAAc,EAAMC,YAAY,KAErD3oB,kBAAoB,SAASvjB,EAAK6O,EAAU+T,EAAQC,GAChDvR,OAAO06B,eAAehsC,EAAK6O,GACtBsU,IAAKP,EAAQM,IAAKL,EAAQopB,cAAc,EAAMC,YAAY,OAGnEL,YAAc,SAAS7rC,EAAK6O,EAAU6R,GAClC1gB,EAAI4pC,QAAQ/6B,EAAU6R,IAE1BorB,YAAc,SAAS9rC,EAAK6O,EAAU6R,GAClC1gB,EAAI6pC,QAAQh7B,EAAU6R,IAE1B6C,kBAAoB,SAASvjB,EAAK6O,EAAU+T,EAAQC,GAChD7iB,EAAI4pC,QAAQ/6B,EAAU+T,GACtB5iB,EAAI6pC,QAAQh7B,EAAUgU,QA4GlCspB,YAAc,WACVnqC,KAAKoqC,aAELpqC,KAAKqqC,aAAe,SAAS70B,GACzBxV,KAAKoqC,UAAY50B,GAGrBxV,KAAKqnB,YAAczF,SACdthB,KAAK,MAAOkE,KAAK,eACjBlE,KAAK,MAAOkE,KAAK,cAEtBxE,KAAKsqC,aAAe1oB,SACfthB,KAAK,MAAOkE,KAAK,eACjBlE,KAAK,MAAOkE,KAAK,cAEtBxE,KAAKuqC,UAAY3oB,SACZthB,KAAK,MAAOkE,KAAK,qBACjBlE,KAAK,MAAOkE,KAAK,mBACjBlE,KAAK,MAAOkE,KAAK,sBAEtBxE,KAAKwqC,YAAc5oB,SACdthB,KAAK,MAAOkE,KAAK,eACjBlE,KAAK,MAAOkE,KAAK,cAEtBxE,KAAKyqC,WAAa7oB,UAYtB,WACE9jB,OAAO0nB,0BAA4B,SAAUklB,OAAQlqB,UACnD,KAAKA,SAAU,CACbsB,KAAK4oB,OAAOC,OACZ,KAAK,GAAI7pC,GAAI,EAAIA,EAAI4pC,OAAO3X,QAAQhyB,SAAWD,EAAG,CAChD,GAAI8pC,YAAaF,OAAO3X,QAAQjyB,EAChC0f,UAASoqB,YAAc9oB,KAAK8oB,eAKlC9sC,OAAOwnB,QAAU,SAAUqlB,GAKzB,IAAK,GAJD3sC,IAAQ+0B,WAAa4X,OAAQA,GAC7BE,EAAWtkC,aAAaokC,EAAQpkC,aAAaoI,YAC7Cm8B,EAAqBD,EAAS,GAAG,GAAG,GAE/B/pC,EAAI,EAAIA,EAAIgqC,EAAmB/pC,SAAWD,EAAG,CACpD,GAAIiQ,GAAO+5B,EAAmBhqC,EAE9B,QAAQiQ,EAAK,IACX,IAAK,MACH/S,EAAI+0B,QAAQ3tB,KAAK2L,EAAK,GAAG,GAAG,GAC5B,MACF,KAAK,QACH/S,EAAI+0B,QAAQ3tB,KAAK2L,EAAK,KAI5B,MAAO/S,OAiEX2qC,iBACIG,OAAQ,UACRtkC,KAAM,WACNqkC,SAAU,KACV7lB,YAAaT,gBA4BjBuC,aAAa7V,UAAUmR,aAAe,SAAS9K,EAAQy1B,GACnD,GAAIjhB,GAAW/J,OAAOirB,cACtBjrB,QAAOirB,eAAiBC,kBAAkBC,IAE1C,IAAIC,GAAKprB,OAAOU,SAAWV,QAAOU,UAAYzgB,KAAKygB,UAAYzgB,KAAKygB,UAAYV,OAAOU,SAEvF,IAAI1P,GAAO2O,WACP3K,OAAQ/U,KAAK+kB,YACbzP,OAAQA,EACRrP,QAASjG,KAAKwgB,SAAWlR,OAAOq6B,OAAO3pC,KAAKwgB,UAAY,GAAIoE,YAC5DlC,iBAAiB,GAQrB,OAHA3C,QAAOU,UAAY0qB,EAEnBprB,OAAOirB,eAAiBlhB,EACjB/Y,GAmDXi4B,QAAQlkB,aAAcvC,eAEtBomB,gBAAgB,YAAe7jB,cAC/B6jB,gBAAgB,cAAe7jB,aAY/B,IAAI/E,QAAS,IAGbqrB,WAAY,SAAUpjB,EAAShR,GA6U3B,QAASq0B,GAAY13B,GAInB,MAHIA,GAAE23B,SAAW,IAAM33B,EAAE23B,SAAW,MAClC33B,EAAE43B,QAAS,GAET53B,EAAE23B,SAAWrrB,GAAGwZ,SAAyB,GAAd9lB,EAAE63B,SACxBvrB,GAAGyZ,YACH/lB,EAAE23B,SAAW,IAAM33B,EAAE23B,SAAW,IAChC33B,EAAE23B,SAAW,GAAKrrB,GAAGggB,OACvBtsB,EAAE23B,QAGX,QAASG,GAAgB93B,GACrB,OACI+3B,UAAU,EACVC,MAAO,EACPC,cAAc,EACd1tC,IAAKmtC,EAAY13B,GACjBk4B,UAAYl4B,EAAEm4B,QAAU7rB,GAAG8rB,aAChBp4B,EAAEq4B,OAAW/rB,GAAGgZ,YAChBtlB,EAAE63B,SAAWvrB,GAAG8Y,cAChBplB,EAAEs4B,QAAWhsB,GAAGiZ,aAChBvlB,EAAE43B,OAAWtrB,GAAGkZ,eAC3Bz4B,KAAM+C,OAAOC,aAAaiQ,EAAEu4B,WAuLpC,QAASC,GAAax4B,GAIlBA,EAAEy4B,gBACF,IAAIC,IACAC,OAAQ34B,EAAE44B,QAAQ,GAAGC,MAAQxkB,EAAQykB,WACrCC,OAAQ/4B,EAAE44B,QAAQ,GAAGI,MAAQ3kB,EAAQ4kB,UACrCC,OAAQ,EAEZ7kB,GAAQ8kB,QAAQT,GAIpB,QAASU,GAAiBp5B,GAEtB,GAAI7S,EACJ,KAAKA,IAAK8W,GAAKo1B,WAAY,CACvB,GAAIC,GAAIr1B,EAAKo1B,WAAWlsC,EACpBmsC,IAAKA,EAAEC,cACDt1B,EAAKu1B,YAAYphB,GAAKkhB,EAAEthC,MACrBiM,EAAKu1B,YAAYphB,GAAKkhB,EAAElhC,OACxB6L,EAAKu1B,YAAYnhB,GAAKihB,EAAE5mB,KACxBzO,EAAKu1B,YAAYnhB,GAAKihB,EAAEtc,UAC1Bhd,EAAE64B,MAAQxkB,EAAQykB,YAAcQ,EAAEthC,MAC/BgI,EAAE64B,MAAQxkB,EAAQykB,YAAcQ,EAAElhC,OAClC4H,EAAEg5B,MAAQ3kB,EAAQ4kB,WAAaK,EAAE5mB,KACjC1S,EAAEg5B,MAAQ3kB,EAAQ4kB,WAAaK,EAAEtc,SAC3Csc,EAAEG,SAEV,IAAKtsC,IAAK8W,GAAKo1B,WAAY,CACvB,GAAIC,GAAIr1B,EAAKo1B,WAAWlsC,EACpBmsC,IAAKA,EAAEC,cACDv5B,EAAE64B,MAAQxkB,EAAQykB,YAAcQ,EAAEthC,MAC/BgI,EAAE64B,MAAQxkB,EAAQykB,YAAcQ,EAAElhC,OAClC4H,EAAEg5B,MAAQ3kB,EAAQ4kB,WAAaK,EAAE5mB,KACjC1S,EAAEg5B,MAAQ3kB,EAAQ4kB,WAAaK,EAAEtc,UACnC/Y,EAAKu1B,YAAYphB,GAAKkhB,EAAEthC,MACrBiM,EAAKu1B,YAAYphB,GAAKkhB,EAAElhC,OACxB6L,EAAKu1B,YAAYnhB,GAAKihB,EAAE5mB,KACxBzO,EAAKu1B,YAAYnhB,GAAKihB,EAAEtc,SAClCsc,EAAEI,UAEVz1B,EAAKu1B,aAAgBphB,EAAGpY,EAAE64B,MAAQxkB,EAAQykB,WACtBzgB,EAAGrY,EAAEg5B,MAAQ3kB,EAAQ4kB,WAG7C,QAASU,KAEL,GAAIxsC,GACAysC,GAAM,GAAKC,OAAMC,UACjBC,EAAUH,EAAMI,CAEpB,KADAA,EAAWJ,EACNzsC,EAAI,EAAGA,EAAI8sC,EAAQ7sC,OAAQD,IAC5B8sC,EAAQ9sC,GAAGysC,EAAKG,GA9kBxB1tC,KAAK6tC,IAAM,GACX7tC,KAAK8tC,UAAY3wB,KAAKC,MAAM,IAAOpd,KAAK6tC,KACxC7tC,KAAK+tC,SAAU,EAGf/tC,KAAKgtC,cACLhtC,KAAKmtC,aAAephB,EAAE,EAAGC,EAAE,GAG3BhsB,KAAK63B,cAEL73B,KAAKgmB,YAAcgC,EAGnBhoB,KAAK4iB,oBAGL5iB,KAAKgrC,eAAiB,EAGtBhrC,KAAKguC,oBAGLhuC,KAAKiuC,WAAa,KAGlBjuC,KAAKygB,UAAY,GAKjBzgB,KAAKqG,MAAQ,WAET0Z,OAAS/f,IACT,IAAIc,EACJ,IAAId,KAAKgrC,iBAAmBC,kBAAkBiD,QAG1C,IAFAluC,KAAKgrC,eAAiBC,kBAAkBiD,QACxCC,EAAWC,YAAYd,EAAMttC,KAAK8tC,WAC7BhtC,EAAI,EAAGA,EAAIutC,EAAUttC,OAAQD,IAC9ButC,EAAUvtC,MAMtBd,KAAKoZ,KAAO,WAER,GAAItY,EACJ,IAAId,KAAKgrC,gBAAkBC,kBAAkBiD,QAKzC,IAJAlmB,EAAQsmB,oBAAoB,aAAcnC,GAC1CnkB,EAAQsmB,oBAAoB,YAAavB,GACzCwB,cAAcJ,GACdnuC,KAAKgrC,eAAiBC,kBAAkBuD,KACnC1tC,EAAI,EAAGA,EAAI2tC,EAAS1tC,OAAQD,IAC7B2tC,EAAS3tC,MAMrBd,KAAK0uC,wBAA0B,SAAS3W,GACtC,IAAK1S,IAAIkS,aAAaQ,GAAO,CAC3B,GAAItoB,GAAM8V,eAAewS,EAErBtoB,IACAxB,QAAQC,IAAI,iBAAkB6pB,EAAM,KACpC1S,IAAI0S,GAAQ4W,SAASl/B,IAErBxB,QAAQC,IAAI,sBAAuB6pB,EAAM,OAKjD/3B,KAAKm4B,gBAAkB,SAAUJ,GAC9B,GAAI6W,GAAW7W,EAAKl3B,MAAM,SAG1B,OAFA+tC,GAASA,EAAS7tC,OAAS,GAAK,GAChC6tC,EAAWA,EAASnyB,KAAK,MAI5Bzc,KAAK6uC,SAAW,SAAS9W,GACrB,GAAIxnB,EAEJvQ,MAAKygB,UAAYzgB,KAAKm4B,gBAAgBJ,GACtC/3B,KAAK0uC,wBAAwB3W,GAC7BxnB,EAAOD,gBAAgB+U,IAAI0S,IAC3B/3B,KAAK8uC,YAAYv+B,IAIrBvQ,KAAK+uC,QAAU,SAASt/B,GACpBzP,KAAK8uC,YAAYh9B,SAASrC,KAG9BzP,KAAK8uC,YAAc,SAASv+B,EAAMwnB,GAC9BhY,OAAS/f,KACLgX,EAAQg4B,WACRh4B,EAAQg4B,UAAUz+B,EAItB,IAAIqP,GAAY,GAAIkF,eAAe/P,OAAQxE,EAAM+E,OAAQ,MAEzDtV,MAAK4lB,YAAarV,EAAKS,UACvB4O,EAAUa,UAAYV,OAAOU,UAC7Bb,EAAU5O,SAAWT,EAAKS,SAC1B4O,EAAUwY,MAAQL,EAElB/3B,KAAKiuC,WAAaruB,EAAUQ,aAAa,MACzCR,EAAUqF,gBAAgBjlB,KAAK0oB,eAC/B1oB,KAAKivC,8BAELjvC,KAAKqG,OAGL,KAAK,GAAIvF,KAAKd,MAAK4iB,iBACf5iB,KAAK4iB,iBAAiB9hB,MAY9Bd,KAAKs4B,kBAAoB,SAAS3E,GAK9B,IAAK,GAJDub,GAAgBvb,GAAmB,KAAXA,EAAK,GAC7Bwb,EAAWxb,EAAK9yB,MAAM,KACtB0R,KAEKzS,EAAM,EAAGA,EAAMqvC,EAASpuC,QAAU,CACvC,GAAIquC,GAAUD,EAASrvC,IAER,MAAXsvC,EACIF,GAAgBpvC,GAAOqvC,EAASpuC,QAChCwR,EAAInN,KAAK,IAEK,MAAXgqC,IACH78B,EAAIxR,OAAS,GAAmB,GAAdwR,EAAIxR,QAAyB,IAAVwR,EAAI,KACzCA,EAAI7J,MAEJwmC,GAAgBpvC,GAAOqvC,EAASpuC,QAChCwR,EAAInN,KAAK,MAGbmN,EAAInN,KAAKgqC,GACTF,GAAe,GAIvB,MAAO38B,GAAIkK,KAAK,MAoDpBzc,KAAK4lB,YAAc,SAASypB,EAAcC,GAMtC,GALKtvC,KAAKuvC,kBAAiBvvC,KAAKuvC,iBAAoBC,WAAcC,wBAG7DzvC,KAAKggB,UAAShgB,KAAKggB,YAEnBqvB,GAAuC,GAAvBA,EAAatuC,OAAlC,CACKuuC,IAAgBA,EAAiBtvC,KAAKygB,UAE3C,KAAK,GAAI3f,GAAE,EAAGA,EAAEuuC,EAAatuC,OAAQD,IAAK,CACtC,GAAI4uC,GAAQL,EAAavuC,GAErB0D,EAAOkrC,EAAM,GAEb5X,EAAkC,GAAtBtzB,EAAK5C,QAAQ,OAAc4C,EAAK5C,QAAQ,QAAU,EAC9D+tC,EAA4BD,EAAM,GAClCE,GAAaD,IAA8B7X,CAY/C,IAVI8X,IAGAprC,EAAOxE,KAAKs4B,kBAAmBgX,EAAiB9qC,GACnB,KAAzBA,EAAMA,EAAKzD,OAAO,KAClByD,EAAOA,EAAKlF,OAAQ,EAAGkF,EAAKzD,OAAO,MAKvCf,KAAKuvC,gBAAiB/qC,GAA1B,CAEA,GAAIqrC,IAAU,CACd,IAAIF,GAA6B3vC,KAAK8vC,sBAAwB9vC,KAAK8vC,qBAAsBtrC,GAErFqrC,EAAUpc,WAAYzzB,KAAK8vC,qBAAsBtrC,QAEhD,IAAIszB,GAAa8X,EAKlBC,EAAUpc,WAAYjvB,OAQtB,KAAK,GAHDurC,IAAgBT,GAAgBzgC,OAAQ7O,KAAKi4B,kBAC7C+X,EAAYxrC,EAAKwB,QAAS,MAAM,KAE3BgkB,EAAE,EAAGA,EAAE+lB,EAAahvC,OAAQipB,IAAK,CACtC,GAAI+N,GAAOgY,EAAa/lB,GAAKgmB,CAE7B,IADAH,EAAUpc,WAAYsE,GACT,MAIrB,GAAK8X,EAAL,CAoBA,IAAK,GAAII,KAAYJ,GAAQ9b,UAAa/zB,KAAKggB,QAAQiwB,GAAYJ,EAAQ9b,UAAUkc,EAGrFjwC,MAAKuvC,gBAAiB/qC,GAASqrC,MAtB3B5hC,SAAQC,IAAI,mEAAmE1J,GAG/ExE,KAAKuvC,gBAAiB/qC,MAQnBorC,GACF5vC,KAAKkwC,cAAe1rC,EAAO,SAexCxE,KAAK0oB,YAAc,WACjB,MAAO1oB,MAAKiuC,WAAWztB,UAGzBxgB,KAAKmwC,eAAiB,WACpB,MAAOnwC,MAAK0oB,cAAcF,aACzB/C,KAAKzlB,KAGR,IAAIowC,KACJA,GAAgBnwB,GAAGye,cAAkB,kBACrC0R,EAAgBnwB,GAAGoiB,UAAkB,cACrC+N,EAAgBnwB,GAAGyZ,aAAkB,iBACrC0W,EAAgBnwB,GAAGgmB,UAAkB,cACrCmK,EAAgBnwB,GAAGmnB,YAAkB,gBACrCgJ,EAAgBnwB,GAAG8Z,YAAkB,gBACrCqW,EAAgBnwB,GAAG+e,OAAkB,gBACrCoR,EAAgBnwB,GAAGgf,OAAkB,gBACrCmR,EAAgBnwB,GAAGif,OAAkB,gBACrCkR,EAAgBnwB,GAAGkf,OAAkB,gBACrCiR,EAAgBnwB,GAAGmf,OAAkB,gBACrCgR,EAAgBnwB,GAAGof,OAAkB,gBACrC+Q,EAAgBnwB,GAAGqf,OAAkB,gBACrC8Q,EAAgBnwB,GAAGsf,OAAkB,gBACrC6Q,EAAgBnwB,GAAGuf,OAAkB,gBACrC4Q,EAAgBnwB,GAAGwf,OAAkB,gBACrC2Q,EAAgBnwB,GAAGuZ,YAAkB,gBACrC4W,EAAgBnwB,GAAGumB,UAAkB,cACrC4J,EAAgBnwB,GAAGwmB,YAAkB,gBACrC2J,EAAgBnwB,GAAGwd,UAAkB,cACrC2S,EAAgBnwB,GAAGymB,QAAkB,YACrC0J,EAAgBnwB,GAAG2Z,YAAkB,gBACrCwW,EAAgBnwB,GAAG0mB,YAAkB,gBACrCyJ,EAAgBnwB,GAAG8d,WAAkB,eACrCqS,EAAgBnwB,GAAGwZ,SAAkB,aACrC2W,EAAgBnwB,GAAGuiB,gBAAkB,oBACrC4N,EAAgBnwB,GAAGwiB,cAAkB,kBACrC2N,EAAgBnwB,GAAG0iB,SAAkB,aACrCyN,EAAgBnwB,GAAGsa,QAAkB,YACrC6V,EAAgBnwB,GAAGua,WAAkB,eACrC4V,EAAgBnwB,GAAGwa,UAAkB,cACrC2V,EAAgBnwB,GAAGqa,UAAkB,cA4BrCrU,SAASoqB,WAAa,SAAU18B,GAK9B,IAJA,GAAIw8B,GAAiBnwC,KAAKmwC,iBACtBG,EAAiB7E,EAAgB93B,GAAKqa,OAAOsiB,OAC7CC,EAAiBH,EAAgBE,EAAMpyC,KAElB,GAAlBoyC,EAAM5E,UAAsC,MAAlByE,GAAwB,CACvD,GAAIK,GAAeL,EAAe3vB,SAAS8vB,KAE3CH,GAAe3vB,SAAS8vB,MAAQA,EAChCH,EAAeltB,KAAKa,QAAQwsB,GACX,MAAbC,GACFJ,EAAeltB,KAAKstB,GAAWD,GACjCH,EAAe3vB,SAAS8vB,MAAQE,EACV,GAAlBF,EAAM5E,SACR/3B,EAAEy4B,iBAEF+D,EAAiBA,EAAepqB,UAEnCN,KAAKzlB,MAERimB,SAASwqB,QAAU,SAAU98B,GAI3B,IAHA,GAAIw8B,GAAiBnwC,KAAKmwC,iBACtBG,EAAiB7E,EAAgB93B,GAAKqa,OAAOsiB,OAExB,GAAlBA,EAAM5E,UAAsC,MAAlByE,GAAwB,CACvD,GAAIK,GAAeL,EAAe3vB,SAAS8vB,KAE3CH,GAAe3vB,SAAS8vB,MAAQA,EAChCH,EAAeltB,KAAKc,SAASusB,GAC7BH,EAAe3vB,SAAS8vB,MAAQE,EACV,GAAlBF,EAAM5E,SACR/3B,EAAEy4B,iBAEF+D,EAAiBA,EAAepqB,UAEnCN,KAAKzlB,MAGRA,KAAK0wC,iBAAmB,SAAS1yC,EAAK6O,GAKlC,QAAS+T,KAIL,MAHIknB,qBAAyE,IAAnD6I,EAAoB/uC,QAAQkmC,qBAClD6I,EAAoBvrC,KAAK0iC,oBAEtBtnC,EAGX,QAASqgB,GAAOQ,GACZ7gB,EAAQ6gB,CAER,KAAKvgB,IAAK6vC,GACNA,EAAoB7vC,GAAG8vC,SAd/B,GAAID,MACAnwC,EAAQxC,EAAI6O,EAgBhB0U,mBAAkBvjB,EAAK6O,EAAU+T,EAAQC,IAO7C7gB,KAAKkwC,cAAgB,SAAUW,GACtB7wC,KAAK8wC,uBAAsB9wC,KAAK8wC,yBACrC9wC,KAAK8wC,qBAAqB1rC,KAAMyrC,IAGpC7wC,KAAK+wC,kBAAoB,SAAUC,GAE/BhxC,KAAK8wC,qBAAuBE,GAGhChxC,KAAKi4B,eAAiB,WAClB,MAAQj4B,MAAK8wC,0BAOjB9wC,KAAKixC,cAAgB,SAAU3jC,EAAY4jC,GAGJ,KAA/BA,EAASA,EAAQnwC,OAAO,KACxBmwC,EAAUA,EAAQ5xC,OAAQ,EAAG4xC,EAAQnwC,OAAO,IAG3Cf,KAAK8vC,uBAAsB9vC,KAAK8vC,yBACrC9vC,KAAK8vC,qBAAsBxiC,GAAe4jC,GAM9ClxC,KAAKmxC,cAAgB,SAAS3sC,GAE1B,GAAIA,IAAQxE,MAAK63B,WACb,MAAO73B,MAAK63B,WAAWrzB,EAE3B,IAAIuzB,GAAO3S,UAAU3E,UAAYjc,EAAO,MAKxC,OAHAxE,MAAK0uC,wBAAwB3W,GAC7BxnB,KAAOD,gBAAgB+U,IAAI0S,IAC3B/3B,KAAK63B,WAAWrzB,GAAQ+L,KACjBA,MAGXvQ,KAAKivC,4BAA8B,WAE/B,IAAK,GAAInuC,GAAI,EAAGA,EAAId,KAAKguC,iBAAiBjtC,OAAQD,IAAK,CACnD,GAAIwQ,GAAWtR,KAAKguC,iBAAiBltC,EACrCwQ,GAASV,QAAQiR,UACjBvQ,EAASs/B,SAEb5wC,KAAKguC,qBAGThuC,KAAKoxC,gBAAkB,SAAS1wC,EAAM2wC,GAElCC,OAAO3+B,OACP2+B,OAAOC,KAAOF,CACd,IAAIG,GAAUF,OAAOG,YAAY/wC,EAEjC,OADA4wC,QAAOviB,UACAyiB,GAIXxxC,KAAK0xC,aAAe,SAAS3Z,GAGzB,MAAY,IAARA,GAAqC,IAAvBA,EAAKn2B,QAAQ,QAAqC,GAArBm2B,EAAKn2B,QAAQ,MAAsC,GAAzBm2B,EAAKn2B,QAAQ,UAA0C,GAAzBm2B,EAAKn2B,QAAQ,SACzGm2B,EAEJ/3B,KAAKygB,UAAYsX,GAG5B/3B,KAAK2xC,eAAiB,SAAS/iC,GAE3By/B,EAAUjpC,KAAKwJ,IAGnB5O,KAAK4xC,cAAgB,SAAShjC,GAE1B6/B,EAASrpC,KAAKwJ,IAGlB5O,KAAK6xC,WAAa,SAAS5+B,GAEvB26B,EAAQxoC,KAAK6N,IAGjBjT,KAAK8xC,cAAgB,SAAS7+B,GAE1B,GAAI8+B,GAAQnE,EAAQhsC,QAAQqR,EACf,KAAT8+B,GACAnE,EAAQ/6B,OAAOk/B,EAAO,IAI9B/xC,KAAKgyC,KAAO,WAER,OAASxkB,MAAOxtB,KAAKiuC,WAAWgE,WAAYxkB,OAAQztB,KAAKiuC,WAAWiE,cAIxElyC,KAAKmyC,UAAY,SAASb,GAEtBtxC,KAAKiuC,WAAWxrB,MAAM6uB,GAM1B,IAqEInD,GAGArtC,EAxEA8W,EAAO5X,KAkEPyuC,KACAJ,KAGAT,KACAD,GAAW,GAAIH,OAAOC,SAM1Bz2B,GAAUA,MAENA,EAAQo7B,eAERnkC,WACAA,QAAQC,IAAM,WACV,GAAI9D,GAAO4E,MAAMC,UAAUtH,MAAMuH,KAAKtH,UACtCoP,GAAQo7B,aAAajqC,MAAMmE,OAAWlC,MAiZlD4+B,QAAQljB,QAASvD,eAEjB1C,aAAmB,KAAIiG,QAcvBmlB,mBACIuD,KAAM,EACNtD,KAAM,EACNgD,QAAS,GAablF,QAAQ9Z,cAAepJ,SAEvBoJ,cAAcG,oBAAsB,WAChC,IAAK,GAAIvuB,GAAI,EAAGA,EAAId,KAAK+V,SAAShV,OAAQD,IAAK,CAC3C,GAAIymB,GAAQvnB,KAAK+V,SAASjV,EACrBymB,GAAMG,aAAa4I,YAAYtwB,KAAMA,KAAKovB,iBAC3C7H,EAAMG,aAAaxF,QAAQliB,KAAMA,KAAKovB,gBACrC7H,EAAMI,cAAc2I,YAAYtwB,KAAMA,KAAKovB,iBAC5C7H,EAAMI,cAAczF,QAAQliB,KAAMA,KAAKovB,gBACtC7H,EAAM2F,eAAeoD,YAAYtwB,KAAMA,KAAKovB,iBAC7C7H,EAAM2F,eAAehL,QAAQliB,KAAMA,KAAKovB,gBACvC7H,EAAM6F,eAAekD,YAAYtwB,KAAMA,KAAKovB,iBAC7C7H,EAAM6F,eAAelL,QAAQliB,KAAMA,KAAKovB,kBAuBpDtO,YAAY7R,UAAU2hC,OAAS,WAC3B,GAAK5wC,KAAK4Q,QAAV,CAGA,GAAIiZ,GAAS7pB,KAAKO,GAClBunC,oBAAqB9nC,KACrBA,KAAKO,IAAMP,KAAK4Q,QAAQkR,KAAK9hB,KAAK0hB,YAAa1hB,KAAK2hB,gBACpDmmB,mBAAqBx7B,OAEjBtM,KAAKsvB,YACLtvB,KAAKsvB,UAAU7E,WACXJ,OAAQrqB,KAAKsvB,UAAUjF,QAAUrqB,KAAKhC,IACtCsT,SAAUtR,KAAKsvB,UAAUhe,UAAYtR,KAAKwE,KAC1CsG,KAAM9K,KAAKsvB,UAAUxkB,MAAQ+e,EAC7B9e,GAAI/K,KAAKsvB,UAAUvkB,IAAM/K,KAAKO,MAElCP,KAAKsvB,UAAUhW,WAGftZ,KAAKO,MAAQspB,GACb7pB,KAAKghB,QAAQhhB,KAAKO,IAAKspB,EAAQ7pB,KAAKwE,QAI5Csc,YAAY7R,UAAUkS,IAAM,WAMxB,MAHI2mB,sBAAuB9nC,KAAKghB,QAAQsP,YAAYwX,mBAAoBhnB,YAAY7R,UAAU2hC,SAC1F5wC,KAAKghB,QAAQkB,QAAQ4lB,mBAAoBhnB,YAAY7R,UAAU2hC,QAE5D5wC,KAAKO,KAIhBugB,YAAY7R,UAAUiS,IAAM,SAASG,EAAQU,EAAeL,EAAaC,GACrE,GACIkI,GAAS7pB,KAAKO,GAElB,IAAI8gB,YAAkBxQ,YAAY,CAC9B,IAAK6Q,IAAgBC,EACjB,KAAM,gDAKV,IAJA3hB,KAAK4Q,QAAUyQ,EACfrhB,KAAK0hB,YAAcA,EACnB1hB,KAAK2hB,eAAiBA,EAElB5B,OAAOirB,iBAAmBC,kBAAkBC,KAS5C,WADAnrB,QAAOiuB,iBAAiB5oC,KAAKpF,KAPxBqhB,GAAOS,MACRT,EAAOQ,UAEXimB,mBAAqB9nC,KACrBqhB,EAASrhB,KAAK4Q,QAAQkR,KAAKJ,EAAaC,GACxCmmB,mBAAqB,SAMpB/lB,KACD/hB,KAAK4Q,QAAU,MACfyQ,YAAkBrS,SAClBqS,EAASA,EAAO1Z,QAGpBkY,cAAa7f,KAAKM,OAAS0uB,QAC3BhvB,KAAKO,IAAMyuB,SAAUja,OAAQsM,EAAQ/L,OAAQtV,KAAKhC,IAAKiI,QAAS0b,IACzDN,YAAkBnR,gBACrB2P,aAAawB,EAAOlR,SAAW2U,cAAgBjF,aAAa7f,KAAKM,OAASwkB,aAC1E9kB,KAAKO,IAAM,GAAIukB,eAAe/P,OAAQsM,EAAQ/L,OAAQtV,KAAKhC,IAAKiI,QAAS0b,IAEzE3hB,KAAKO,IAAMmf,WAAY3K,OAAQsM,EAAQ/L,OAAQtV,KAAKhC,IAAKiI,QAAS0b,IAC/DN,YAAkB/R,UAAW+R,EACpCrhB,KAAKO,IAAM8gB,EAEXrhB,KAAKO,IAAMsf,aAAa7f,KAAKM,MAAM+gB,GAGnCrhB,KAAKO,MAAQspB,IACT7pB,KAAKsvB,YAAcvN,IACnB/hB,KAAKsvB,UAAUye,SAAU,EACzB/tC,KAAKsvB,UAAU7E,WACXJ,OAAQrqB,KAAKsvB,UAAUjF,QAAUrqB,KAAKhC,IACtCsT,SAAUtR,KAAKsvB,UAAUhe,UAAYtR,KAAKwE,KAC1CsG,KAAM9K,KAAKsvB,UAAUxkB,MAAQ+e,EAC7B9e,GAAI/K,KAAKsvB,UAAUvkB,IAAM/K,KAAKO,MAElCP,KAAKsvB,UAAUye,SAAU,GAEzB/tC,KAAKhC,IAAIq0C,gCAAiCvjC,YAAaiT,EACvD/hB,KAAKhC,IAAIq0C,sBAAsBryC,KAAKwE,KAAM6c,GAE1CrhB,KAAKghB,QAAQhhB,KAAKO,IAAKspB,EAAQ7pB,KAAKwE,QAyBhDwkC,QAAQxZ,mBAAoBjN,eAE5BomB,gBAAgB,kBAAmBnZ,mBAOnC,IAAIG,WAAY,CA8OhBgZ,kBACEG,OAAU,SACVtkC,KAAU,YACVqkC,SAAU,KACVE,UAAWjjB,QACX9C,YAAa,SAAsBrD,GAuCjC,QAAS2yB,GAAaC,GACpB,GAAI7oC,GAAO8oC,GAEXC,IACEF,OAAUA,EACVG,SAAU96B,EAAK+6B,cACfjpC,KAAUA,EACVkpC,QAAU,SAASzf,GACjB0f,EAAgB1f,GAChBvb,EAAKk7B,WAcX,QAASN,KAIP,IAAK,GAFD9oC,GADAqL,KAGKjU,EAAI,EAAIA,EAAI8W,EAAKkL,WAAW/hB,SAAWD,EAC9CiU,EAAO6C,EAAKkL,WAAWhiB,IAAM8W,EAAKqJ,YAAYrJ,EAAKkL,WAAWhiB,IAAIqgB,KAMpE,OALAlT,SAAQC,IAAI6G,GACc,oBAAtB6C,EAAK+6B,eAA6D,aAAtB/6B,EAAK+6B,cACnDjpC,EAAOynB,KAAKC,UAAUrc,GACO,gCAAtB6C,EAAK+6B,gBACZjpC,EAAOqpC,EAAmBh+B,IACrBrL,EAGT,QAASspC,GAAqB5sC,GAC5B,MAAO6sC,oBAAmB7sC,GAAKJ,QAAQ,WAAY,SAAUkN,GAC3D,MAAO,IAAMA,EAAEzU,WAAW,GAAGmd,SAAS,MAI1C,QAASm3B,GAAmBh+B,EAAQ9R,GAClC,GAAImD,GAAM,EACV,KAAK,GAAIlI,KAAO6W,GACd,GAAIA,EAAOxF,eAAerR,GAAM,CAC9B,GAAIsC,GAAQuU,EAAO7W,EACR,KAAPkI,IACFA,GAAO,KACY,mBAAVnD,KACT/E,EAAO+E,EAAS,IAAM/E,EAAM,KAE5BkI,GADkB,gBAAT5F,GACFuyC,EAAmBvyC,EAAOtC,GAE1B80C,EAAqB90C,GAAO,IAAM80C,EAAqBxyC,GAGpE,MAAO4F,GAGT,QAASqsC,GAAKz7B,GACZ,GAAImc,GAAM,GAAIC,eAEdD,GAAI+f,iBAAiBt7B,EAAK86B,UAC1Bvf,EAAIggB,mBAAqB,WACnBhgB,EAAIigB,YAAchgB,eAAeigB,OACjB,KAAdlgB,EAAII,OACNvc,EAAQ47B,QAAQzf,GAEhBnc,EAAQs8B,QAAQngB;AAClBvb,EAAK27B,iBAAmB,EACpB37B,EAAK27B,iBAAmB,IAC1B37B,EAAK47B,WAAY,KAGvBrgB,EAAIE,KAAKrc,EAAQu7B,OAAQ36B,EAAKuI,KAAK,GACR,mBAAhBnJ,GAAQtN,MACjBypB,EAAIsgB,iBAAiB,eAAgB77B,EAAK+6B,eAC1Cxf,EAAIG,KAAKtc,EAAQtN,OAGjBypB,EAAIG,KAAK,MACX1b,EAAK27B,iBAAmB,EACxB37B,EAAK47B,WAAY,EAGnB,QAASX,GAAgB1f,GACvB,GAAIugB,EAEiB,qBAAjB97B,EAAK86B,UAAmD,aAAjB96B,EAAK86B,WAC9CgB,EAAiBviB,KAAKjS,MAAMiU,EAAIK,eAElCmgB,EAAmCD,GAGrC,QAASC,GAAmCD,GAC1C,IAAK,GAAIx1C,KAAOw1C,GACVA,EAAenkC,eAAerR,IAAQ0Z,EAAKg8B,aAAa11C,IAC1D0Z,EAAKqJ,YAAY/iB,GAAKgjB,IAAIwyB,EAAex1C,IAzI/C4nB,QAAQ5W,KAAKlP,KAAM2f,EACnB,IAAI/H,GAAO5X,KACP8iB,EAAa9iB,KAAKykB,eAEtB9D,sBAAqB,SAAU3gB,KAAM,OACrC2gB,qBAAqB,OAAU3gB,KAAM,aACrC2gB,qBAAqB,SAAU3gB,KAAM,YACrC2gB,qBAAqB,SAAU3gB,KAAM,iBAErCA,KAAK0yC,SAAgB,mBACrB1yC,KAAK2yC,cAAgB,+BACrB3yC,KAAKwzC,WAAgB,EACrBxzC,KAAK8iB,WAAgBA,EAErB9iB,KAAK6zC,QAAUjyB,SACf5hB,KAAK8yC,MAAUlxB,SAEf5hB,KAAKuzC,gBAAkB,EAEvBvzC,KAAK8zC,MAAQ,WACXrB,GACEF,OAAU,MACVG,SAAU96B,EAAKm8B,SACfnB,QAAS,SAASzf,GAChB0f,EAAgB1f,GAChBvb,EAAKi8B,cAKX7zC,KAAK2pC,OAAS,WACZ2I,EAAa,SAGftyC,KAAK2S,KAAO,WACV2/B,EAAa,QAiBftyC,KAAKg0C,OAAS,WACZvB,GACEF,OAAQ,SACRK,QAAS,SAASzf,GAChBvb,EAAKq8B,cAsFXj0C,KAAK4zC,aAAe,SAASpvC,GAC3B,MAAyC,mBAA1BoT,GAAKqJ,YAAYzc,OAKtCmkC,iBACEG,OAAQ,UACRtkC,KAAQ,WACRqkC,SAAU,KACVE,UAAWjjB,QACX9C,YAAa,SAAqBrD,GAKhC,GAJAmG,QAAQ5W,KAAKlP,KAAM2f,GAEnBgB,qBAAqB,SAAU3gB,KAAM,YAEH,mBAAvBguB,QAAOkmB,aAAlB,CAGA,GAAIpxB,GAEAqxB,EAAS,SAAUC,GACrB,MAAOp0C,MAAKq0C,SAAW,IAAMD,GAC5B3uB,KAAKzlB,MAEJs0C,EAAiB,WACnB,IAAK,GAAIxzC,GAAI,EAAIA,EAAIgiB,EAAW/hB,SAAWD,EACzCd,KAAK8iB,EAAWhiB,IAAMozC,aAAaK,QAAQJ,EAAOrxB,EAAWhiB,MAE9D2kB,KAAKzlB,MAEJw0C,EAAuB,WACzB,IAAK,GAAI1zC,GAAI,EAAIA,EAAIgiB,EAAW/hB,SAAWD,EAAG,CAC5C,GAAIszC,GAAatxB,EAAWhiB,GACxBmhB,EAAamyB,EAAW,UACxBK,EAAaz0C,IAEsB,UAAnCA,KAAKihB,YAAYmzB,GAAU9zC,OAC7Bm0C,EAAaz0C,KAAKwgB,SAASxgB,KAAKihB,YAAYmzB,GAAU7zC,IAAIqP,YAC1DqS,EAAajiB,KAAKihB,YAAYmzB,GAAU7zC,IAAIsP,aAAe,WAE7D4kC,EAAQxyB,GAAYC,QAAQliB,KAAM,WAChCk0C,aAAaQ,QAAQP,EAAOn0C,KAAKo0C,UAAWp0C,KAAK4X,KAAK5X,KAAKo0C,YAC1D3uB,MAAO7N,KAAM5X,KAAMo0C,SAAUA,OAEjC3uB,KAAKzlB,KAERA,MAAK2iB,UAAUP,UAAUF,QAAQliB,KAAM,WACrC8iB,EAAa9iB,KAAKykB,gBAClB6vB,IACAE,KACC/uB,KAAKzlB,YAIQ,mBAAVlC,QAAwBA,OAA0B,mBAAVkwB,QAAwBA,OAAShuB","file":"qml2js-parser.min.js","sourcesContent":["(function(global){\r\n\n/**\r\n * Create QML binding.\r\n * @param {Variant} val Sourcecode or function representing the binding\r\n * @param {Array} tree Parser tree of the binding\r\n * @return {Object} Object representing the binding\r\n */\r\nglobal.QMLBinding = function(val, tree) {\r\n    // this.function states whether the binding is a simple js statement or a function containing a\r\n    // return statement. We decide this on whether it is a code block or not. If it is, we require a\r\n    // return statement. If it is a code block it could though also be a object definition, so we\r\n    // need to check that as well (it is, if the content is labels).\r\n    this.function = tree && tree[0] == \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\r\n    this.src = val;\r\n}\r\n\r\nglobal.QMLBinding.prototype.toJSON = function() {\r\n    return {src: this.src,\r\n        deps: JSON.stringify(this.deps),\r\n        tree: JSON.stringify(this.tree) };\r\n}\r\n\r\n/**\r\n * Compile binding. Afterwards you may call binding.eval to evaluate.\r\n */\r\nQMLBinding.prototype.compile = function() {\r\n    this.eval = new Function('__executionObject', '__executionContext', \"with(__executionContext) with(__executionObject) \" + ( this.function ? \"\" : \"return \" ) + this.src);\r\n}\r\n\n/* @license\r\n\r\n  Copyright (c) 2010 Mihai Bazon <mihai.bazon@gmail.com>\r\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\r\n  Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions\r\n  are met:\r\n\r\n      * Redistributions of source code must retain the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer.\r\n\r\n      * Redistributions in binary form must reproduce the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer in the documentation and/or other materials\r\n        provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n  SUCH DAMAGE.\r\n*/\r\n\r\n\r\n/*\r\n * QML parser and parsetree'er.\r\n *\r\n * Based on Javascript parser written by Mihai Bazon for UglifyJS project.\r\n * That, again, is a port of Javascript parser by Marijn Haverbeke.\r\n * Big thanks to both of you (and others involved)!\r\n * UglifyJS: https://github.com/mishoo/UglifyJS\r\n * Marijn's parser: http://marijn.haverbeke.nl/parse-js/\r\n *\r\n * The primary goal of this file is to offer QML parsing *on top of UglifyJS\r\n * parser* and to change Javascript parts as little as possible. If you find\r\n * bugs/improvements to Javascript parsing parts, check if those are fixed to\r\n * UglifyJS parser first. If not, fix them there. After UglifyJS has been fixed,\r\n * backport the changes to this file. Less changes to Javascript, more easy it\r\n * will be to keep up with UglifyJS.\r\n * Ultimately it would be great to keep the original parser and QML additions in\r\n * different files but the structure of code does not support that.\r\n *\r\n * Exports:\r\n *\r\n * - QMLBinding(src, tree) to pass qml bindings along.\r\n *\r\n * - parseQML(src) -- parses QML source and returns it as output tree expected\r\n *   by the QML engine\r\n *\r\n * - qmlweb_parse(src) -- parses QML or JS source and returns tree a la uglifyjs parser.\r\n *   Currently used for debugging purposes.\r\n */\r\n\r\n// Object cloning for debug prints.\r\nfunction clone(obj){\r\n    if(obj == null || typeof(obj) != 'object')\r\n        return obj;\r\n\r\n    var temp = {}; // changed\r\n\r\n    for(var key in obj)\r\n        temp[key] = clone(obj[key]);\r\n    return temp;\r\n}\r\n\r\n/* -----[ Tokenizer (constants) ]----- */\r\n\r\nvar KEYWORDS = array_to_hash([\r\n        \"break\",\r\n        \"case\",\r\n        \"catch\",\r\n        \"const\",\r\n        \"continue\",\r\n        \"default\",\r\n        \"delete\",\r\n        \"do\",\r\n        \"else\",\r\n        \"finally\",\r\n        \"for\",\r\n        \"function\",\r\n        \"if\",\r\n        \"in\",\r\n        \"instanceof\",\r\n        \"new\",\r\n        \"return\",\r\n        \"switch\",\r\n        \"throw\",\r\n        \"try\",\r\n        \"typeof\",\r\n        \"var\",\r\n        \"void\",\r\n        \"while\",\r\n        \"with\"\r\n]);\r\n\r\nvar RESERVED_WORDS = array_to_hash([\r\n        \"abstract\",\r\n        \"boolean\",\r\n        \"byte\",\r\n        \"char\",\r\n        \"class\",\r\n        \"debugger\",\r\n        \"double\",\r\n        \"enum\",\r\n        \"export\",\r\n        \"extends\",\r\n        \"final\",\r\n        \"float\",\r\n        \"goto\",\r\n        \"implements\",\r\n        \"import\",\r\n        \"int\",\r\n        \"interface\",\r\n        \"long\",\r\n        \"native\",\r\n        \"package\",\r\n        \"private\",\r\n        \"protected\",\r\n        \"public\",\r\n        \"short\",\r\n        \"static\",\r\n        \"super\",\r\n        \"synchronized\",\r\n        \"throws\",\r\n        \"transient\",\r\n        \"volatile\"\r\n]);\r\n\r\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\r\n        \"return\",\r\n        \"new\",\r\n        \"delete\",\r\n        \"throw\",\r\n        \"else\",\r\n        \"case\"\r\n]);\r\n\r\nvar KEYWORDS_ATOM = array_to_hash([\r\n        \"false\",\r\n        \"null\",\r\n        \"true\",\r\n        \"undefined\"\r\n]);\r\n\r\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\r\n\r\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\r\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\r\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\r\n\r\nvar OPERATORS = array_to_hash([\r\n        \"in\",\r\n        \"instanceof\",\r\n        \"typeof\",\r\n        \"new\",\r\n        \"void\",\r\n        \"delete\",\r\n        \"++\",\r\n        \"--\",\r\n        \"+\",\r\n        \"-\",\r\n        \"!\",\r\n        \"~\",\r\n        \"&\",\r\n        \"|\",\r\n        \"^\",\r\n        \"*\",\r\n        \"/\",\r\n        \"%\",\r\n        \">>\",\r\n        \"<<\",\r\n        \">>>\",\r\n        \"<\",\r\n        \">\",\r\n        \"<=\",\r\n        \">=\",\r\n        \"==\",\r\n        \"===\",\r\n        \"!=\",\r\n        \"!==\",\r\n        \"?\",\r\n        \"=\",\r\n        \"+=\",\r\n        \"-=\",\r\n        \"/=\",\r\n        \"*=\",\r\n        \"%=\",\r\n        \">>=\",\r\n        \"<<=\",\r\n        \">>>=\",\r\n        \"|=\",\r\n        \"^=\",\r\n        \"&=\",\r\n        \"&&\",\r\n        \"||\"\r\n]);\r\n\r\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\n\\r\\t\\u200b\"));\r\n\r\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{}(,.;:\"));\r\n\r\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\r\n\r\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\r\n\r\n/* -----[ Tokenizer ]----- */\r\n\r\n// regexps adapted from http://xregexp.com/plugins/#unicode\r\nvar UNICODE = {\r\n        letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\r\n        non_spacing_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\r\n        space_combining_mark: new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\r\n        connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\r\n};\r\n\r\nfunction is_letter(ch) {\r\n        return UNICODE.letter.test(ch);\r\n};\r\n\r\nfunction is_digit(ch) {\r\n        ch = ch.charCodeAt(0);\r\n        return ch >= 48 && ch <= 57; //XXX: find out if \"UnicodeDigit\" means something else than 0..9\r\n};\r\n\r\nfunction is_alphanumeric_char(ch) {\r\n        return is_digit(ch) || is_letter(ch);\r\n};\r\n\r\nfunction is_unicode_combining_mark(ch) {\r\n        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\r\n};\r\n\r\nfunction is_unicode_connector_punctuation(ch) {\r\n        return UNICODE.connector_punctuation.test(ch);\r\n};\r\n\r\nfunction is_identifier_start(ch) {\r\n        return ch == \"$\" || ch == \"_\" || is_letter(ch);\r\n};\r\n\r\nfunction is_identifier_char(ch) {\r\n        return is_identifier_start(ch)\r\n                || is_unicode_combining_mark(ch)\r\n                || is_digit(ch)\r\n                || is_unicode_connector_punctuation(ch)\r\n                || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\r\n                || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\r\n        ;\r\n};\r\n\r\nfunction parse_js_number(num) {\r\n        if (RE_HEX_NUMBER.test(num)) {\r\n                return parseInt(num.substr(2), 16);\r\n        } else if (RE_OCT_NUMBER.test(num)) {\r\n                return parseInt(num.substr(1), 8);\r\n        } else if (RE_DEC_NUMBER.test(num)) {\r\n                return parseFloat(num);\r\n        }\r\n};\r\n\r\nfunction JS_Parse_Error(message, line, col, pos, comment) {\r\n        this.message = message;\r\n        this.line = line + 1;\r\n        this.col = col;\r\n        this.pos = pos;\r\n        this.comment = comment ? comment : \"\";\r\n        try {\r\n                ({})();\r\n        } catch(ex) {\r\n                this.stack = ex.stack;\r\n        };\r\n};\r\n\r\nJS_Parse_Error.prototype.toString = function() {\r\n        return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\" + this.comment + \"\\n\" + this.stack;\r\n};\r\n\r\nfunction js_error(message, line, col, pos, comment) {\r\n        throw new JS_Parse_Error(message, line, col, pos, comment);\r\n};\r\n\r\nfunction is_token(token, type, val) {\r\n        return token.type == type && (val == null || token.value == val);\r\n};\r\n\r\nfunction extractLinesForErrorDiag(text, line)\r\n{\r\n  var r = \"\";\r\n  var lines = text.split(\"\\n\");\r\n\r\n  for (var i = line - 3; i <= line + 3; i++)\r\n  if (i >= 0 && i < lines.length ) {\r\n      var mark = ( i == line ) ? \">>\" : \"  \";\r\n      r += mark + i + \"  \" + lines[i] + \"\\n\";\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\nvar EX_EOF = {};\r\n\r\nfunction tokenizer($TEXT) {\r\n\r\n        var S = {\r\n                text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\r\n                pos             : 0,\r\n                tokpos          : 0,\r\n                line            : 0,\r\n                tokline         : 0,\r\n                col             : 0,\r\n                tokcol          : 0,\r\n                newline_before  : false,\r\n                regex_allowed   : false,\r\n                comments_before : []\r\n        };\r\n\r\n        function peek() { return S.text.charAt(S.pos); };\r\n\r\n        function next(signal_eof) {\r\n                var ch = S.text.charAt(S.pos++);\r\n                if (signal_eof && !ch)\r\n                        throw EX_EOF;\r\n                if (ch == \"\\n\") {\r\n                        S.newline_before = true;\r\n                        ++S.line;\r\n                        S.col = 0;\r\n                } else {\r\n                        ++S.col;\r\n                }\r\n                return ch;\r\n        };\r\n\r\n        function eof() {\r\n                return !S.peek();\r\n        };\r\n\r\n        function find(what, signal_eof) {\r\n                var pos = S.text.indexOf(what, S.pos);\r\n                if (signal_eof && pos == -1) throw EX_EOF;\r\n                return pos;\r\n        };\r\n\r\n        function start_token() {\r\n                S.tokline = S.line;\r\n                S.tokcol = S.col;\r\n                S.tokpos = S.pos;\r\n        };\r\n\r\n        function token(type, value, is_comment) {\r\n                S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\r\n                                   (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\r\n                                   (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\r\n                var ret = {\r\n                        type  : type,\r\n                        value : value,\r\n                        line  : S.tokline,\r\n                        col   : S.tokcol,\r\n                        pos   : S.tokpos,\r\n                        nlb   : S.newline_before\r\n                };\r\n                if (!is_comment) {\r\n                        ret.comments_before = S.comments_before;\r\n                        S.comments_before = [];\r\n                }\r\n                S.newline_before = false;\r\n                return ret;\r\n        };\r\n\r\n        function skip_whitespace() {\r\n                while (HOP(WHITESPACE_CHARS, peek()))\r\n                        next();\r\n        };\r\n\r\n        function read_while(pred) {\r\n                var ret = \"\", ch = peek(), i = 0;\r\n                while (ch && pred(ch, i++)) {\r\n                        ret += next();\r\n                        ch = peek();\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        function parse_error(err) {\r\n                js_error(err, S.tokline, S.tokcol, S.tokpos, extractLinesForErrorDiag( S.text, S.tokline ) );\r\n        };\r\n\r\n        function read_num(prefix) {\r\n                var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\r\n                var num = read_while(function(ch, i){\r\n                        if (ch == \"x\" || ch == \"X\") {\r\n                                if (has_x) return false;\r\n                                return has_x = true;\r\n                        }\r\n                        if (!has_x && (ch == \"E\" || ch == \"e\")) {\r\n                                if (has_e) return false;\r\n                                return has_e = after_e = true;\r\n                        }\r\n                        if (ch == \"-\") {\r\n                                if (after_e || (i == 0 && !prefix)) return true;\r\n                                return false;\r\n                        }\r\n                        if (ch == \"+\") return after_e;\r\n                        after_e = false;\r\n                        if (ch == \".\") {\r\n                                if (!has_dot && !has_x)\r\n                                        return has_dot = true;\r\n                                return false;\r\n                        }\r\n                        return is_alphanumeric_char(ch);\r\n                });\r\n                if (prefix)\r\n                        num = prefix + num;\r\n                var valid = parse_js_number(num);\r\n                if (!isNaN(valid)) {\r\n                        return token(\"num\", valid);\r\n                } else {\r\n                        parse_error(\"Invalid syntax: \" + num);\r\n                }\r\n        };\r\n\r\n        function read_escaped_char() {\r\n                var ch = next(true);\r\n                switch (ch) {\r\n                    case \"n\" : return \"\\n\";\r\n                    case \"r\" : return \"\\r\";\r\n                    case \"t\" : return \"\\t\";\r\n                    case \"b\" : return \"\\b\";\r\n                    case \"v\" : return \"\\v\";\r\n                    case \"f\" : return \"\\f\";\r\n                    case \"0\" : return \"\\0\";\r\n                    case \"x\" : return String.fromCharCode(hex_bytes(2));\r\n                    case \"u\" : return String.fromCharCode(hex_bytes(4));\r\n                    case \"\\n\": return \"\";\r\n                    default  : return ch;\r\n                }\r\n        };\r\n\r\n        function hex_bytes(n) {\r\n                var num = 0;\r\n                for (; n > 0; --n) {\r\n                        var digit = parseInt(next(true), 16);\r\n                        if (isNaN(digit))\r\n                                parse_error(\"Invalid hex-character pattern in string\");\r\n                        num = (num << 4) | digit;\r\n                }\r\n                return num;\r\n        };\r\n\r\n        function read_string() {\r\n                return with_eof_error(\"Unterminated string constant\", function(){\r\n                        var quote = next(), ret = \"\";\r\n                        for (;;) {\r\n                                var ch = next(true);\r\n                                if (ch == \"\\\\\") ch = read_escaped_char();\r\n                                else if (ch == quote) break;\r\n                                ret += ch;\r\n                        }\r\n                        return token(\"string\", ret);\r\n                });\r\n        };\r\n\r\n        function read_line_comment() {\r\n                next();\r\n                var i = find(\"\\n\"), ret;\r\n                if (i == -1) {\r\n                        ret = S.text.substr(S.pos);\r\n                        S.pos = S.text.length;\r\n                } else {\r\n                        ret = S.text.substring(S.pos, i);\r\n                        S.pos = i;\r\n                }\r\n                return token(\"comment1\", ret, true);\r\n        };\r\n\r\n        function read_multiline_comment() {\r\n                next();\r\n                return with_eof_error(\"Unterminated multiline comment\", function(){\r\n                        var i = find(\"*/\", true),\r\n                            text = S.text.substring(S.pos, i),\r\n                            tok = token(\"comment2\", text, true);\r\n                        S.pos = i + 2;\r\n                        S.line += text.split(\"\\n\").length - 1;\r\n                        S.newline_before = text.indexOf(\"\\n\") >= 0;\r\n\r\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/100\r\n                        if (/^@cc_on/i.test(text)) {\r\n                                warn(\"WARNING: at line \" + S.line);\r\n                                warn(\"*** Found \\\"conditional comment\\\": \" + text);\r\n                                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\r\n                        }\r\n\r\n                        return tok;\r\n                });\r\n        };\r\n\r\n        function read_name() {\r\n                var backslash = false, name = \"\", ch;\r\n                while ((ch = peek()) != null) {\r\n                        if (!backslash) {\r\n                                if (ch == \"\\\\\") backslash = true, next();\r\n                                else if (is_identifier_char(ch)) name += next();\r\n                                else break;\r\n                        }\r\n                        else {\r\n                                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\r\n                                ch = read_escaped_char();\r\n                                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\r\n                                name += ch;\r\n                                backslash = false;\r\n                        }\r\n                }\r\n                return name;\r\n        };\r\n\r\n        function read_regexp() {\r\n                return with_eof_error(\"Unterminated regular expression\", function(){\r\n                        var prev_backslash = false, regexp = \"\", ch, in_class = false;\r\n                        while ((ch = next(true))) if (prev_backslash) {\r\n                                regexp += \"\\\\\" + ch;\r\n                                prev_backslash = false;\r\n                        } else if (ch == \"[\") {\r\n                                in_class = true;\r\n                                regexp += ch;\r\n                        } else if (ch == \"]\" && in_class) {\r\n                                in_class = false;\r\n                                regexp += ch;\r\n                        } else if (ch == \"/\" && !in_class) {\r\n                                break;\r\n                        } else if (ch == \"\\\\\") {\r\n                                prev_backslash = true;\r\n                        } else {\r\n                                regexp += ch;\r\n                        }\r\n                        var mods = read_name();\r\n                        return token(\"regexp\", [ regexp, mods ]);\r\n                });\r\n        };\r\n\r\n        function read_operator(prefix) {\r\n                function grow(op) {\r\n                        if (!peek()) return op;\r\n                        var bigger = op + peek();\r\n                        if (HOP(OPERATORS, bigger)) {\r\n                                next();\r\n                                return grow(bigger);\r\n                        } else {\r\n                                return op;\r\n                        }\r\n                };\r\n                return token(\"operator\", grow(prefix || next()));\r\n        };\r\n\r\n        function handle_slash() {\r\n                next();\r\n                var regex_allowed = S.regex_allowed;\r\n                switch (peek()) {\r\n                    case \"/\":\r\n                        S.comments_before.push(read_line_comment());\r\n                        S.regex_allowed = regex_allowed;\r\n                        return next_token();\r\n                    case \"*\":\r\n                        S.comments_before.push(read_multiline_comment());\r\n                        S.regex_allowed = regex_allowed;\r\n                        return next_token();\r\n                }\r\n                return S.regex_allowed ? read_regexp() : read_operator(\"/\");\r\n        };\r\n\r\n        function handle_dot() {\r\n                next();\r\n                return is_digit(peek())\r\n                        ? read_num(\".\")\r\n                        : token(\"punc\", \".\");\r\n        };\r\n\r\n        function read_word() {\r\n                var word = read_name();\r\n                return !HOP(KEYWORDS, word)\r\n                        ? token(\"name\", word)\r\n                        : HOP(OPERATORS, word)\r\n                        ? token(\"operator\", word)\r\n                        : HOP(KEYWORDS_ATOM, word)\r\n                        ? token(\"atom\", word)\r\n                        : token(\"keyword\", word);\r\n        };\r\n\r\n        function with_eof_error(eof_error, cont) {\r\n                try {\r\n                        return cont();\r\n                } catch(ex) {\r\n                        if (ex === EX_EOF) parse_error(eof_error);\r\n                        else throw ex;\r\n                }\r\n        };\r\n\r\n        function next_token(force_regexp) {\r\n                if (force_regexp)\r\n                        return read_regexp();\r\n                skip_whitespace();\r\n                start_token();\r\n                var ch = peek();\r\n                if (!ch) return token(\"eof\");\r\n                if (is_digit(ch)) return read_num();\r\n                if (ch == '\"' || ch == \"'\") return read_string();\r\n                if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\r\n                if (ch == \".\") return handle_dot();\r\n                if (ch == \"/\") return handle_slash();\r\n                if (HOP(OPERATOR_CHARS, ch)) return read_operator();\r\n                if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\r\n                parse_error(\"Unexpected character '\" + ch + \"'\");\r\n        };\r\n\r\n        next_token.context = function(nc) {\r\n                if (nc) S = nc;\r\n                return S;\r\n        };\r\n\r\n        return next_token;\r\n\r\n};\r\n\r\n/* -----[ Parser (constants) ]----- */\r\n\r\nvar UNARY_PREFIX = array_to_hash([\r\n        \"typeof\",\r\n        \"void\",\r\n        \"delete\",\r\n        \"--\",\r\n        \"++\",\r\n        \"!\",\r\n        \"~\",\r\n        \"-\",\r\n        \"+\"\r\n]);\r\n\r\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\r\n\r\nvar ASSIGNMENT = (function(a, ret, i){\r\n        while (i < a.length) {\r\n                ret[a[i]] = a[i].substr(0, a[i].length - 1);\r\n                i++;\r\n        }\r\n        return ret;\r\n})(\r\n        [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\r\n        { \"=\": true },\r\n        0\r\n);\r\n\r\nvar PRECEDENCE = (function(a, ret){\r\n        for (var i = 0, n = 1; i < a.length; ++i, ++n) {\r\n                var b = a[i];\r\n                for (var j = 0; j < b.length; ++j) {\r\n                        ret[b[j]] = n;\r\n                }\r\n        }\r\n        return ret;\r\n})(\r\n        [\r\n                [\"||\"],\r\n                [\"&&\"],\r\n                [\"|\"],\r\n                [\"^\"],\r\n                [\"&\"],\r\n                [\"==\", \"===\", \"!=\", \"!==\"],\r\n                [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\r\n                [\">>\", \"<<\", \">>>\"],\r\n                [\"+\", \"-\"],\r\n                [\"*\", \"/\", \"%\"]\r\n        ],\r\n        {}\r\n);\r\n\r\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\r\n\r\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\r\n\r\n/* -----[ Parser ]----- */\r\n\r\nfunction NodeWithToken(str, start, end) {\r\n        this.name = str;\r\n        this.start = start;\r\n        this.end = end;\r\n};\r\n\r\nNodeWithToken.prototype.toString = function() { return this.name; };\r\n\r\nqmlweb_parse.QMLDocument = 1;\r\nqmlweb_parse.JSResource = 2;\r\nfunction qmlweb_parse($TEXT, document_type, exigent_mode, embed_tokens) {\r\n\r\n        var S = {\r\n                text        : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\r\n                input       : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\r\n                token       : null,\r\n                prev        : null,\r\n                peeked      : null,\r\n                in_function : 0,\r\n                in_loop     : 0,\r\n                labels      : []\r\n        };\r\n\r\n        S.token = next();\r\n\r\n        function is(type, value) {\r\n                return is_token(S.token, type, value);\r\n        };\r\n\r\n        function peek() { return S.peeked || (S.peeked = S.input()); };\r\n\r\n        function next() {\r\n                S.prev = S.token;\r\n                if (S.peeked) {\r\n                        S.token = S.peeked;\r\n                        S.peeked = null;\r\n                } else {\r\n                        S.token = S.input();\r\n                }\r\n                return S.token;\r\n        };\r\n\r\n        function prev() {\r\n                return S.prev;\r\n        };\r\n\r\n        function croak(msg, line, col, pos) {\r\n                var ctx = S.input.context();\r\n                var eLine = (line != null ? line : ctx.tokline);\r\n                js_error(msg,\r\n                         eLine,\r\n                         col != null ? col : ctx.tokcol,\r\n                         pos != null ? pos : ctx.tokpos,\r\n                         extractLinesForErrorDiag( S.text, eLine ) );\r\n        };\r\n\r\n        function token_error(token, msg) {\r\n                croak(msg, token.line, token.col);\r\n        };\r\n\r\n        function unexpected(token) {\r\n                if (token == null)\r\n                        token = S.token;\r\n                token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\r\n        };\r\n\r\n        function expect_token(type, val) {\r\n                if (is(type, val)) {\r\n                        return next();\r\n                }\r\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.val + \", expected \" + type + \" \" + val);\r\n        };\r\n\r\n        function expect(punc) { return expect_token(\"punc\", punc); };\r\n\r\n        function can_insert_semicolon() {\r\n                return !exigent_mode && (\r\n                        S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\r\n                );\r\n        };\r\n\r\n        function semicolon() {\r\n                if (is(\"punc\", \";\")) next();\r\n                else if (!can_insert_semicolon()) unexpected();\r\n        };\r\n\r\n        function as() {\r\n                return slice(arguments);\r\n        };\r\n\r\n        function parenthesised() {\r\n                expect(\"(\");\r\n                var ex = expression();\r\n                expect(\")\");\r\n                return ex;\r\n        };\r\n\r\n        function add_tokens(str, start, end) {\r\n                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\r\n        };\r\n\r\n        function maybe_embed_tokens(parser) {\r\n                if (embed_tokens) return function() {\r\n                        var start = S.token;\r\n                        var ast = parser.apply(this, arguments);\r\n                        ast[0] = add_tokens(ast[0], start, prev());\r\n                        return ast;\r\n                };\r\n                else return parser;\r\n        };\r\n\r\n        var statement = maybe_embed_tokens(function() {\r\n                if (is(\"operator\", \"/\")) {\r\n                        S.peeked = null;\r\n                        S.token = S.input(true); // force regexp\r\n                }\r\n                switch (S.token.type) {\r\n                    case \"num\":\r\n                    case \"string\":\r\n                    case \"regexp\":\r\n                    case \"operator\":\r\n                    case \"atom\":\r\n                        return simple_statement();\r\n\r\n                    case \"name\":\r\n                        return is_token(peek(), \"punc\", \":\")\r\n                                ? labeled_statement(prog1(S.token.value, next, next))\r\n                                : simple_statement();\r\n\r\n                    case \"punc\":\r\n                        switch (S.token.value) {\r\n                            case \"{\":\r\n                                return as(\"block\", block_());\r\n                            case \"[\":\r\n                            case \"(\":\r\n                                return simple_statement();\r\n                            case \";\":\r\n                                next();\r\n                                return as(\"block\");\r\n                            default:\r\n                                unexpected();\r\n                        }\r\n\r\n                    case \"keyword\":\r\n                        switch (prog1(S.token.value, next)) {\r\n                            case \"break\":\r\n                                return break_cont(\"break\");\r\n\r\n                            case \"continue\":\r\n                                return break_cont(\"continue\");\r\n\r\n                            case \"debugger\":\r\n                                semicolon();\r\n                                return as(\"debugger\");\r\n\r\n                            case \"do\":\r\n                                return (function(body){\r\n                                        expect_token(\"keyword\", \"while\");\r\n                                        return as(\"do\", prog1(parenthesised, semicolon), body);\r\n                                })(in_loop(statement));\r\n\r\n                            case \"for\":\r\n                                return for_();\r\n\r\n                            case \"function\":\r\n                                return function_(true);\r\n\r\n                            case \"if\":\r\n                                return if_();\r\n\r\n                            case \"return\":\r\n                                if (S.in_function == 0)\r\n                                        croak(\"'return' outside of function\");\r\n                                return as(\"return\",\r\n                                          is(\"punc\", \";\")\r\n                                          ? (next(), null)\r\n                                          : can_insert_semicolon()\r\n                                          ? null\r\n                                          : prog1(expression, semicolon));\r\n\r\n                            case \"switch\":\r\n                                return as(\"switch\", parenthesised(), switch_block_());\r\n\r\n                            case \"throw\":\r\n                                return as(\"throw\", prog1(expression, semicolon));\r\n\r\n                            case \"try\":\r\n                                return try_();\r\n\r\n                            case \"var\":\r\n                                return prog1(var_, semicolon);\r\n\r\n                            case \"const\":\r\n                                return prog1(const_, semicolon);\r\n\r\n                            case \"while\":\r\n                                return as(\"while\", parenthesised(), in_loop(statement));\r\n\r\n                            case \"with\":\r\n                                return as(\"with\", parenthesised(), statement());\r\n\r\n                            default:\r\n                                unexpected();\r\n                        }\r\n                }\r\n        });\r\n\r\n        function labeled_statement(label) {\r\n                S.labels.push(label);\r\n                var start = S.token, stat = statement();\r\n                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\r\n                        unexpected(start);\r\n                S.labels.pop();\r\n                return as(\"label\", label, stat);\r\n        };\r\n\r\n        function simple_statement() {\r\n                return as(\"stat\", prog1(expression, semicolon));\r\n        };\r\n\r\n        function break_cont(type) {\r\n                var name = is(\"name\") ? S.token.value : null;\r\n                if (name != null) {\r\n                        next();\r\n                        if (!member(name, S.labels))\r\n                                croak(\"Label \" + name + \" without matching loop or statement\");\r\n                }\r\n                else if (S.in_loop == 0)\r\n                        croak(type + \" not inside a loop or switch\");\r\n                semicolon();\r\n                return as(type, name);\r\n        };\r\n\r\n        function for_() {\r\n                expect(\"(\");\r\n                var init = null;\r\n                if (!is(\"punc\", \";\")) {\r\n                        init = is(\"keyword\", \"var\")\r\n                                ? (next(), var_(true))\r\n                                : expression(true, true);\r\n                        if (is(\"operator\", \"in\"))\r\n                                return for_in(init);\r\n                }\r\n                return regular_for(init);\r\n        };\r\n\r\n        function regular_for(init) {\r\n                expect(\";\");\r\n                var test = is(\"punc\", \";\") ? null : expression();\r\n                expect(\";\");\r\n                var step = is(\"punc\", \")\") ? null : expression();\r\n                expect(\")\");\r\n                return as(\"for\", init, test, step, in_loop(statement));\r\n        };\r\n\r\n        function for_in(init) {\r\n                var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\r\n                next();\r\n                var obj = expression();\r\n                expect(\")\");\r\n                return as(\"for-in\", init, lhs, obj, in_loop(statement));\r\n        };\r\n\r\n        var function_ = maybe_embed_tokens(function(in_statement) {\r\n                var name = is(\"name\") ? prog1(S.token.value, next) : null;\r\n                if (in_statement && !name)\r\n                        unexpected();\r\n                expect(\"(\");\r\n                return as(in_statement ? \"defun\" : \"function\",\r\n                          name,\r\n                          // arguments\r\n                          (function(first, a){\r\n                                  while (!is(\"punc\", \")\")) {\r\n                                          if (first) first = false; else expect(\",\");\r\n                                          if (!is(\"name\")) unexpected();\r\n                                          a.push(S.token.value);\r\n                                          next();\r\n                                  }\r\n                                  next();\r\n                                  return a;\r\n                          })(true, []),\r\n                          // body\r\n                          (function(){\r\n                                  ++S.in_function;\r\n                                  var loop = S.in_loop;\r\n                                  S.in_loop = 0;\r\n                                  var a = block_();\r\n                                  --S.in_function;\r\n                                  S.in_loop = loop;\r\n                                  return a;\r\n                          })());\r\n        });\r\n\r\n        function if_() {\r\n                var cond = parenthesised(), body = statement(), belse;\r\n                if (is(\"keyword\", \"else\")) {\r\n                        next();\r\n                        belse = statement();\r\n                }\r\n                return as(\"if\", cond, body, belse);\r\n        };\r\n\r\n        function block_() {\r\n                expect(\"{\");\r\n                var a = [];\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (is(\"eof\")) unexpected();\r\n                        a.push(statement());\r\n                }\r\n                next();\r\n                return a;\r\n        };\r\n\r\n        var switch_block_ = curry(in_loop, function(){\r\n                expect(\"{\");\r\n                var a = [], cur = null;\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (is(\"eof\")) unexpected();\r\n                        if (is(\"keyword\", \"case\")) {\r\n                                next();\r\n                                cur = [];\r\n                                a.push([ expression(), cur ]);\r\n                                expect(\":\");\r\n                        }\r\n                        else if (is(\"keyword\", \"default\")) {\r\n                                next();\r\n                                expect(\":\");\r\n                                cur = [];\r\n                                a.push([ null, cur ]);\r\n                        }\r\n                        else {\r\n                                if (!cur) unexpected();\r\n                                cur.push(statement());\r\n                        }\r\n                }\r\n                next();\r\n                return a;\r\n        });\r\n\r\n        function try_() {\r\n                var body = block_(), bcatch, bfinally;\r\n                if (is(\"keyword\", \"catch\")) {\r\n                        next();\r\n                        expect(\"(\");\r\n                        if (!is(\"name\"))\r\n                                croak(\"Name expected\");\r\n                        var name = S.token.value;\r\n                        next();\r\n                        expect(\")\");\r\n                        bcatch = [ name, block_() ];\r\n                }\r\n                if (is(\"keyword\", \"finally\")) {\r\n                        next();\r\n                        bfinally = block_();\r\n                }\r\n                if (!bcatch && !bfinally)\r\n                        croak(\"Missing catch/finally blocks\");\r\n                return as(\"try\", body, bcatch, bfinally);\r\n        };\r\n\r\n        function vardefs(no_in) {\r\n                var a = [];\r\n                for (;;) {\r\n                        if (!is(\"name\"))\r\n                                unexpected();\r\n                        var name = S.token.value;\r\n                        next();\r\n                        if (is(\"operator\", \"=\")) {\r\n                                next();\r\n                                a.push([ name, expression(false, no_in) ]);\r\n                        } else {\r\n                                a.push([ name ]);\r\n                        }\r\n                        if (!is(\"punc\", \",\"))\r\n                                break;\r\n                        next();\r\n                }\r\n                return a;\r\n        };\r\n\r\n        function var_(no_in) {\r\n                return as(\"var\", vardefs(no_in));\r\n        };\r\n\r\n        function const_() {\r\n                return as(\"const\", vardefs());\r\n        };\r\n\r\n        function new_() {\r\n                var newexp = expr_atom(false), args;\r\n                if (is(\"punc\", \"(\")) {\r\n                        next();\r\n                        args = expr_list(\")\");\r\n                } else {\r\n                        args = [];\r\n                }\r\n                return subscripts(as(\"new\", newexp, args), true);\r\n        };\r\n\r\n        var expr_atom = maybe_embed_tokens(function(allow_calls) {\r\n                if (is(\"operator\", \"new\")) {\r\n                        next();\r\n                        return new_();\r\n                }\r\n                if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\r\n                        return make_unary(\"unary-prefix\",\r\n                                          prog1(S.token.value, next),\r\n                                          expr_atom(allow_calls));\r\n                }\r\n                if (is(\"punc\")) {\r\n                        switch (S.token.value) {\r\n                            case \"(\":\r\n                                next();\r\n                                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\r\n                            case \"[\":\r\n                                next();\r\n                                return subscripts(array_(), allow_calls);\r\n                            case \"{\":\r\n                                next();\r\n                                return subscripts(object_(), allow_calls);\r\n                        }\r\n                        unexpected();\r\n                }\r\n                if (is(\"keyword\", \"function\")) {\r\n                        next();\r\n                        return subscripts(function_(false), allow_calls);\r\n                }\r\n                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\r\n                        var atom = S.token.type == \"regexp\"\r\n                                ? as(\"regexp\", S.token.value[0], S.token.value[1])\r\n                                : as(S.token.type, S.token.value);\r\n                        return subscripts(prog1(atom, next), allow_calls);\r\n                }\r\n                unexpected();\r\n        });\r\n\r\n        function expr_list(closing, allow_trailing_comma, allow_empty) {\r\n                var first = true, a = [];\r\n                while (!is(\"punc\", closing)) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (allow_trailing_comma && is(\"punc\", closing)) break;\r\n                        if (is(\"punc\", \",\") && allow_empty) {\r\n                                a.push([ \"atom\", \"undefined\" ]);\r\n                        } else {\r\n                                a.push(expression(false));\r\n                        }\r\n                }\r\n                next();\r\n                return a;\r\n        };\r\n\r\n        function array_() {\r\n                var from = S.token.pos,\r\n                    stat = expr_list(\"]\", !exigent_mode, true),\r\n                    to = S.token.pos;\r\n                return as(\"array\", stat, \"[\" + S.text.substr(from, to - from));\r\n        };\r\n\r\n        function object_() {\r\n                var first = true, a = [];\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (!exigent_mode && is(\"punc\", \"}\"))\r\n                                // allow trailing comma\r\n                                break;\r\n                        var type = S.token.type;\r\n                        var name = as_property_name();\r\n                        if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\r\n                                a.push([ as_name(), function_(false), name ]);\r\n                        } else {\r\n                                expect(\":\");\r\n                                a.push([ name, expression(false) ]);\r\n                        }\r\n                }\r\n                next();\r\n                return as(\"object\", a);\r\n        };\r\n\r\n        function as_property_name() {\r\n                switch (S.token.type) {\r\n                    case \"num\":\r\n                    case \"string\":\r\n                        return prog1(S.token.value, next);\r\n                }\r\n                return as_name();\r\n        };\r\n\r\n        function as_name() {\r\n                switch (S.token.type) {\r\n                    case \"name\":\r\n                    case \"operator\":\r\n                    case \"keyword\":\r\n                    case \"atom\":\r\n                        return prog1(S.token.value, next);\r\n                    default:\r\n                        unexpected();\r\n                }\r\n        };\r\n\r\n        function subscripts(expr, allow_calls) {\r\n                if (is(\"punc\", \".\")) {\r\n                        next();\r\n                        return subscripts(as(\"dot\", expr, as_name()), allow_calls);\r\n                }\r\n                if (is(\"punc\", \"[\")) {\r\n                        next();\r\n                        return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\r\n                }\r\n                if (allow_calls && is(\"punc\", \"(\")) {\r\n                        next();\r\n                        return subscripts(as(\"call\", expr, expr_list(\")\")), true);\r\n                }\r\n                if (allow_calls && is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value)) {\r\n                        return prog1(curry(make_unary, \"unary-postfix\", S.token.value, expr),\r\n                                     next);\r\n                }\r\n                return expr;\r\n        };\r\n\r\n        function make_unary(tag, op, expr) {\r\n                if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\r\n                        croak(\"Invalid use of \" + op + \" operator\");\r\n                return as(tag, op, expr);\r\n        };\r\n\r\n        function expr_op(left, min_prec, no_in) {\r\n                var op = is(\"operator\") ? S.token.value : null;\r\n                if (op && op == \"in\" && no_in) op = null;\r\n                var prec = op != null ? PRECEDENCE[op] : null;\r\n                if (prec != null && prec > min_prec) {\r\n                        next();\r\n                        var right = expr_op(expr_atom(true), prec, no_in);\r\n                        return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\r\n                }\r\n                return left;\r\n        };\r\n\r\n        function expr_ops(no_in) {\r\n                return expr_op(expr_atom(true), 0, no_in);\r\n        };\r\n\r\n        function maybe_conditional(no_in) {\r\n                var expr = expr_ops(no_in);\r\n                if (is(\"operator\", \"?\")) {\r\n                        next();\r\n                        var yes = expression(false);\r\n                        expect(\":\");\r\n                        return as(\"conditional\", expr, yes, expression(false, no_in));\r\n                }\r\n                return expr;\r\n        };\r\n\r\n        function is_assignable(expr) {\r\n                if (!exigent_mode) return true;\r\n                switch (expr[0]) {\r\n                    case \"dot\":\r\n                    case \"sub\":\r\n                    case \"new\":\r\n                    case \"call\":\r\n                        return true;\r\n                    case \"name\":\r\n                        return expr[1] != \"this\";\r\n                }\r\n        };\r\n\r\n        function maybe_assign(no_in) {\r\n                var left = maybe_conditional(no_in), val = S.token.value;\r\n                if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\r\n                        if (is_assignable(left)) {\r\n                                next();\r\n                                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\r\n                        }\r\n                        croak(\"Invalid assignment\");\r\n                }\r\n                return left;\r\n        };\r\n\r\n        function maybe_qmlelem(no_in) {\r\n                var expr = maybe_assign(no_in);\r\n                if (is(\"punc\", \"{\"))\r\n                    return as(\"qmlelem\", expr[1], undefined, qmlblock());\r\n                return expr;\r\n        };\r\n\r\n        var expression = maybe_embed_tokens(function(commas, no_in) {\r\n                if (arguments.length == 0)\r\n                        commas = true;\r\n                var expr = maybe_qmlelem(no_in);\r\n                if (commas && is(\"punc\", \",\")) {\r\n                        next();\r\n                        return as(\"seq\", expr, expression(true, no_in));\r\n                }\r\n                return expr;\r\n        });\r\n\r\n        function in_loop(cont) {\r\n                try {\r\n                        ++S.in_loop;\r\n                        return cont();\r\n                } finally {\r\n                        --S.in_loop;\r\n                }\r\n        };\r\n\r\n        function qml_is_element(str) {\r\n            return str[0].toUpperCase() == str[0];\r\n        }\r\n\r\n        function qmlblock() {\r\n            expect(\"{\");\r\n            var a = [];\r\n            while (!is(\"punc\", \"}\")) {\r\n                if (is(\"eof\")) unexpected();\r\n                a.push(qmlstatement());\r\n            }\r\n            expect(\"}\");\r\n            return a;\r\n        }\r\n\r\n        function qmlproperty() {\r\n            switch (S.token.type) {\r\n                case \"name\":\r\n                    return as(\"qmlbinding\", statement());\r\n                case \"num\":\r\n                case \"string\":\r\n                    return as(\"qmlvalue\", prog1(S.token.value, next,\r\n                        semicolon));\r\n                default:\r\n                    todo();\r\n            }\r\n        }\r\n\r\n        function qmlpropdef() {\r\n            var type = S.token.value;\r\n            next();\r\n            var name = S.token.value;\r\n            next();\r\n            if (type == \"alias\") {\r\n                expect(\":\");\r\n                if (!is(\"name\")) unexpected();\r\n                var objName = S.token.value;\r\n                next();\r\n                if (is(\"punc\", \".\")) {\r\n                    next();\r\n                    if (!is(\"name\")) unexpected();\r\n                    var propName = S.token.value;\r\n                    next();\r\n                }\r\n                return as(\"qmlaliasdef\", name, objName, propName);\r\n            }\r\n            if (is(\"punc\", \":\")) {\r\n                next();\r\n                S.in_function++;\r\n                var from = S.token.pos,\r\n                    stat = statement(),\r\n                    to = S.token.pos;\r\n                S.in_function--;\r\n                return as(\"qmlpropdef\", name, type, stat,\r\n                        S.text.substr(from, to - from));\r\n            } else if (is(\"punc\", \";\"))\r\n                next();\r\n            return as(\"qmlpropdef\", name, type);\r\n\r\n        }\r\n\r\n        function qmldefaultprop() {\r\n            next();\r\n            expect_token(\"name\", \"property\");\r\n\r\n            return as(\"qmldefaultprop\", qmlpropdef());\r\n        }\r\n\r\n        function qmlsignaldef() {\r\n            var name = S.token.value;\r\n            next();\r\n            var args = [];\r\n            if (is(\"punc\", \"(\")) {\r\n                next();\r\n                var first = true;\r\n                while (!is(\"punc\", \")\")) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (!is(\"name\")) unexpected();\r\n                        var type = S.token.value;\r\n                        next();\r\n                        if (!is(\"name\")) unexpected();\r\n                        args.push({type: type, name: S.token.value});\r\n                        next();\r\n                }\r\n                next();\r\n            }\r\n            if (is(\"punc\", \";\"))\r\n                next();\r\n            return as(\"qmlsignaldef\", name, args);\r\n\r\n        }\r\n\r\n        function qmlstatement() {\r\n            if (is(\"keyword\", \"function\")) {\r\n                var from = S.token.pos;\r\n                next();\r\n                var stat = function_(true);\r\n                var to = S.token.pos;\r\n                var name = stat[1];\r\n                return as(\"qmlmethod\", name, stat,\r\n                    S.text.substr(from, to - from));\r\n            } else if (is(\"name\", \"signal\")) {\r\n                next();\r\n                if (is(\"punc\", \":\")) {\r\n                    next();\r\n                    S.in_function++;\r\n                    var from = S.token.pos,\r\n                        stat = statement(),\r\n                        to = S.token.pos;\r\n                    S.in_function--;\r\n                    return as(\"qmlprop\", propname, stat,\r\n                        S.text.substr(from, to - from));\r\n                } else {\r\n                    return qmlsignaldef();\r\n                }\r\n            } else if (S.token.type == \"name\") {\r\n                var propname = S.token.value;\r\n                next();\r\n                if (propname == \"property\" && (S.token.type == \"name\" || S.token.value == \"var\")) {\r\n                    return qmlpropdef();\r\n                } else if (qml_is_element(propname) && !is(\"punc\", \".\")) {\r\n                    // Element\r\n                    var onProp;\r\n                    if (is(\"name\", \"on\")) {\r\n                        next();\r\n                        onProp = S.token.value;\r\n                        next();\r\n                    }\r\n                    return as(\"qmlelem\", propname, onProp, qmlblock());\r\n                } else {\r\n                    // property statement\r\n                    if (is(\"punc\", \".\")) {\r\n                        // anchors, fonts etc, a.b: statement;\r\n                        // Can also be Component.onCompleted: ...\r\n                        // Assume only one subproperty\r\n                        next();\r\n                        var subname = S.token.value;\r\n                        next();\r\n                        expect(\":\");\r\n                        S.in_function++;\r\n                        var from = S.token.pos,\r\n                            stat = statement(),\r\n                            to = S.token.pos;\r\n                        S.in_function--;\r\n                        return as(\"qmlobjdef\", propname, subname, stat,\r\n                            S.text.substr(from, to - from));\r\n                    } else if (is(\"punc\", \"{\")) {\r\n                        return as(\"qmlobj\", propname, qmlblock());\r\n                    } else {\r\n                        // Evaluatable item\r\n                        expect(\":\");\r\n                        S.in_function++;\r\n                        var from = S.token.pos,\r\n                            stat = statement(),\r\n                            to = S.token.pos;\r\n                        S.in_function--;\r\n                        return as(\"qmlprop\", propname, stat,\r\n                            S.text.substr(from, to - from));\r\n                    }\r\n                }\r\n            } else if (is(\"keyword\", \"default\")) {\r\n                return qmldefaultprop();\r\n            } else {\r\n                todo();\r\n            }\r\n        }\r\n\r\n        function qmlimport() {\r\n            // todo\r\n            next();\r\n            var moduleName = S.token.value;\r\n            var isDottedNotation = (S.token.type == \"name\");\r\n            next();\r\n            \r\n            while (is(\"punc\", \".\")) {\r\n                next();\r\n                moduleName += \".\" + S.token.value;\r\n                next();\r\n            }\r\n            if (is(\"num\")) {\r\n                var version = S.token.value\r\n                next();\r\n            }\r\n            var namespace = \"\";\r\n            if (is(\"name\", \"as\")) {\r\n                next();\r\n                namespace = S.token.value;\r\n                next();\r\n            }\r\n            return as(\"qmlimport\", moduleName, version, namespace, isDottedNotation);\r\n        }\r\n\r\n        function qmldocument() {\r\n            var imports = [];\r\n            while (is(\"name\", \"import\")) {\r\n                imports.push(qmlimport());\r\n            }\r\n            var root = qmlstatement();\r\n            if (!is(\"eof\"))\r\n                unexpected();\r\n\r\n            return as(\"toplevel\", imports, root);\r\n        }\r\n\r\n        function jsdocument() {\r\n            var statements = [];\r\n            while (!is(\"eof\")) {\r\n                statements.push(statement());\r\n            }\r\n            return as(\"jsresource\", statements);\r\n        }\r\n\r\n        function amIn(s) {\r\n            console && console.log(s, clone(S), S.token.type, S.token.value);\r\n        }\r\n        function todo() {\r\n            amIn(\"todo parse:\");\r\n            next();\r\n        }\r\n\r\n        if (document_type === qmlweb_parse.JSResource) {\r\n            return jsdocument();\r\n        } else {\r\n            return qmldocument();\r\n        }\r\n\r\n};\r\n\r\n/* -----[ Utilities ]----- */\r\n\r\nfunction curry(f) {\r\n        var args = slice(arguments, 1);\r\n        return function() { return f.apply(this, args.concat(slice(arguments))); };\r\n};\r\n\r\nfunction prog1(ret) {\r\n        if (ret instanceof Function)\r\n                ret = ret();\r\n        for (var i = 1, n = arguments.length; --n > 0; ++i)\r\n                arguments[i]();\r\n        return ret;\r\n};\r\n\r\nfunction array_to_hash(a) {\r\n        var ret = {};\r\n        for (var i = 0; i < a.length; ++i)\r\n                ret[a[i]] = true;\r\n        return ret;\r\n};\r\n\r\nfunction slice(a, start) {\r\n        return Array.prototype.slice.call(a, start == null ? 0 : start);\r\n};\r\n\r\nfunction characters(str) {\r\n        return str.split(\"\");\r\n};\r\n\r\nfunction member(name, array) {\r\n        for (var i = array.length; --i >= 0;)\r\n                if (array[i] === name)\r\n                        return true;\r\n        return false;\r\n};\r\n\r\nfunction HOP(obj, prop) {\r\n        return Object.prototype.hasOwnProperty.call(obj, prop);\r\n};\r\n\r\nvar warn = function() {};\r\n\r\nQMLMethod.prototype = new QMLBinding();\r\nfunction QMLMethod(src) {\r\n    this.src = src;\r\n}\r\n\r\n/**\r\n * Create an object representing a QML property definition.\r\n * @param {String} type The type of the property\r\n * @param {Array} value The default value of the property\r\n * @return {Object} Object representing the defintion\r\n */\r\nfunction QMLPropertyDefinition(type, value) {\r\n    this.type = type;\r\n    this.value = value;\r\n}\r\n\r\nfunction QMLAliasDefinition(objName, propName) {\r\n    this.objectName = objName;\r\n    this.propertyName = propName;\r\n}\r\n\r\n/**\r\n * Create an object representing a QML signal definition.\r\n * @param {Array} params The parameters the signal ships\r\n * @return {Object} Object representing the defintion\r\n */\r\nfunction QMLSignalDefinition(params) {\r\n    this.parameters = params;\r\n}\r\n\r\n/**\r\n * Create an object representing a group of QML properties (like anchors).\r\n * @return {Object} Object representing the group\r\n */\r\nfunction QMLMetaPropertyGroup() {}\r\n\r\n/**\r\n * Create an object representing a QML element.\r\n * @param {String} type The type of the element\r\n * @param {String} onProp The name of the property specified with the \"on\" keyword\r\n */\r\nfunction QMLMetaElement(type, onProp) {\r\n    this.$class = type;\r\n    this.$children = [];\r\n    this.$on = onProp;\r\n}\r\n\r\n// Convert parser tree to the format understood by engine\r\nfunction convertToEngine(tree) {\r\n\r\n    // Help logger\r\n    function amIn(str, tree) {\r\n        console.log(str);\r\n        if (tree) console.log(JSON.stringify(tree, null, \"  \"));\r\n    }\r\n\r\n    var walkers = {\r\n        \"toplevel\": function(imports, statement) {\r\n            var item = { $class: \"QMLDocument\" };\r\n            item.$imports = imports;\r\n            item.$children = [ walk(statement) ];\r\n            return item;\r\n        },\r\n        \"qmlelem\": function(elem, onProp, statements) {\r\n            var item = new QMLMetaElement(elem, onProp);\r\n\r\n            for (var i in statements) {\r\n                var statement = statements[i],\r\n                    name = statement[1],\r\n                    val = walk(statement);\r\n                switch (statement[0]) {\r\n                    case \"qmldefaultprop\":\r\n                        item.$defaultProperty = name;\r\n                    case \"qmlprop\":\r\n                    case \"qmlpropdef\":\r\n                    case \"qmlaliasdef\":\r\n                    case \"qmlmethod\":\r\n                    case \"qmlsignaldef\":\r\n                        item[name] = val;\r\n                        break;\r\n                    case \"qmlelem\":\r\n                        item.$children.push(val);\r\n                        break;\r\n                    case \"qmlobjdef\":\r\n                        // Create object to item\r\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\r\n                        item[name][statement[2]] = val;\r\n                        break;\r\n                    case \"qmlobj\":\r\n                        // Create object to item\r\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\r\n                        for (var i in val)\r\n                            item[name][i] = val[i];\r\n                        break;\r\n                    default:\r\n                        console.log(\"Unknown statement\", statement);\r\n\r\n                }\r\n            }\r\n            // Make $children be either a single item or an array, if it's more than one\r\n            if (item.$children.length === 1)\r\n                item.$children = item.$children[0];\r\n\r\n            return item;\r\n        },\r\n        \"qmlprop\": function(name, tree, src) {\r\n            if (name == \"id\") {\r\n                // id property\r\n                return tree[1][1];\r\n            }\r\n            return bindout(tree, src);\r\n        },\r\n        \"qmlobjdef\": function(name, property, tree, src) {\r\n            return bindout(tree, src);\r\n        },\r\n        \"qmlobj\": function(elem, statements) {\r\n            var item = {};\r\n\r\n            for (var i in statements) {\r\n                var statement = statements[i],\r\n                    name = statement[1],\r\n                    val = walk(statement);\r\n                if (statement[0] == \"qmlprop\")\r\n                    item[name] = val;\r\n            }\r\n\r\n            return item;\r\n        },\r\n        \"qmlmethod\": function(name, tree, src) {\r\n            return new QMLMethod(src);\r\n        },\r\n        \"qmlpropdef\": function(name, type, tree, src) {\r\n            return new QMLPropertyDefinition(type, tree ? bindout(tree, src) : \"\");\r\n        },\r\n        \"qmlaliasdef\": function(name, objName, propName) {\r\n            return new QMLAliasDefinition(objName, propName);\r\n        },\r\n        \"qmlsignaldef\": function(name, params) {\r\n            return new QMLSignalDefinition(params);\r\n        },\r\n        \"qmldefaultprop\": function(tree) {\r\n            return walk(tree);\r\n        },\r\n        \"name\": function(src) {\r\n            if (src == \"true\" || src == \"false\")\r\n                return src == \"true\";\r\n            return new QMLBinding(src, [\"name\", src]);\r\n        },\r\n        \"num\": function(src) {\r\n            return +src;\r\n        },\r\n        \"string\": function(src) {\r\n            return String(src);\r\n        },\r\n        \"array\": function(tree, src) {\r\n            var a = [];\r\n            var isList = false;\r\n            var hasBinding = false;\r\n            for (var i in tree) {\r\n                var val = bindout(tree[i]);\r\n                a.push(val);\r\n\r\n                if (val instanceof QMLMetaElement)\r\n                    isList = true;\r\n                else if (val instanceof QMLBinding)\r\n                    hasBinding = true;\r\n            }\r\n\r\n            if (hasBinding) {\r\n                if (isList)\r\n                    throw new TypeError(\"An array may either contain bindings or Element definitions.\");\r\n                return new QMLBinding(src, tree);\r\n            }\r\n\r\n            return a;\r\n        }\r\n    };\r\n\r\n    function walk(tree) {\r\n        var type = tree[0];\r\n        var walker = walkers[type];\r\n        if (!walker) {\r\n            console.log(\"No walker for \" + type);\r\n            return;\r\n        } else {\r\n            return walker.apply(type, tree.slice(1));\r\n        }\r\n    }\r\n\r\n    return walk(tree);\r\n\r\n    // Try to bind out tree and return static variable instead of binding\r\n    function bindout(tree, binding) {\r\n        if (tree[0] === \"stat\") // We want to process the content of the statement\r\n            tree = tree[1];     // (but still handle the case, we get the content directly)\r\n        var type = tree[0];\r\n        var walker = walkers[type];\r\n        if (walker) {\r\n            return walker.apply(type, tree.slice(1));\r\n        } else {\r\n            return new QMLBinding(binding, tree);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Function to parse qml and output tree expected by engine\r\nfunction parseQML(src) {\r\n    var parsetree = qmlweb_parse(src, qmlweb_parse.QmlDocument);\r\n    return convertToEngine(parsetree);\r\n}\r\n\r\nif (typeof global != \"undefined\") {\r\n  global.qmlweb_parse = qmlweb_parse;\r\n}\r\n\n/***********************************************************************\r\n\r\n  A JavaScript tokenizer / parser / beautifier / compressor.\r\n\r\n  This version is suitable for Node.js.  With minimal changes (the\r\n  exports stuff) it should work on any JS platform.\r\n\r\n  This file implements some AST processors.  They work on data built\r\n  by parse-js.\r\n\r\n  Exported functions:\r\n\r\n    - ast_mangle(ast, options) -- mangles the variable/function names\r\n      in the AST.  Returns an AST.\r\n\r\n    - ast_squeeze(ast) -- employs various optimizations to make the\r\n      final generated code even smaller.  Returns an AST.\r\n\r\n    - gen_code(ast, options) -- generates JS code from the AST.  Pass\r\n      true (or an object, see the code for some options) as second\r\n      argument to get \"pretty\" (indented) code.\r\n\r\n  -------------------------------- (C) ---------------------------------\r\n\r\n                           Author: Mihai Bazon\r\n                         <mihai.bazon@gmail.com>\r\n                       http://mihai.bazon.net/blog\r\n\r\n  Distributed under the BSD license:\r\n\r\n    Copyright 2011 (c) Lauri Paimen <lauri@paimen.info>\r\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions\r\n    are met:\r\n\r\n        * Redistributions of source code must retain the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer.\r\n\r\n        * Redistributions in binary form must reproduce the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer in the documentation and/or other materials\r\n          provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n    SUCH DAMAGE.\r\n\r\n ***********************************************************************/\r\n\r\n/*\r\n * Based on Javascript parser written by Mihai Bazon for UglifyJS project.\r\n * That, again, is a port of Javascript parser by Marijn Haverbeke.\r\n * Big thanks to both of you (and others involved)!\r\n * UglifyJS: https://github.com/mishoo/UglifyJS\r\n * Marijn's parser: http://marijn.haverbeke.nl/parse-js/\r\n *\r\n * The primary goal of this file is to offer QML parsing *on top of UglifyJS\r\n * parser* and to change Javascript parts as little as possible. If you find\r\n * bugs/improvements to Javascript parsing parts, check if those are fixed to\r\n * UglifyJS parser first. If not, fix them there. After UglifyJS has been fixed,\r\n * backport the changes to this file. Less changes to Javascript, more easy it\r\n * will be to keep up with UglifyJS.\r\n * Ultimately it would be great to keep the original parser and QML additions in\r\n * different files but the structure of code does not support that.\r\n */\r\n\r\n/*\r\nvar jsp = require(\"./parse-js\"),\r\n    slice = jsp.slice,\r\n    member = jsp.member,\r\n    PRECEDENCE = jsp.PRECEDENCE,\r\n    OPERATORS = jsp.OPERATORS;\r\n*/\r\n\r\n/* -----[ helper for AST traversal ]----- */\r\n\r\nfunction ast_walker(ast) {\r\n        function _vardefs(defs) {\r\n                return [ this[0], MAP(defs, function(def){\r\n                        var a = [ def[0] ];\r\n                        if (def.length > 1)\r\n                                a[1] = walk(def[1]);\r\n                        return a;\r\n                }) ];\r\n        };\r\n        function _block(statements) {\r\n                var out = [ this[0] ];\r\n                if (statements != null)\r\n                        out.push(MAP(statements, walk));\r\n                return out;\r\n        };\r\n        var walkers = {\r\n                \"string\": function(str) {\r\n                        return [ this[0], str ];\r\n                },\r\n                \"num\": function(num) {\r\n                        return [ this[0], num ];\r\n                },\r\n                \"name\": function(name) {\r\n                        return [ this[0], name ];\r\n                },\r\n                \"toplevel\": function(statements) {\r\n                        return [ this[0], MAP(statements, walk) ];\r\n                },\r\n                \"block\": _block,\r\n                \"splice\": _block,\r\n                \"var\": _vardefs,\r\n                \"const\": _vardefs,\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                this[0],\r\n                                MAP(t, walk),\r\n                                c != null ? [ c[0], MAP(c[1], walk) ] : null,\r\n                                f != null ? MAP(f, walk) : null\r\n                        ];\r\n                },\r\n                \"throw\": function(expr) {\r\n                        return [ this[0], walk(expr) ];\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        return [ this[0], walk(ctor), MAP(args, walk) ];\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        return [ this[0], walk(expr), MAP(body, function(branch){\r\n                                return [ branch[0] ? walk(branch[0]) : null,\r\n                                         MAP(branch[1], walk) ];\r\n                        }) ];\r\n                },\r\n                \"break\": function(label) {\r\n                        return [ this[0], label ];\r\n                },\r\n                \"continue\": function(label) {\r\n                        return [ this[0], label ];\r\n                },\r\n                \"conditional\": function(cond, t, e) {\r\n                        return [ this[0], walk(cond), walk(t), walk(e) ];\r\n                },\r\n                \"assign\": function(op, lvalue, rvalue) {\r\n                        return [ this[0], op, walk(lvalue), walk(rvalue) ];\r\n                },\r\n                \"dot\": function(expr) {\r\n                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));\r\n                },\r\n                \"call\": function(expr, args) {\r\n                        return [ this[0], walk(expr), MAP(args, walk) ];\r\n                },\r\n                \"function\": function(name, args, body) {\r\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\r\n                },\r\n                \"defun\": function(name, args, body) {\r\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\r\n                },\r\n                \"if\": function(conditional, t, e) {\r\n                        return [ this[0], walk(conditional), walk(t), walk(e) ];\r\n                },\r\n                \"for\": function(init, cond, step, block) {\r\n                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];\r\n                },\r\n                \"for-in\": function(vvar, key, hash, block) {\r\n                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];\r\n                },\r\n                \"while\": function(cond, block) {\r\n                        return [ this[0], walk(cond), walk(block) ];\r\n                },\r\n                \"do\": function(cond, block) {\r\n                        return [ this[0], walk(cond), walk(block) ];\r\n                },\r\n                \"return\": function(expr) {\r\n                        return [ this[0], walk(expr) ];\r\n                },\r\n                \"binary\": function(op, left, right) {\r\n                        return [ this[0], op, walk(left), walk(right) ];\r\n                },\r\n                \"unary-prefix\": function(op, expr) {\r\n                        return [ this[0], op, walk(expr) ];\r\n                },\r\n                \"unary-postfix\": function(op, expr) {\r\n                        return [ this[0], op, walk(expr) ];\r\n                },\r\n                \"sub\": function(expr, subscript) {\r\n                        return [ this[0], walk(expr), walk(subscript) ];\r\n                },\r\n                \"object\": function(props) {\r\n                        return [ this[0], MAP(props, function(p){\r\n                                return p.length == 2\r\n                                        ? [ p[0], walk(p[1]) ]\r\n                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter\r\n                        }) ];\r\n                },\r\n                \"regexp\": function(rx, mods) {\r\n                        return [ this[0], rx, mods ];\r\n                },\r\n                \"array\": function(elements) {\r\n                        return [ this[0], MAP(elements, walk) ];\r\n                },\r\n                \"stat\": function(stat) {\r\n                        return [ this[0], walk(stat) ];\r\n                },\r\n                \"seq\": function() {\r\n                        return [ this[0] ].concat(MAP(slice(arguments), walk));\r\n                },\r\n                \"label\": function(name, block) {\r\n                        return [ this[0], name, walk(block) ];\r\n                },\r\n                \"with\": function(expr, block) {\r\n                        return [ this[0], walk(expr), walk(block) ];\r\n                },\r\n                \"atom\": function(name) {\r\n                        return [ this[0], name ];\r\n                }\r\n        };\r\n\r\n        var user = {};\r\n        var stack = [];\r\n        function walk(ast) {\r\n                if (ast == null)\r\n                        return null;\r\n                try {\r\n                        stack.push(ast);\r\n                        var type = ast[0];\r\n                        var gen = user[type];\r\n                        if (gen) {\r\n                                var ret = gen.apply(ast, ast.slice(1));\r\n                                if (ret != null)\r\n                                        return ret;\r\n                        }\r\n                        gen = walkers[type];\r\n                        return gen.apply(ast, ast.slice(1));\r\n                } finally {\r\n                        stack.pop();\r\n                }\r\n        };\r\n\r\n        function with_walkers(walkers, cont){\r\n                var save = {}, i;\r\n                for (i in walkers) if (HOP(walkers, i)) {\r\n                        save[i] = user[i];\r\n                        user[i] = walkers[i];\r\n                }\r\n                var ret = cont();\r\n                for (i in save) if (HOP(save, i)) {\r\n                        if (!save[i]) delete user[i];\r\n                        else user[i] = save[i];\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        return {\r\n                walk: walk,\r\n                with_walkers: with_walkers,\r\n                parent: function() {\r\n                        return stack[stack.length - 2]; // last one is current node\r\n                },\r\n                stack: function() {\r\n                        return stack;\r\n                }\r\n        };\r\n};\r\n\r\n/* -----[ Scope and mangling ]----- */\r\n\r\nfunction Scope(parent) {\r\n        this.names = {};        // names defined in this scope\r\n        this.mangled = {};      // mangled names (orig.name => mangled)\r\n        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)\r\n        this.cname = -1;        // current mangled name\r\n        this.refs = {};         // names referenced from this scope\r\n        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes\r\n        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes\r\n        this.parent = parent;   // parent scope\r\n        this.children = [];     // sub-scopes\r\n        if (parent) {\r\n                this.level = parent.level + 1;\r\n                parent.children.push(this);\r\n        } else {\r\n                this.level = 0;\r\n        }\r\n};\r\n\r\nvar base54 = (function(){\r\n        var DIGITS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\r\n        return function(num) {\r\n                var ret = \"\";\r\n                do {\r\n                        ret = DIGITS.charAt(num % 54) + ret;\r\n                        num = Math.floor(num / 54);\r\n                } while (num > 0);\r\n                return ret;\r\n        };\r\n})();\r\n\r\nScope.prototype = {\r\n        has: function(name) {\r\n                for (var s = this; s; s = s.parent)\r\n                        if (HOP(s.names, name))\r\n                                return s;\r\n        },\r\n        has_mangled: function(mname) {\r\n                for (var s = this; s; s = s.parent)\r\n                        if (HOP(s.rev_mangled, mname))\r\n                                return s;\r\n        },\r\n        toJSON: function() {\r\n                return {\r\n                        names: this.names,\r\n                        uses_eval: this.uses_eval,\r\n                        uses_with: this.uses_with\r\n                };\r\n        },\r\n\r\n        next_mangled: function() {\r\n                // we must be careful that the new mangled name:\r\n                //\r\n                // 1. doesn't shadow a mangled name from a parent\r\n                //    scope, unless we don't reference the original\r\n                //    name from this scope OR from any sub-scopes!\r\n                //    This will get slow.\r\n                //\r\n                // 2. doesn't shadow an original name from a parent\r\n                //    scope, in the event that the name is not mangled\r\n                //    in the parent scope and we reference that name\r\n                //    here OR IN ANY SUBSCOPES!\r\n                //\r\n                // 3. doesn't shadow a name that is referenced but not\r\n                //    defined (possibly global defined elsewhere).\r\n                for (;;) {\r\n                        var m = base54(++this.cname), prior;\r\n\r\n                        // case 1.\r\n                        prior = this.has_mangled(m);\r\n                        if (prior && this.refs[prior.rev_mangled[m]] === prior)\r\n                                continue;\r\n\r\n                        // case 2.\r\n                        prior = this.has(m);\r\n                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))\r\n                                continue;\r\n\r\n                        // case 3.\r\n                        if (HOP(this.refs, m) && this.refs[m] == null)\r\n                                continue;\r\n\r\n                        // I got \"do\" once. :-/\r\n                        if (!is_identifier(m))\r\n                                continue;\r\n\r\n                        return m;\r\n                }\r\n        },\r\n        set_mangle: function(name, m) {\r\n                this.rev_mangled[m] = name;\r\n                return this.mangled[name] = m;\r\n        },\r\n        get_mangled: function(name, newMangle) {\r\n                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use\r\n                var s = this.has(name);\r\n                if (!s) return name; // not in visible scope, no mangle\r\n                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope\r\n                if (!newMangle) return name;                      // not found and no mangling requested\r\n                return s.set_mangle(name, s.next_mangled());\r\n        },\r\n        references: function(name) {\r\n                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];\r\n        },\r\n        define: function(name, type) {\r\n                if (name != null) {\r\n                        if (type == \"var\" || !HOP(this.names, name))\r\n                                this.names[name] = type || \"var\";\r\n                        return name;\r\n                }\r\n        }\r\n};\r\n\r\nfunction ast_add_scope(ast) {\r\n\r\n        var current_scope = null;\r\n        var w = ast_walker(), walk = w.walk;\r\n        var having_eval = [];\r\n\r\n        function with_new_scope(cont) {\r\n                current_scope = new Scope(current_scope);\r\n                var ret = current_scope.body = cont();\r\n                ret.scope = current_scope;\r\n                current_scope = current_scope.parent;\r\n                return ret;\r\n        };\r\n\r\n        function define(name, type) {\r\n                return current_scope.define(name, type);\r\n        };\r\n\r\n        function reference(name) {\r\n                current_scope.refs[name] = true;\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\";\r\n                return [ this[0], is_defun ? define(name, \"defun\") : name, args, with_new_scope(function(){\r\n                        if (!is_defun) define(name, \"lambda\");\r\n                        MAP(args, function(name){ define(name, \"arg\") });\r\n                        return MAP(body, walk);\r\n                })];\r\n        };\r\n\r\n        function _vardefs(type) {\r\n                return function(defs) {\r\n                        MAP(defs, function(d){\r\n                                define(d[0], type);\r\n                                if (d[1]) reference(d[0]);\r\n                        });\r\n                };\r\n        };\r\n\r\n        return with_new_scope(function(){\r\n                // process AST\r\n                var ret = w.with_walkers({\r\n                        \"function\": _lambda,\r\n                        \"defun\": _lambda,\r\n                        \"label\": function(name, stat) { define(name, \"label\") },\r\n                        \"break\": function(label) { if (label) reference(label) },\r\n                        \"continue\": function(label) { if (label) reference(label) },\r\n                        \"with\": function(expr, block) {\r\n                                for (var s = current_scope; s; s = s.parent)\r\n                                        s.uses_with = true;\r\n                        },\r\n                        \"var\": _vardefs(\"var\"),\r\n                        \"const\": _vardefs(\"const\"),\r\n                        \"try\": function(t, c, f) {\r\n                                if (c != null) return [\r\n                                        this[0],\r\n                                        MAP(t, walk),\r\n                                        [ define(c[0], \"catch\"), MAP(c[1], walk) ],\r\n                                        f != null ? MAP(f, walk) : null\r\n                                ];\r\n                        },\r\n                        \"name\": function(name) {\r\n                                if (name == \"eval\")\r\n                                        having_eval.push(current_scope);\r\n                                reference(name);\r\n                        }\r\n                }, function(){\r\n                        return walk(ast);\r\n                });\r\n\r\n                // the reason why we need an additional pass here is\r\n                // that names can be used prior to their definition.\r\n\r\n                // scopes where eval was detected and their parents\r\n                // are marked with uses_eval, unless they define the\r\n                // \"eval\" name.\r\n                MAP(having_eval, function(scope){\r\n                        if (!scope.has(\"eval\")) while (scope) {\r\n                                scope.uses_eval = true;\r\n                                scope = scope.parent;\r\n                        }\r\n                });\r\n\r\n                // for referenced names it might be useful to know\r\n                // their origin scope.  current_scope here is the\r\n                // toplevel one.\r\n                function fixrefs(scope, i) {\r\n                        // do children first; order shouldn't matter\r\n                        for (i = scope.children.length; --i >= 0;)\r\n                                fixrefs(scope.children[i]);\r\n                        for (i in scope.refs) if (HOP(scope.refs, i)) {\r\n                                // find origin scope and propagate the reference to origin\r\n                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {\r\n                                        s.refs[i] = origin;\r\n                                        if (s === origin) break;\r\n                                }\r\n                        }\r\n                };\r\n                fixrefs(current_scope);\r\n\r\n                return ret;\r\n        });\r\n\r\n};\r\n\r\n/* -----[ mangle names ]----- */\r\n\r\nfunction ast_mangle(ast, options) {\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n        options = options || {};\r\n\r\n        function get_mangled(name, newMangle) {\r\n                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel\r\n                if (options.except && member(name, options.except))\r\n                        return name;\r\n                return scope.get_mangled(name, newMangle);\r\n        };\r\n\r\n        function get_define(name) {\r\n                if (options.defines) {\r\n                        // we always lookup a defined symbol for the current scope FIRST, so declared\r\n                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value\r\n                        if (!scope.has(name)) {\r\n                                if (HOP(options.defines, name)) {\r\n                                        return options.defines[name];\r\n                                }\r\n                        }\r\n                        return null;\r\n                }\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\", extra;\r\n                if (name) {\r\n                        if (is_defun) name = get_mangled(name);\r\n                        else {\r\n                                extra = {};\r\n                                if (!(scope.uses_eval || scope.uses_with))\r\n                                        name = extra[name] = scope.next_mangled();\r\n                                else\r\n                                        extra[name] = name;\r\n                        }\r\n                }\r\n                body = with_scope(body.scope, function(){\r\n                        args = MAP(args, function(name){ return get_mangled(name) });\r\n                        return MAP(body, walk);\r\n                }, extra);\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        function with_scope(s, cont, extra) {\r\n                var _scope = scope;\r\n                scope = s;\r\n                if (extra) for (var i in extra) if (HOP(extra, i)) {\r\n                        s.set_mangle(i, extra[i]);\r\n                }\r\n                for (var i in s.names) if (HOP(s.names, i)) {\r\n                        get_mangled(i, true);\r\n                }\r\n                var ret = cont();\r\n                ret.scope = s;\r\n                scope = _scope;\r\n                return ret;\r\n        };\r\n\r\n        function _vardefs(defs) {\r\n                return [ this[0], MAP(defs, function(d){\r\n                        return [ get_mangled(d[0]), walk(d[1]) ];\r\n                }) ];\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"function\": _lambda,\r\n                \"defun\": function() {\r\n                        // move function declarations to the top when\r\n                        // they are not in some block.\r\n                        var ast = _lambda.apply(this, arguments);\r\n                        switch (w.parent()[0]) {\r\n                            case \"toplevel\":\r\n                            case \"function\":\r\n                            case \"defun\":\r\n                                return MAP.at_top(ast);\r\n                        }\r\n                        return ast;\r\n                },\r\n                \"label\": function(label, stat) { return [ this[0], get_mangled(label), walk(stat) ] },\r\n                \"break\": function(label) { if (label) return [ this[0], get_mangled(label) ] },\r\n                \"continue\": function(label) { if (label) return [ this[0], get_mangled(label) ] },\r\n                \"var\": _vardefs,\r\n                \"const\": _vardefs,\r\n                \"name\": function(name) {\r\n                        return get_define(name) || [ this[0], get_mangled(name) ];\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [ this[0],\r\n                                 MAP(t, walk),\r\n                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,\r\n                                 f != null ? MAP(f, walk) : null ];\r\n                },\r\n                \"toplevel\": function(body) {\r\n                        var self = this;\r\n                        return with_scope(self.scope, function(){\r\n                                return [ self[0], MAP(body, walk) ];\r\n                        });\r\n                }\r\n        }, function() {\r\n                return walk(ast_add_scope(ast));\r\n        });\r\n};\r\n\r\n/* -----[\r\n   - compress foo[\"bar\"] into foo.bar,\r\n   - remove block brackets {} where possible\r\n   - join consecutive var declarations\r\n   - various optimizations for IFs:\r\n     - if (cond) foo(); else bar();  ==>  cond?foo():bar();\r\n     - if (cond) foo();  ==>  cond&&foo();\r\n     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw\r\n     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}\r\n   ]----- */\r\n\r\nvar warn = function(){};\r\n\r\nfunction best_of(ast1, ast2) {\r\n        return gen_code(ast1).length > gen_code(ast2[0] == \"stat\" ? ast2[1] : ast2).length ? ast2 : ast1;\r\n};\r\n\r\nfunction last_stat(b) {\r\n        if (b[0] == \"block\" && b[1] && b[1].length > 0)\r\n                return b[1][b[1].length - 1];\r\n        return b;\r\n}\r\n\r\nfunction aborts(t) {\r\n        if (t) switch (last_stat(t)[0]) {\r\n            case \"return\":\r\n            case \"break\":\r\n            case \"continue\":\r\n            case \"throw\":\r\n                return true;\r\n        }\r\n};\r\n\r\nfunction boolean_expr(expr) {\r\n        return ( (expr[0] == \"unary-prefix\"\r\n                  && member(expr[1], [ \"!\", \"delete\" ])) ||\r\n\r\n                 (expr[0] == \"binary\"\r\n                  && member(expr[1], [ \"in\", \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">=\", \">\" ])) ||\r\n\r\n                 (expr[0] == \"binary\"\r\n                  && member(expr[1], [ \"&&\", \"||\" ])\r\n                  && boolean_expr(expr[2])\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"conditional\"\r\n                  && boolean_expr(expr[2])\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"assign\"\r\n                  && expr[1] === true\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"seq\"\r\n                  && boolean_expr(expr[expr.length - 1]))\r\n               );\r\n};\r\n\r\nfunction make_conditional(c, t, e) {\r\n    var make_real_conditional = function() {\r\n        if (c[0] == \"unary-prefix\" && c[1] == \"!\") {\r\n            return e ? [ \"conditional\", c[2], e, t ] : [ \"binary\", \"||\", c[2], t ];\r\n        } else {\r\n            return e ? [ \"conditional\", c, t, e ] : [ \"binary\", \"&&\", c, t ];\r\n        }\r\n    };\r\n    // shortcut the conditional if the expression has a constant value\r\n    return when_constant(c, function(ast, val){\r\n        warn_unreachable(val ? e : t);\r\n        return          (val ? t : e);\r\n    }, make_real_conditional);\r\n};\r\n\r\nfunction empty(b) {\r\n        return !b || (b[0] == \"block\" && (!b[1] || b[1].length == 0));\r\n};\r\n\r\nfunction is_string(node) {\r\n        return (node[0] == \"string\" ||\r\n                node[0] == \"unary-prefix\" && node[1] == \"typeof\" ||\r\n                node[0] == \"binary\" && node[1] == \"+\" &&\r\n                (is_string(node[2]) || is_string(node[3])));\r\n};\r\n\r\nvar when_constant = (function(){\r\n\r\n        var $NOT_CONSTANT = {};\r\n\r\n        // this can only evaluate constant expressions.  If it finds anything\r\n        // not constant, it throws $NOT_CONSTANT.\r\n        function evaluate(expr) {\r\n                switch (expr[0]) {\r\n                    case \"string\":\r\n                    case \"num\":\r\n                        return expr[1];\r\n                    case \"name\":\r\n                    case \"atom\":\r\n                        switch (expr[1]) {\r\n                            case \"true\": return true;\r\n                            case \"false\": return false;\r\n                        }\r\n                        break;\r\n                    case \"unary-prefix\":\r\n                        switch (expr[1]) {\r\n                            case \"!\": return !evaluate(expr[2]);\r\n                            case \"typeof\": return typeof evaluate(expr[2]);\r\n                            case \"~\": return ~evaluate(expr[2]);\r\n                            case \"-\": return -evaluate(expr[2]);\r\n                            case \"+\": return +evaluate(expr[2]);\r\n                        }\r\n                        break;\r\n                    case \"binary\":\r\n                        var left = expr[2], right = expr[3];\r\n                        switch (expr[1]) {\r\n                            case \"&&\"         : return evaluate(left) &&         evaluate(right);\r\n                            case \"||\"         : return evaluate(left) ||         evaluate(right);\r\n                            case \"|\"          : return evaluate(left) |          evaluate(right);\r\n                            case \"&\"          : return evaluate(left) &          evaluate(right);\r\n                            case \"^\"          : return evaluate(left) ^          evaluate(right);\r\n                            case \"+\"          : return evaluate(left) +          evaluate(right);\r\n                            case \"*\"          : return evaluate(left) *          evaluate(right);\r\n                            case \"/\"          : return evaluate(left) /          evaluate(right);\r\n                            case \"-\"          : return evaluate(left) -          evaluate(right);\r\n                            case \"<<\"         : return evaluate(left) <<         evaluate(right);\r\n                            case \">>\"         : return evaluate(left) >>         evaluate(right);\r\n                            case \">>>\"        : return evaluate(left) >>>        evaluate(right);\r\n                            case \"==\"         : return evaluate(left) ==         evaluate(right);\r\n                            case \"===\"        : return evaluate(left) ===        evaluate(right);\r\n                            case \"!=\"         : return evaluate(left) !=         evaluate(right);\r\n                            case \"!==\"        : return evaluate(left) !==        evaluate(right);\r\n                            case \"<\"          : return evaluate(left) <          evaluate(right);\r\n                            case \"<=\"         : return evaluate(left) <=         evaluate(right);\r\n                            case \">\"          : return evaluate(left) >          evaluate(right);\r\n                            case \">=\"         : return evaluate(left) >=         evaluate(right);\r\n                            case \"in\"         : return evaluate(left) in         evaluate(right);\r\n                            case \"instanceof\" : return evaluate(left) instanceof evaluate(right);\r\n                        }\r\n                }\r\n                throw $NOT_CONSTANT;\r\n        };\r\n\r\n        return function(expr, yes, no) {\r\n                try {\r\n                        var val = evaluate(expr), ast;\r\n                        switch (typeof val) {\r\n                            case \"string\": ast =  [ \"string\", val ]; break;\r\n                            case \"number\": ast =  [ \"num\", val ]; break;\r\n                            case \"boolean\": ast =  [ \"name\", String(val) ]; break;\r\n                            default: throw new Error(\"Can't handle constant of type: \" + (typeof val));\r\n                        }\r\n                        return yes.call(expr, ast, val);\r\n                } catch(ex) {\r\n                        if (ex === $NOT_CONSTANT) {\r\n                                if (expr[0] == \"binary\"\r\n                                    && (expr[1] == \"===\" || expr[1] == \"!==\")\r\n                                    && ((is_string(expr[2]) && is_string(expr[3]))\r\n                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {\r\n                                        expr[1] = expr[1].substr(0, 2);\r\n                                }\r\n                                else if (no && expr[0] == \"binary\"\r\n                                         && (expr[1] == \"||\" || expr[1] == \"&&\")) {\r\n                                    // the whole expression is not constant but the lval may be...\r\n                                    try {\r\n                                        var lval = evaluate(expr[2]);\r\n                                        expr = ((expr[1] == \"&&\" && (lval ? expr[3] : lval))    ||\r\n                                                (expr[1] == \"||\" && (lval ? lval    : expr[3])) ||\r\n                                                expr);\r\n                                    } catch(ex2) {\r\n                                        // IGNORE... lval is not constant\r\n                                    }\r\n                                }\r\n                                return no ? no.call(expr, expr) : null;\r\n                        }\r\n                        else throw ex;\r\n                }\r\n        };\r\n\r\n})();\r\n\r\nfunction warn_unreachable(ast) {\r\n        if (!empty(ast))\r\n                warn(\"Dropping unreachable code: \" + gen_code(ast, true));\r\n};\r\n\r\nfunction prepare_ifs(ast) {\r\n        var w = ast_walker(), walk = w.walk;\r\n        // In this first pass, we rewrite ifs which abort with no else with an\r\n        // if-else.  For example:\r\n        //\r\n        // if (x) {\r\n        //     blah();\r\n        //     return y;\r\n        // }\r\n        // foobar();\r\n        //\r\n        // is rewritten into:\r\n        //\r\n        // if (x) {\r\n        //     blah();\r\n        //     return y;\r\n        // } else {\r\n        //     foobar();\r\n        // }\r\n        function redo_if(statements) {\r\n                statements = MAP(statements, walk);\r\n\r\n                for (var i = 0; i < statements.length; ++i) {\r\n                        var fi = statements[i];\r\n                        if (fi[0] != \"if\") continue;\r\n\r\n                        if (fi[3] && walk(fi[3])) continue;\r\n\r\n                        var t = walk(fi[2]);\r\n                        if (!aborts(t)) continue;\r\n\r\n                        var conditional = walk(fi[1]);\r\n\r\n                        var e_body = statements.slice(i + 1);\r\n                        var e = e_body.length == 1 ? e_body[0] : [ \"block\", e_body ];\r\n\r\n                        var ret = statements.slice(0, i).concat([ [\r\n                                fi[0],          // \"if\"\r\n                                conditional,    // conditional\r\n                                t,              // then\r\n                                e               // else\r\n                        ] ]);\r\n\r\n                        return redo_if(ret);\r\n                }\r\n\r\n                return statements;\r\n        };\r\n\r\n        function redo_if_lambda(name, args, body) {\r\n                body = redo_if(body);\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        function redo_if_block(statements) {\r\n                return [ this[0], statements != null ? redo_if(statements) : null ];\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"defun\": redo_if_lambda,\r\n                \"function\": redo_if_lambda,\r\n                \"block\": redo_if_block,\r\n                \"splice\": redo_if_block,\r\n                \"toplevel\": function(statements) {\r\n                        return [ this[0], redo_if(statements) ];\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                this[0],\r\n                                redo_if(t),\r\n                                c != null ? [ c[0], redo_if(c[1]) ] : null,\r\n                                f != null ? redo_if(f) : null\r\n                        ];\r\n                }\r\n        }, function() {\r\n                return walk(ast);\r\n        });\r\n};\r\n\r\nfunction for_side_effects(ast, handler) {\r\n        var w = ast_walker(), walk = w.walk;\r\n        var $stop = {}, $restart = {};\r\n        function stop() { throw $stop };\r\n        function restart() { throw $restart };\r\n        function found(){ return handler.call(this, this, w, stop, restart) };\r\n        function unary(op) {\r\n                if (op == \"++\" || op == \"--\")\r\n                        return found.apply(this, arguments);\r\n        };\r\n        return w.with_walkers({\r\n                \"try\": found,\r\n                \"throw\": found,\r\n                \"return\": found,\r\n                \"new\": found,\r\n                \"switch\": found,\r\n                \"break\": found,\r\n                \"continue\": found,\r\n                \"assign\": found,\r\n                \"call\": found,\r\n                \"if\": found,\r\n                \"for\": found,\r\n                \"for-in\": found,\r\n                \"while\": found,\r\n                \"do\": found,\r\n                \"return\": found,\r\n                \"unary-prefix\": unary,\r\n                \"unary-postfix\": unary,\r\n                \"defun\": found\r\n        }, function(){\r\n                while (true) try {\r\n                        walk(ast);\r\n                        break;\r\n                } catch(ex) {\r\n                        if (ex === $stop) break;\r\n                        if (ex === $restart) continue;\r\n                        throw ex;\r\n                }\r\n        });\r\n};\r\n\r\nfunction ast_lift_variables(ast) {\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n        function do_body(body, env) {\r\n                var _scope = scope;\r\n                scope = env;\r\n                body = MAP(body, walk);\r\n                var hash = {}, names = MAP(env.names, function(type, name){\r\n                        if (type != \"var\") return MAP.skip;\r\n                        if (!env.references(name)) return MAP.skip;\r\n                        hash[name] = true;\r\n                        return [ name ];\r\n                });\r\n                if (names.length > 0) {\r\n                        // looking for assignments to any of these variables.\r\n                        // we can save considerable space by moving the definitions\r\n                        // in the var declaration.\r\n                        for_side_effects([ \"block\", body ], function(ast, walker, stop, restart) {\r\n                                if (ast[0] == \"assign\"\r\n                                    && ast[1] === true\r\n                                    && ast[2][0] == \"name\"\r\n                                    && HOP(hash, ast[2][1])) {\r\n                                        // insert the definition into the var declaration\r\n                                        for (var i = names.length; --i >= 0;) {\r\n                                                if (names[i][0] == ast[2][1]) {\r\n                                                        if (names[i][1]) // this name already defined, we must stop\r\n                                                                stop();\r\n                                                        names[i][1] = ast[3]; // definition\r\n                                                        names.push(names.splice(i, 1)[0]);\r\n                                                        break;\r\n                                                }\r\n                                        }\r\n                                        // remove this assignment from the AST.\r\n                                        var p = walker.parent();\r\n                                        if (p[0] == \"seq\") {\r\n                                                var a = p[2];\r\n                                                a.unshift(0, p.length);\r\n                                                p.splice.apply(p, a);\r\n                                        }\r\n                                        else if (p[0] == \"stat\") {\r\n                                                p.splice(0, p.length, \"block\"); // empty statement\r\n                                        }\r\n                                        else {\r\n                                                stop();\r\n                                        }\r\n                                        restart();\r\n                                }\r\n                                stop();\r\n                        });\r\n                        body.unshift([ \"var\", names ]);\r\n                }\r\n                scope = _scope;\r\n                return body;\r\n        };\r\n        function _vardefs(defs) {\r\n                var ret = null;\r\n                for (var i = defs.length; --i >= 0;) {\r\n                        var d = defs[i];\r\n                        if (!d[1]) continue;\r\n                        d = [ \"assign\", true, [ \"name\", d[0] ], d[1] ];\r\n                        if (ret == null) ret = d;\r\n                        else ret = [ \"seq\", d, ret ];\r\n                }\r\n                if (ret == null) {\r\n                        if (w.parent()[0] == \"for-in\")\r\n                                return [ \"name\", defs[0][0] ];\r\n                        return MAP.skip;\r\n                }\r\n                return [ \"stat\", ret ];\r\n        };\r\n        function _toplevel(body) {\r\n                return [ this[0], do_body(body, this.scope) ];\r\n        };\r\n        return w.with_walkers({\r\n                \"function\": function(name, args, body){\r\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\r\n                                args.pop();\r\n                        if (!body.scope.references(name)) name = null;\r\n                        return [ this[0], name, args, do_body(body, body.scope) ];\r\n                },\r\n                \"defun\": function(name, args, body){\r\n                        if (!scope.references(name)) return MAP.skip;\r\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\r\n                                args.pop();\r\n                        return [ this[0], name, args, do_body(body, body.scope) ];\r\n                },\r\n                \"var\": _vardefs,\r\n                \"toplevel\": _toplevel\r\n        }, function(){\r\n                return walk(ast_add_scope(ast));\r\n        });\r\n};\r\n\r\nfunction ast_squeeze(ast, options) {\r\n        options = defaults(options, {\r\n                make_seqs   : true,\r\n                dead_code   : true,\r\n                keep_comps  : true,\r\n                no_warnings : false\r\n        });\r\n\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n\r\n        function negate(c) {\r\n                var not_c = [ \"unary-prefix\", \"!\", c ];\r\n                switch (c[0]) {\r\n                    case \"unary-prefix\":\r\n                        return c[1] == \"!\" && boolean_expr(c[2]) ? c[2] : not_c;\r\n                    case \"seq\":\r\n                        c = slice(c);\r\n                        c[c.length - 1] = negate(c[c.length - 1]);\r\n                        return c;\r\n                    case \"conditional\":\r\n                        return best_of(not_c, [ \"conditional\", c[1], negate(c[2]), negate(c[3]) ]);\r\n                    case \"binary\":\r\n                        var op = c[1], left = c[2], right = c[3];\r\n                        if (!options.keep_comps) switch (op) {\r\n                            case \"<=\"  : return [ \"binary\", \">\", left, right ];\r\n                            case \"<\"   : return [ \"binary\", \">=\", left, right ];\r\n                            case \">=\"  : return [ \"binary\", \"<\", left, right ];\r\n                            case \">\"   : return [ \"binary\", \"<=\", left, right ];\r\n                        }\r\n                        switch (op) {\r\n                            case \"==\"  : return [ \"binary\", \"!=\", left, right ];\r\n                            case \"!=\"  : return [ \"binary\", \"==\", left, right ];\r\n                            case \"===\" : return [ \"binary\", \"!==\", left, right ];\r\n                            case \"!==\" : return [ \"binary\", \"===\", left, right ];\r\n                            case \"&&\"  : return best_of(not_c, [ \"binary\", \"||\", negate(left), negate(right) ]);\r\n                            case \"||\"  : return best_of(not_c, [ \"binary\", \"&&\", negate(left), negate(right) ]);\r\n                        }\r\n                        break;\r\n                }\r\n                return not_c;\r\n        };\r\n\r\n        function with_scope(s, cont) {\r\n                var _scope = scope;\r\n                scope = s;\r\n                var ret = cont();\r\n                ret.scope = s;\r\n                scope = _scope;\r\n                return ret;\r\n        };\r\n\r\n        function rmblock(block) {\r\n                if (block != null && block[0] == \"block\" && block[1]) {\r\n                        if (block[1].length == 1)\r\n                                block = block[1][0];\r\n                        else if (block[1].length == 0)\r\n                                block = [ \"block\" ];\r\n                }\r\n                return block;\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\";\r\n                body = with_scope(body.scope, function(){\r\n                        var ret = tighten(body, \"lambda\");\r\n                        if (!is_defun && name && !scope.references(name))\r\n                                name = null;\r\n                        return ret;\r\n                });\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        // this function does a few things:\r\n        // 1. discard useless blocks\r\n        // 2. join consecutive var declarations\r\n        // 3. remove obviously dead code\r\n        // 4. transform consecutive statements using the comma operator\r\n        // 5. if block_type == \"lambda\" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }\r\n        function tighten(statements, block_type) {\r\n                statements = MAP(statements, walk);\r\n\r\n                statements = statements.reduce(function(a, stat){\r\n                        if (stat[0] == \"block\") {\r\n                                if (stat[1]) {\r\n                                        a.push.apply(a, stat[1]);\r\n                                }\r\n                        } else {\r\n                                a.push(stat);\r\n                        }\r\n                        return a;\r\n                }, []);\r\n\r\n                statements = (function(a, prev){\r\n                        statements.forEach(function(cur){\r\n                                if (prev && ((cur[0] == \"var\" && prev[0] == \"var\") ||\r\n                                             (cur[0] == \"const\" && prev[0] == \"const\"))) {\r\n                                        prev[1] = prev[1].concat(cur[1]);\r\n                                } else {\r\n                                        a.push(cur);\r\n                                        prev = cur;\r\n                                }\r\n                        });\r\n                        return a;\r\n                })([]);\r\n\r\n                if (options.dead_code) statements = (function(a, has_quit){\r\n                        statements.forEach(function(st){\r\n                                if (has_quit) {\r\n                                        if (st[0] == \"function\" || st[0] == \"defun\") {\r\n                                                a.push(st);\r\n                                        }\r\n                                        else if (st[0] == \"var\" || st[0] == \"const\") {\r\n                                                if (!options.no_warnings)\r\n                                                        warn(\"Variables declared in unreachable code\");\r\n                                                st[1] = MAP(st[1], function(def){\r\n                                                        if (def[1] && !options.no_warnings)\r\n                                                                warn_unreachable([ \"assign\", true, [ \"name\", def[0] ], def[1] ]);\r\n                                                        return [ def[0] ];\r\n                                                });\r\n                                                a.push(st);\r\n                                        }\r\n                                        else if (!options.no_warnings)\r\n                                                warn_unreachable(st);\r\n                                }\r\n                                else {\r\n                                        a.push(st);\r\n                                        if (member(st[0], [ \"return\", \"throw\", \"break\", \"continue\" ]))\r\n                                                has_quit = true;\r\n                                }\r\n                        });\r\n                        return a;\r\n                })([]);\r\n\r\n                if (options.make_seqs) statements = (function(a, prev) {\r\n                        statements.forEach(function(cur){\r\n                                if (prev && prev[0] == \"stat\" && cur[0] == \"stat\") {\r\n                                        prev[1] = [ \"seq\", prev[1], cur[1] ];\r\n                                } else {\r\n                                        a.push(cur);\r\n                                        prev = cur;\r\n                                }\r\n                        });\r\n                        if (a.length >= 2\r\n                            && a[a.length-2][0] == \"stat\"\r\n                            && (a[a.length-1][0] == \"return\" || a[a.length-1][0] == \"throw\")\r\n                            && a[a.length-1][1])\r\n                        {\r\n                                a.splice(a.length - 2, 2,\r\n                                         [ a[a.length-1][0],\r\n                                           [ \"seq\", a[a.length-2][1], a[a.length-1][1] ]]);\r\n                        }\r\n                        return a;\r\n                })([]);\r\n\r\n                // this increases jQuery by 1K.  Probably not such a good idea after all..\r\n                // part of this is done in prepare_ifs anyway.\r\n                // if (block_type == \"lambda\") statements = (function(i, a, stat){\r\n                //         while (i < statements.length) {\r\n                //                 stat = statements[i++];\r\n                //                 if (stat[0] == \"if\" && !stat[3]) {\r\n                //                         if (stat[2][0] == \"return\" && stat[2][1] == null) {\r\n                //                                 a.push(make_if(negate(stat[1]), [ \"block\", statements.slice(i) ]));\r\n                //                                 break;\r\n                //                         }\r\n                //                         var last = last_stat(stat[2]);\r\n                //                         if (last[0] == \"return\" && last[1] == null) {\r\n                //                                 a.push(make_if(stat[1], [ \"block\", stat[2][1].slice(0, -1) ], [ \"block\", statements.slice(i) ]));\r\n                //                                 break;\r\n                //                         }\r\n                //                 }\r\n                //                 a.push(stat);\r\n                //         }\r\n                //         return a;\r\n                // })(0, []);\r\n\r\n                return statements;\r\n        };\r\n\r\n        function make_if(c, t, e) {\r\n                return when_constant(c, function(ast, val){\r\n                        if (val) {\r\n                                warn_unreachable(e);\r\n                                return t;\r\n                        } else {\r\n                                warn_unreachable(t);\r\n                                return e;\r\n                        }\r\n                }, function() {\r\n                        return make_real_if(c, t, e);\r\n                });\r\n        };\r\n\r\n        function make_real_if(c, t, e) {\r\n                c = walk(c);\r\n                t = walk(t);\r\n                e = walk(e);\r\n\r\n                if (empty(t)) {\r\n                        c = negate(c);\r\n                        t = e;\r\n                        e = null;\r\n                } else if (empty(e)) {\r\n                        e = null;\r\n                } else {\r\n                        // if we have both else and then, maybe it makes sense to switch them?\r\n                        (function(){\r\n                                var a = gen_code(c);\r\n                                var n = negate(c);\r\n                                var b = gen_code(n);\r\n                                if (b.length < a.length) {\r\n                                        var tmp = t;\r\n                                        t = e;\r\n                                        e = tmp;\r\n                                        c = n;\r\n                                }\r\n                        })();\r\n                }\r\n                if (empty(e) && empty(t))\r\n                        return [ \"stat\", c ];\r\n                var ret = [ \"if\", c, t, e ];\r\n                if (t[0] == \"if\" && empty(t[3]) && empty(e)) {\r\n                        ret = best_of(ret, walk([ \"if\", [ \"binary\", \"&&\", c, t[1] ], t[2] ]));\r\n                }\r\n                else if (t[0] == \"stat\") {\r\n                        if (e) {\r\n                                if (e[0] == \"stat\") {\r\n                                        ret = best_of(ret, [ \"stat\", make_conditional(c, t[1], e[1]) ]);\r\n                                }\r\n                        }\r\n                        else {\r\n                                ret = best_of(ret, [ \"stat\", make_conditional(c, t[1]) ]);\r\n                        }\r\n                }\r\n                else if (e && t[0] == e[0] && (t[0] == \"return\" || t[0] == \"throw\") && t[1] && e[1]) {\r\n                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);\r\n                }\r\n                else if (e && aborts(t)) {\r\n                        ret = [ [ \"if\", c, t ] ];\r\n                        if (e[0] == \"block\") {\r\n                                if (e[1]) ret = ret.concat(e[1]);\r\n                        }\r\n                        else {\r\n                                ret.push(e);\r\n                        }\r\n                        ret = walk([ \"block\", ret ]);\r\n                }\r\n                else if (t && aborts(e)) {\r\n                        ret = [ [ \"if\", negate(c), e ] ];\r\n                        if (t[0] == \"block\") {\r\n                                if (t[1]) ret = ret.concat(t[1]);\r\n                        } else {\r\n                                ret.push(t);\r\n                        }\r\n                        ret = walk([ \"block\", ret ]);\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        function _do_while(cond, body) {\r\n                return when_constant(cond, function(cond, val){\r\n                        if (!val) {\r\n                                warn_unreachable(body);\r\n                                return [ \"block\" ];\r\n                        } else {\r\n                                return [ \"for\", null, null, null, walk(body) ];\r\n                        }\r\n                });\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"sub\": function(expr, subscript) {\r\n                        if (subscript[0] == \"string\") {\r\n                                var name = subscript[1];\r\n                                if (is_identifier(name))\r\n                                        return [ \"dot\", walk(expr), name ];\r\n                                else if (/^[1-9][0-9]*$/.test(name) || name === \"0\")\r\n                                        return [ \"sub\", walk(expr), [ \"num\", parseInt(name, 10) ] ];\r\n                        }\r\n                },\r\n                \"if\": make_if,\r\n                \"toplevel\": function(body) {\r\n                        return [ \"toplevel\", with_scope(this.scope, function(){\r\n                                return tighten(body);\r\n                        }) ];\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        var last = body.length - 1;\r\n                        return [ \"switch\", walk(expr), MAP(body, function(branch, i){\r\n                                var block = tighten(branch[1]);\r\n                                if (i == last && block.length > 0) {\r\n                                        var node = block[block.length - 1];\r\n                                        if (node[0] == \"break\" && !node[1])\r\n                                                block.pop();\r\n                                }\r\n                                return [ branch[0] ? walk(branch[0]) : null, block ];\r\n                        }) ];\r\n                },\r\n                \"function\": _lambda,\r\n                \"defun\": _lambda,\r\n                \"block\": function(body) {\r\n                        if (body) return rmblock([ \"block\", tighten(body) ]);\r\n                },\r\n                \"binary\": function(op, left, right) {\r\n                        return when_constant([ \"binary\", op, walk(left), walk(right) ], function yes(c){\r\n                                return best_of(walk(c), this);\r\n                        }, function no() {\r\n                                return this;\r\n                        });\r\n                },\r\n                \"conditional\": function(c, t, e) {\r\n                        return make_conditional(walk(c), walk(t), walk(e));\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                \"try\",\r\n                                tighten(t),\r\n                                c != null ? [ c[0], tighten(c[1]) ] : null,\r\n                                f != null ? tighten(f) : null\r\n                        ];\r\n                },\r\n                \"unary-prefix\": function(op, expr) {\r\n                        expr = walk(expr);\r\n                        var ret = [ \"unary-prefix\", op, expr ];\r\n                        if (op == \"!\")\r\n                                ret = best_of(ret, negate(expr));\r\n                        return when_constant(ret, function(ast, val){\r\n                                return walk(ast); // it's either true or false, so minifies to !0 or !1\r\n                        }, function() { return ret });\r\n                },\r\n                \"name\": function(name) {\r\n                        switch (name) {\r\n                            case \"true\": return [ \"unary-prefix\", \"!\", [ \"num\", 0 ]];\r\n                            case \"false\": return [ \"unary-prefix\", \"!\", [ \"num\", 1 ]];\r\n                        }\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        if (ctor[0] == \"name\" && ctor[1] == \"Array\" && !scope.has(\"Array\")) {\r\n                                if (args.length != 1) {\r\n                                        return [ \"array\", args ];\r\n                                } else {\r\n                                        return [ \"call\", [ \"name\", \"Array\" ], args ];\r\n                                }\r\n                        }\r\n                },\r\n                \"call\": function(expr, args) {\r\n                        if (expr[0] == \"name\" && expr[1] == \"Array\" && args.length != 1 && !scope.has(\"Array\")) {\r\n                                return [ \"array\", args ];\r\n                        }\r\n                },\r\n                \"while\": _do_while\r\n        }, function() {\r\n                for (var i = 0; i < 2; ++i) {\r\n                        ast = prepare_ifs(ast);\r\n                        ast = ast_add_scope(ast);\r\n                        ast = walk(ast);\r\n                }\r\n                return ast;\r\n        });\r\n};\r\n\r\n/* -----[ re-generate code from the AST ]----- */\r\n\r\nvar DOT_CALL_NO_PARENS = /*jsp.*/array_to_hash([\r\n        \"name\",\r\n        \"array\",\r\n        \"object\",\r\n        \"string\",\r\n        \"dot\",\r\n        \"sub\",\r\n        \"call\",\r\n        \"regexp\"\r\n]);\r\n\r\nfunction make_string(str, ascii_only) {\r\n        var dq = 0, sq = 0;\r\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27\\u2028\\u2029]/g, function(s){\r\n                switch (s) {\r\n                    case \"\\\\\": return \"\\\\\\\\\";\r\n                    case \"\\b\": return \"\\\\b\";\r\n                    case \"\\f\": return \"\\\\f\";\r\n                    case \"\\n\": return \"\\\\n\";\r\n                    case \"\\r\": return \"\\\\r\";\r\n                    case \"\\t\": return \"\\\\t\";\r\n                    case \"\\u2028\": return \"\\\\u2028\";\r\n                    case \"\\u2029\": return \"\\\\u2029\";\r\n                    case '\"': ++dq; return '\"';\r\n                    case \"'\": ++sq; return \"'\";\r\n                }\r\n                return s;\r\n        });\r\n        if (ascii_only) str = to_ascii(str);\r\n        if (dq > sq) return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\r\n        else return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\r\n};\r\n\r\nfunction to_ascii(str) {\r\n        return str.replace(/[\\u0080-\\uffff]/g, function(ch) {\r\n                var code = ch.charCodeAt(0).toString(16);\r\n                while (code.length < 4) code = \"0\" + code;\r\n                return \"\\\\u\" + code;\r\n        });\r\n};\r\n\r\nvar SPLICE_NEEDS_BRACKETS = /*jsp.*/array_to_hash([ \"if\", \"while\", \"do\", \"for\", \"for-in\", \"with\" ]);\r\n\r\nfunction gen_code(ast, options) {\r\n        options = defaults(options, {\r\n                indent_start : 0,\r\n                indent_level : 4,\r\n                quote_keys   : false,\r\n                space_colon  : false,\r\n                beautify     : false,\r\n                ascii_only   : false,\r\n                inline_script: false\r\n        });\r\n        var beautify = !!options.beautify;\r\n        var indentation = 0,\r\n            newline = beautify ? \"\\n\" : \"\",\r\n            space = beautify ? \" \" : \"\";\r\n\r\n        function encode_string(str) {\r\n                var ret = make_string(str, options.ascii_only);\r\n                if (options.inline_script)\r\n                        ret = ret.replace(/<\\x2fscript([>/\\t\\n\\f\\r ])/gi, \"<\\\\/script$1\");\r\n                return ret;\r\n        };\r\n\r\n        function make_name(name) {\r\n                name = name.toString();\r\n                if (options.ascii_only)\r\n                        name = to_ascii(name);\r\n                return name;\r\n        };\r\n\r\n        function indent(line) {\r\n                if (line == null)\r\n                        line = \"\";\r\n                if (beautify)\r\n                        line = repeat_string(\" \", options.indent_start + indentation * options.indent_level) + line;\r\n                return line;\r\n        };\r\n\r\n        function with_indent(cont, incr) {\r\n                if (incr == null) incr = 1;\r\n                indentation += incr;\r\n                try { return cont.apply(null, slice(arguments, 1)); }\r\n                finally { indentation -= incr; }\r\n        };\r\n\r\n        function add_spaces(a) {\r\n                if (beautify)\r\n                        return a.join(\" \");\r\n                var b = [];\r\n                for (var i = 0; i < a.length; ++i) {\r\n                        var next = a[i + 1];\r\n                        b.push(a[i]);\r\n                        if (next &&\r\n                            ((/[a-z0-9_\\x24]$/i.test(a[i].toString()) && /^[a-z0-9_\\x24]/i.test(next.toString())) ||\r\n                             (/[\\+\\-]$/.test(a[i].toString()) && /^[\\+\\-]/.test(next.toString())))) {\r\n                                b.push(\" \");\r\n                        }\r\n                }\r\n                return b.join(\"\");\r\n        };\r\n\r\n        function add_commas(a) {\r\n                return a.join(\",\" + space);\r\n        };\r\n\r\n        function parenthesize(expr) {\r\n                var gen = make(expr);\r\n                for (var i = 1; i < arguments.length; ++i) {\r\n                        var el = arguments[i];\r\n                        if ((el instanceof Function && el(expr)) || expr[0] == el)\r\n                                return \"(\" + gen + \")\";\r\n                }\r\n                return gen;\r\n        };\r\n\r\n        function best_of(a) {\r\n                if (a.length == 1) {\r\n                        return a[0];\r\n                }\r\n                if (a.length == 2) {\r\n                        var b = a[1];\r\n                        a = a[0];\r\n                        return a.length <= b.length ? a : b;\r\n                }\r\n                return best_of([ a[0], best_of(a.slice(1)) ]);\r\n        };\r\n\r\n        function needs_parens(expr) {\r\n                if (expr[0] == \"function\" || expr[0] == \"object\") {\r\n                        // dot/call on a literal function requires the\r\n                        // function literal itself to be parenthesized\r\n                        // only if it's the first \"thing\" in a\r\n                        // statement.  This means that the parent is\r\n                        // \"stat\", but it could also be a \"seq\" and\r\n                        // we're the first in this \"seq\" and the\r\n                        // parent is \"stat\", and so on.  Messy stuff,\r\n                        // but it worths the trouble.\r\n                        var a = slice(w.stack()), self = a.pop(), p = a.pop();\r\n                        while (p) {\r\n                                if (p[0] == \"stat\") return true;\r\n                                if (((p[0] == \"seq\" || p[0] == \"call\" || p[0] == \"dot\" || p[0] == \"sub\" || p[0] == \"conditional\") && p[1] === self) ||\r\n                                    ((p[0] == \"binary\" || p[0] == \"assign\" || p[0] == \"unary-postfix\") && p[2] === self)) {\r\n                                        self = p;\r\n                                        p = a.pop();\r\n                                } else {\r\n                                        return false;\r\n                                }\r\n                        }\r\n                }\r\n                return !HOP(DOT_CALL_NO_PARENS, expr[0]);\r\n        };\r\n\r\n        function make_num(num) {\r\n                var str = num.toString(10), a = [ str.replace(/^0\\./, \".\") ], m;\r\n                if (Math.floor(num) === num) {\r\n                        a.push(\"0x\" + num.toString(16).toLowerCase(), // probably pointless\r\n                               \"0\" + num.toString(8)); // same.\r\n                        if ((m = /^(.*?)(0+)$/.exec(num))) {\r\n                                a.push(m[1] + \"e\" + m[2].length);\r\n                        }\r\n                } else if ((m = /^0?\\.(0+)(.*)$/.exec(num))) {\r\n                        a.push(m[2] + \"e-\" + (m[1].length + m[2].length),\r\n                               str.substr(str.indexOf(\".\")));\r\n                }\r\n                return best_of(a);\r\n        };\r\n\r\n        var w = ast_walker();\r\n        var make = w.walk;\r\n        return w.with_walkers({\r\n                \"string\": encode_string,\r\n                \"num\": make_num,\r\n                \"name\": make_name,\r\n                \"toplevel\": function(statements) {\r\n                        return make_block_statements(statements)\r\n                                .join(newline + newline);\r\n                },\r\n                \"splice\": function(statements) {\r\n                        var parent = w.parent();\r\n                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {\r\n                                // we need block brackets in this case\r\n                                return make_block.apply(this, arguments);\r\n                        } else {\r\n                                return MAP(make_block_statements(statements, true),\r\n                                           function(line, i) {\r\n                                                   // the first line is already indented\r\n                                                   return i > 0 ? indent(line) : line;\r\n                                           }).join(newline);\r\n                        }\r\n                },\r\n                \"block\": make_block,\r\n                \"var\": function(defs) {\r\n                        return \"var \" + add_commas(MAP(defs, make_1vardef)) + \";\";\r\n                },\r\n                \"const\": function(defs) {\r\n                        return \"const \" + add_commas(MAP(defs, make_1vardef)) + \";\";\r\n                },\r\n                \"try\": function(tr, ca, fi) {\r\n                        var out = [ \"try\", make_block(tr) ];\r\n                        if (ca) out.push(\"catch\", \"(\" + ca[0] + \")\", make_block(ca[1]));\r\n                        if (fi) out.push(\"finally\", make_block(fi));\r\n                        return add_spaces(out);\r\n                },\r\n                \"throw\": function(expr) {\r\n                        return add_spaces([ \"throw\", make(expr) ]) + \";\";\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        args = args.length > 0 ? \"(\" + add_commas(MAP(args, make)) + \")\" : \"\";\r\n                        return add_spaces([ \"new\", parenthesize(ctor, \"seq\", \"binary\", \"conditional\", \"assign\", function(expr){\r\n                                var w = ast_walker(), has_call = {};\r\n                                try {\r\n                                        w.with_walkers({\r\n                                                \"call\": function() { throw has_call },\r\n                                                \"function\": function() { return this }\r\n                                        }, function(){\r\n                                                w.walk(expr);\r\n                                        });\r\n                                } catch(ex) {\r\n                                        if (ex === has_call)\r\n                                                return true;\r\n                                        throw ex;\r\n                                }\r\n                        }) + args ]);\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        return add_spaces([ \"switch\", \"(\" + make(expr) + \")\", make_switch_block(body) ]);\r\n                },\r\n                \"break\": function(label) {\r\n                        var out = \"break\";\r\n                        if (label != null)\r\n                                out += \" \" + make_name(label);\r\n                        return out + \";\";\r\n                },\r\n                \"continue\": function(label) {\r\n                        var out = \"continue\";\r\n                        if (label != null)\r\n                                out += \" \" + make_name(label);\r\n                        return out + \";\";\r\n                },\r\n                \"conditional\": function(co, th, el) {\r\n                        return add_spaces([ parenthesize(co, \"assign\", \"seq\", \"conditional\"), \"?\",\r\n                                            parenthesize(th, \"seq\"), \":\",\r\n                                            parenthesize(el, \"seq\") ]);\r\n                },\r\n                \"assign\": function(op, lvalue, rvalue) {\r\n                        if (op && op !== true) op += \"=\";\r\n                        else op = \"=\";\r\n                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, \"seq\") ]);\r\n                },\r\n                \"dot\": function(expr) {\r\n                        var out = make(expr), i = 1;\r\n                        if (expr[0] == \"num\") {\r\n                                if (!/\\./.test(expr[1]))\r\n                                        out += \".\";\r\n                        } else if (needs_parens(expr))\r\n                                out = \"(\" + out + \")\";\r\n                        while (i < arguments.length)\r\n                                out += \".\" + make_name(arguments[i++]);\r\n                        return out;\r\n                },\r\n                \"call\": function(func, args) {\r\n                        var f = make(func);\r\n                        if (needs_parens(func))\r\n                                f = \"(\" + f + \")\";\r\n                        return f + \"(\" + add_commas(MAP(args, function(expr){\r\n                                return parenthesize(expr, \"seq\");\r\n                        })) + \")\";\r\n                },\r\n                \"function\": make_function,\r\n                \"defun\": make_function,\r\n                \"if\": function(co, th, el) {\r\n                        var out = [ \"if\", \"(\" + make(co) + \")\", el ? make_then(th) : make(th) ];\r\n                        if (el) {\r\n                                out.push(\"else\", make(el));\r\n                        }\r\n                        return add_spaces(out);\r\n                },\r\n                \"for\": function(init, cond, step, block) {\r\n                        var out = [ \"for\" ];\r\n                        init = (init != null ? make(init) : \"\").replace(/;*\\s*$/, \";\" + space);\r\n                        cond = (cond != null ? make(cond) : \"\").replace(/;*\\s*$/, \";\" + space);\r\n                        step = (step != null ? make(step) : \"\").replace(/;*\\s*$/, \"\");\r\n                        var args = init + cond + step;\r\n                        if (args == \"; ; \") args = \";;\";\r\n                        out.push(\"(\" + args + \")\", make(block));\r\n                        return add_spaces(out);\r\n                },\r\n                \"for-in\": function(vvar, key, hash, block) {\r\n                        return add_spaces([ \"for\", \"(\" +\r\n                                            (vvar ? make(vvar).replace(/;+$/, \"\") : make(key)),\r\n                                            \"in\",\r\n                                            make(hash) + \")\", make(block) ]);\r\n                },\r\n                \"while\": function(condition, block) {\r\n                        return add_spaces([ \"while\", \"(\" + make(condition) + \")\", make(block) ]);\r\n                },\r\n                \"do\": function(condition, block) {\r\n                        return add_spaces([ \"do\", make(block), \"while\", \"(\" + make(condition) + \")\" ]) + \";\";\r\n                },\r\n                \"return\": function(expr) {\r\n                        var out = [ \"return\" ];\r\n                        if (expr != null) out.push(make(expr));\r\n                        return add_spaces(out) + \";\";\r\n                },\r\n                \"binary\": function(operator, lvalue, rvalue) {\r\n                        var left = make(lvalue), right = make(rvalue);\r\n                        // XXX: I'm pretty sure other cases will bite here.\r\n                        //      we need to be smarter.\r\n                        //      adding parens all the time is the safest bet.\r\n                        if (member(lvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\r\n                            lvalue[0] == \"binary\" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]]) {\r\n                                left = \"(\" + left + \")\";\r\n                        }\r\n                        if (member(rvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\r\n                            rvalue[0] == \"binary\" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&\r\n                            !(rvalue[1] == operator && member(operator, [ \"&&\", \"||\", \"*\" ]))) {\r\n                                right = \"(\" + right + \")\";\r\n                        }\r\n                        else if (!beautify && options.inline_script && (operator == \"<\" || operator == \"<<\")\r\n                                 && rvalue[0] == \"regexp\" && /^script/i.test(rvalue[1])) {\r\n                                right = \" \" + right;\r\n                        }\r\n                        return add_spaces([ left, operator, right ]);\r\n                },\r\n                \"unary-prefix\": function(operator, expr) {\r\n                        var val = make(expr);\r\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-prefix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\r\n                                val = \"(\" + val + \")\";\r\n                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? \" \" : \"\") + val;\r\n                },\r\n                \"unary-postfix\": function(operator, expr) {\r\n                        var val = make(expr);\r\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-postfix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\r\n                                val = \"(\" + val + \")\";\r\n                        return val + operator;\r\n                },\r\n                \"sub\": function(expr, subscript) {\r\n                        var hash = make(expr);\r\n                        if (needs_parens(expr))\r\n                                hash = \"(\" + hash + \")\";\r\n                        return hash + \"[\" + make(subscript) + \"]\";\r\n                },\r\n                \"object\": function(props) {\r\n                        if (props.length == 0)\r\n                                return \"{}\";\r\n                        return \"{\" + newline + with_indent(function(){\r\n                                return MAP(props, function(p){\r\n                                        if (p.length == 3) {\r\n                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the\r\n                                                // body in p[1][3] and type (\"get\" / \"set\") in p[2].\r\n                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2]));\r\n                                        }\r\n                                        var key = p[0], val = parenthesize(p[1], \"seq\");\r\n                                        if (options.quote_keys) {\r\n                                                key = encode_string(key);\r\n                                        } else if ((typeof key == \"number\" || !beautify && +key + \"\" == key)\r\n                                                   && parseFloat(key) >= 0) {\r\n                                                key = make_num(+key);\r\n                                        } else if (!is_identifier(key)) {\r\n                                                key = encode_string(key);\r\n                                        }\r\n                                        return indent(add_spaces(beautify && options.space_colon\r\n                                                                 ? [ key, \":\", val ]\r\n                                                                 : [ key + \":\", val ]));\r\n                                }).join(\",\" + newline);\r\n                        }) + newline + indent(\"}\");\r\n                },\r\n                \"regexp\": function(rx, mods) {\r\n                        return \"/\" + rx + \"/\" + mods;\r\n                },\r\n                \"array\": function(elements) {\r\n                        if (elements.length == 0) return \"[]\";\r\n                        return add_spaces([ \"[\", add_commas(MAP(elements, function(el){\r\n                                if (!beautify && el[0] == \"atom\" && el[1] == \"undefined\") return \"\";\r\n                                return parenthesize(el, \"seq\");\r\n                        })), \"]\" ]);\r\n                },\r\n                \"stat\": function(stmt) {\r\n                        return make(stmt).replace(/;*\\s*$/, \";\");\r\n                },\r\n                \"seq\": function() {\r\n                        return add_commas(MAP(slice(arguments), make));\r\n                },\r\n                \"label\": function(name, block) {\r\n                        return add_spaces([ make_name(name), \":\", make(block) ]);\r\n                },\r\n                \"with\": function(expr, block) {\r\n                        return add_spaces([ \"with\", \"(\" + make(expr) + \")\", make(block) ]);\r\n                },\r\n                \"atom\": function(name) {\r\n                        return make_name(name);\r\n                }\r\n        }, function(){ return make(ast) });\r\n\r\n        // The squeezer replaces \"block\"-s that contain only a single\r\n        // statement with the statement itself; technically, the AST\r\n        // is correct, but this can create problems when we output an\r\n        // IF having an ELSE clause where the THEN clause ends in an\r\n        // IF *without* an ELSE block (then the outer ELSE would refer\r\n        // to the inner IF).  This function checks for this case and\r\n        // adds the block brackets if needed.\r\n        function make_then(th) {\r\n                if (th[0] == \"do\") {\r\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/57\r\n                        // IE croaks with \"syntax error\" on code like this:\r\n                        //     if (foo) do ... while(cond); else ...\r\n                        // we need block brackets around do/while\r\n                        return make_block([ th ]);\r\n                }\r\n                var b = th;\r\n                while (true) {\r\n                        var type = b[0];\r\n                        if (type == \"if\") {\r\n                                if (!b[3])\r\n                                        // no else, we must add the block\r\n                                        return make([ \"block\", [ th ]]);\r\n                                b = b[3];\r\n                        }\r\n                        else if (type == \"while\" || type == \"do\") b = b[2];\r\n                        else if (type == \"for\" || type == \"for-in\") b = b[4];\r\n                        else break;\r\n                }\r\n                return make(th);\r\n        };\r\n\r\n        function make_function(name, args, body, keyword) {\r\n                var out = keyword || \"function\";\r\n                if (name) {\r\n                        out += \" \" + make_name(name);\r\n                }\r\n                out += \"(\" + add_commas(MAP(args, make_name)) + \")\";\r\n                return add_spaces([ out, make_block(body) ]);\r\n        };\r\n\r\n        function must_has_semicolon(node) {\r\n                switch (node[0]) {\r\n                    case \"with\":\r\n                    case \"while\":\r\n                        return empty(node[2]); // `with' or `while' with empty body?\r\n                    case \"for\":\r\n                    case \"for-in\":\r\n                        return empty(node[4]); // `for' with empty body?\r\n                    case \"if\":\r\n                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'\r\n                        if (node[3]) {\r\n                                if (empty(node[3])) return true; // `else' present but empty\r\n                                return must_has_semicolon(node[3]); // dive into the `else' branch\r\n                        }\r\n                        return must_has_semicolon(node[2]); // dive into the `then' branch\r\n                }\r\n        };\r\n\r\n        function make_block_statements(statements, noindent) {\r\n                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {\r\n                        var stat = statements[i];\r\n                        var code = make(stat);\r\n                        if (code != \";\") {\r\n                                if (!beautify && i == last && !must_has_semicolon(stat)) {\r\n                                        code = code.replace(/;+\\s*$/, \"\");\r\n                                }\r\n                                a.push(code);\r\n                        }\r\n                }\r\n                return noindent ? a : MAP(a, indent);\r\n        };\r\n\r\n        function make_switch_block(body) {\r\n                var n = body.length;\r\n                if (n == 0) return \"{}\";\r\n                return \"{\" + newline + MAP(body, function(branch, i){\r\n                        var has_body = branch[1].length > 0, code = with_indent(function(){\r\n                                return indent(branch[0]\r\n                                              ? add_spaces([ \"case\", make(branch[0]) + \":\" ])\r\n                                              : \"default:\");\r\n                        }, 0.5) + (has_body ? newline + with_indent(function(){\r\n                                return make_block_statements(branch[1]).join(newline);\r\n                        }) : \"\");\r\n                        if (!beautify && has_body && i < n - 1)\r\n                                code += \";\";\r\n                        return code;\r\n                }).join(newline) + newline + indent(\"}\");\r\n        };\r\n\r\n        function make_block(statements) {\r\n                if (!statements) return \";\";\r\n                if (statements.length == 0) return \"{}\";\r\n                return \"{\" + newline + with_indent(function(){\r\n                        return make_block_statements(statements).join(newline);\r\n                }) + newline + indent(\"}\");\r\n        };\r\n\r\n        function make_1vardef(def) {\r\n                var name = def[0], val = def[1];\r\n                if (val != null)\r\n                        name = add_spaces([ make_name(name), \"=\", parenthesize(val, \"seq\") ]);\r\n                return name;\r\n        };\r\n\r\n};\r\n\r\nfunction split_lines(code, max_line_length) {\r\n        var splits = [ 0 ];\r\n        jsp.parse(function(){\r\n                var next_token = jsp.tokenizer(code);\r\n                var last_split = 0;\r\n                var prev_token;\r\n                function current_length(tok) {\r\n                        return tok.pos - last_split;\r\n                };\r\n                function split_here(tok) {\r\n                        last_split = tok.pos;\r\n                        splits.push(last_split);\r\n                };\r\n                function custom(){\r\n                        var tok = next_token.apply(this, arguments);\r\n                        out: {\r\n                                if (prev_token) {\r\n                                        if (prev_token.type == \"keyword\") break out;\r\n                                }\r\n                                if (current_length(tok) > max_line_length) {\r\n                                        switch (tok.type) {\r\n                                            case \"keyword\":\r\n                                            case \"atom\":\r\n                                            case \"name\":\r\n                                            case \"punc\":\r\n                                                split_here(tok);\r\n                                                break out;\r\n                                        }\r\n                                }\r\n                        }\r\n                        prev_token = tok;\r\n                        return tok;\r\n                };\r\n                custom.context = function() {\r\n                        return next_token.context.apply(this, arguments);\r\n                };\r\n                return custom;\r\n        }());\r\n        return splits.map(function(pos, i){\r\n                return code.substring(pos, splits[i + 1] || code.length);\r\n        }).join(\"\\n\");\r\n};\r\n\r\n/* -----[ Utilities ]----- */\r\n\r\nfunction repeat_string(str, i) {\r\n        if (i <= 0) return \"\";\r\n        if (i == 1) return str;\r\n        var d = repeat_string(str, i >> 1);\r\n        d += d;\r\n        if (i & 1) d += str;\r\n        return d;\r\n};\r\n\r\nfunction defaults(args, defs) {\r\n        var ret = {};\r\n        if (args === true)\r\n                args = {};\r\n        for (var i in defs) if (HOP(defs, i)) {\r\n                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\r\n        }\r\n        return ret;\r\n};\r\n\r\nfunction is_identifier(name) {\r\n        return /^[a-z_$][a-z0-9_$]*$/i.test(name)\r\n                && name != \"this\"\r\n                && !HOP(jsp.KEYWORDS_ATOM, name)\r\n                && !HOP(jsp.RESERVED_WORDS, name)\r\n                && !HOP(jsp.KEYWORDS, name);\r\n};\r\n\r\nfunction HOP(obj, prop) {\r\n        return Object.prototype.hasOwnProperty.call(obj, prop);\r\n};\r\n\r\n// some utilities\r\n\r\nvar MAP;\r\n\r\n(function(){\r\n        MAP = function(a, f, o) {\r\n                var ret = [], top = [], i;\r\n                function doit() {\r\n                        var val = f.call(o, a[i], i);\r\n                        if (val instanceof AtTop) {\r\n                                val = val.v;\r\n                                if (val instanceof Splice) {\r\n                                        top.push.apply(top, val.v);\r\n                                } else {\r\n                                        top.push(val);\r\n                                }\r\n                        }\r\n                        else if (val != skip) {\r\n                                if (val instanceof Splice) {\r\n                                        ret.push.apply(ret, val.v);\r\n                                } else {\r\n                                        ret.push(val);\r\n                                }\r\n                        }\r\n                };\r\n                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();\r\n                else for (i in a) if (HOP(a, i)) doit();\r\n                return top.concat(ret);\r\n        };\r\n        MAP.at_top = function(val) { return new AtTop(val) };\r\n        MAP.splice = function(val) { return new Splice(val) };\r\n        var skip = MAP.skip = {};\r\n        function AtTop(val) { this.v = val };\r\n        function Splice(val) { this.v = val };\r\n})();\r\n\r\n/* -----[ Exports ]----- */\r\n/*\r\nexports.ast_walker = ast_walker;\r\nexports.ast_mangle = ast_mangle;\r\nexports.ast_squeeze = ast_squeeze;\r\nexports.ast_lift_variables = ast_lift_variables;\r\nexports.gen_code = gen_code;\r\nexports.ast_add_scope = ast_add_scope;\r\nexports.set_logger = function(logger) { warn = logger };\r\nexports.make_string = make_string;\r\nexports.split_lines = split_lines;\r\nexports.MAP = MAP;\r\n\r\n// keep this last!\r\nexports.ast_squeeze_more = require(\"./squeeze-more\").ast_squeeze_more;\r\n*/\r\n\n/* @license\r\n\r\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\n  Copyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial\r\n                     and working import implementation.\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions\r\n  are met:\r\n\r\n      * Redistributions of source code must retain the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer.\r\n\r\n      * Redistributions in binary form must reproduce the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer in the documentation and/or other materials\r\n        provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n  SUCH DAMAGE.\r\n*/\r\n\r\n\r\n/*\r\n * Misc classes for importing files.\r\n *\r\n * Currently the file contains a lot of unused code for future\r\n * purposes. Most of it can be rewritten as there is now Javascript parser\r\n * available.\r\n *\r\n * Exports:\r\n *\r\n * - getUrlContents(url) -- get URL contents. Returns contents or false in\r\n *   error.\r\n *\r\n * - Some other stuff not currently used/needed.\r\n *\r\n *\r\n */\r\n(function() {\r\n\r\nfunction parseQML(file) {\r\n    var contents = getUrlContents(file + \".js\");\r\n    if (contents) {\r\n        console.log(\"Using pre-processed content for \" + file);\r\n        return new Function(\"return \" + contents)();\r\n    } else {\r\n        contents = getUrlContents(file);\r\n        if (contents) {\r\n            // todo: use parser/compiler here\r\n            console.log(\"todo: add parser to import.js \" + file);\r\n        } else {\r\n            console.log(\"warn: Fetch failed for \" + file);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Get URL contents. EXPORTED.\r\n * @param url {String} Url to fetch.\r\n * @param skipExceptions {bool} when turned on, ignore exeptions and return false. This feature is used by readQmlDir.\r\n * @private\r\n * @return {mixed} String of contents or false in errors.\r\n *\r\n * Q1: can someone provide use-case when we need caching here?\r\n * A1:\r\n * Q2: should errors be cached? (now they aren't)\r\n * A2:\r\n \r\n * Q3: split getUrlContents into: getUrlContents, getUrlContentsWithCaching, getUrlContentsWithoutErrors..\r\n */\r\ngetUrlContents = function (url, skipExceptions) {\r\n    if (typeof urlContentCache[url] == 'undefined') {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", url, false);\r\n\r\n      if (skipExceptions)\r\n        { try { xhr.send(null); } catch (e) { return false; } } /* it is OK to not have logging here, because DeveloperTools already will have red log record */\r\n      else\r\n        xhr.send(null);\r\n\r\n      if (xhr.status != 200 && xhr.status != 0) { // 0 if accessing with file://\r\n          console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\r\n          return false;\r\n      }\r\n      urlContentCache[url] = xhr.responseText;\r\n    }\r\n    return urlContentCache[url];\r\n}\r\nif (typeof global.urlContentCache == 'undefined')\r\n  global.urlContentCache = {};\r\n\r\n/**\r\n * Read qmldir spec file at directory. EXPORTED.\r\n * @param url Url of the directory\r\n * @return {Object} Object, where .internals lists qmldir internal references\r\n *                          and .externals lists qmldir external references.\r\n */\r\n\r\n/*  Note on how importing works.\r\n\r\n   * parseQML gives us `tree.$imports` variable, which contains information from `import` statements.\r\n\r\n   * After each call to parseQML, we call engine.loadImports(tree.$imports).\r\n     It in turn invokes readQmlDir() calls for each import, with respect to current component base path and engine.importPathList().\r\n\r\n   * We keep all component names from all qmldir files in global variable `engine.qmldir`.\r\n   \r\n   * In construct() function, we use `engine.qmldir` for component url lookup.\r\n\r\n   Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html \r\n   Also please look at notes and TODO's in qtcore.js::loadImports() and qtcore.js::construct() methods.\r\n*/\r\n \r\nreadQmlDir = function (url) {\r\n    // in case 'url' is empty, do not attach \"/\"\r\n    // Q1: when this happen?\r\n    var qmldirFileUrl = url.length > 0 ? (url + \"/qmldir\") : \"qmldir\";\r\n\r\n    var qmldir = getUrlContents( qmldirFileUrl, true), // loading url contents with skipping errors\r\n        lines,\r\n        line,\r\n        internals = {},\r\n        externals = {},\r\n        match,\r\n        i;\r\n\r\n    if (qmldir === false) {\r\n        return false;\r\n    }\r\n\r\n    // we have to check for \"://\" \r\n    // In that case, item path is meant to be absolute, and we have no need to prefix it with base url\r\n    function makeurl( path ) {\r\n       if (path.indexOf(\"://\") > 0) return path;\r\n       return url + \"/\" + path;\r\n    }\r\n\r\n    lines = qmldir.split(/\\r?\\n/);\r\n    for (i = 0; i < lines.length; i++) {\r\n        // trim\r\n        line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\r\n        if (!line.length || line[0] == \"#\") {\r\n            // Empty line or comment\r\n            continue;\r\n        }\r\n        match = line.split(/\\s+/);\r\n        if (match.length == 2 || match.length == 3) {\r\n            if (match[0] == \"plugin\") {\r\n                console.log(url + \": qmldir plugins are not supported!\");\r\n            } else if (match[0] == \"internal\") {\r\n                internals[match[1]] = { url: makeurl( match[2] ) };\r\n            } else {\r\n                if (match.length == 2) {\r\n                    externals[match[0]] = { url: makeurl( match[1] ) };\r\n                } else {\r\n                    externals[match[0]] = { url: makeurl( match[2] ), version: match[1] };\r\n                }\r\n            }\r\n        } else {\r\n            console.log(url + \": unmatched: \" + line);\r\n        }\r\n    }\r\n    return {internals: internals, externals: externals};\r\n}\r\n\r\n\r\n/**\r\n * Import and parse javascript file. EXPORTED.\r\n * @return {object} Object which has \"var\"s and functions from file as keys, or\r\n *         undefined if operation fails\r\n */\r\nimportJs = function (filename) {\r\n\r\n    // todo: .pragma support\r\n\r\n    // Exports as follow:\r\n    // function a() { function b() {} } exports only a.\r\n    // var a = function b(){} exports a and b. Not sure if b should be exported.\r\n    //                        rare case, however.\r\n    // var a = function(){} exports only a.\r\n\r\n    var i,\r\n        src = getUrlContents(filename),\r\n        exports = [];\r\n\r\n    if (src === false) {\r\n        return;\r\n    }\r\n\r\n    // Analyse source\r\n    exports = readExports(src);\r\n    console.log(filename + \" exports:\", exports);\r\n\r\n    // Wrap source to function to retain private scope of the variables.\r\n    // Make that function return an object.\r\n    // That object contains getters and setters for exported stuff.\r\n    // Add () to execute the function.\r\n    src += \";return {\";\r\n    for (i = 0; i < exports.length; i++) {\r\n        // create getters and setters for properties\r\n        // keeps variables synced better\r\n        src += \"get \" + exports[i] + \"(){return \" + exports[i] + \"},\";\r\n        src += \"set \" + exports[i] + \"(){\" + exports[i] + \" = arguments[0]},\";\r\n        // without getters and setters:\r\n        // src += exports[i] + \":\" + exports[i] + \",\";\r\n    }\r\n    src += \"}\";\r\n\r\n    // evaluate source to get the object.\r\n    return new Function(src)();\r\n}\r\n\r\n/**\r\n * Read code for variables and functions which are exported to qml\r\n * @private\r\n * @param src source code\r\n * @return Array Array of local variable names to export\r\n */\r\nfunction readExports(src) {\r\n\r\n    // Eat src until str is found. Recurse if recursive set.\r\n    function eatUntil(src, str, recursive) {\r\n        var i;\r\n        if (!recursive) {\r\n            i = src.indexOf(str);\r\n            if (i == -1) {\r\n                console.log(\"eof encountered, \" + str + \" expected.\");\r\n                return \"\";\r\n            }\r\n        } else {\r\n            i = 0;\r\n            while (i < src.length) {\r\n                if (src.substr(i, str.length) == str) {\r\n                    break;\r\n                }\r\n                switch(src[i]) {\r\n                 case \"{\": // inner block\r\n                    src = eatUntil(src.substr(i + 1), \"}\", true );\r\n                    i = 0;\r\n                    break;\r\n                 case \"(\": // Parentheses\r\n                    src = eatUntil(src.substr(i + 1), \")\", true );\r\n                    i = 0;\r\n                    break;\r\n                 case \"/\": // Possible beginning of comment\r\n                    if (src[i + 1] == \"/\") {\r\n                        src = eatUntil(src.substr(i + 1), \"\\n\");\r\n                        i = 0;\r\n                    } else if (src[i + 1] == \"*\") {\r\n                        src = eatUntil(src.substr(i + 1), \"*/\");\r\n                        i = 0;\r\n                    } else {\r\n                        i++;\r\n                    }\r\n                    break;\r\n                 default:\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return src.substr(i + str.length);\r\n    }\r\n\r\n    // Strip comments and code blocks from the input source\r\n    // This is quite similar with eatCodeBlock but still a bit different.\r\n    // If either section has bugs, check the other section, too!\r\n    var i = 0,\r\n        // Code without blocks and comments\r\n        semi = \"\",\r\n        // todo: these doesn't match with exports containing \"$\"\r\n        matcher = /var\\s+\\w+|function\\s+\\w+/g,\r\n        matches,\r\n        tmp,\r\n        exports = [];\r\n\r\n    while (i < src.length) {\r\n        switch (src[i]) {\r\n         case \"{\": // code block\r\n            src = eatUntil(src.substr(i + 1), \"}\", true);\r\n            i = 0;\r\n            break;\r\n         case \"(\": // parentheses\r\n            src = eatUntil(src.substr(i + 1), \")\", true);\r\n            i = 0;\r\n            break;\r\n         case \"/\": // comment\r\n            if (src[i + 1] == \"/\") {\r\n                src = eatUntil(src.substr(i + 1), \"\\n\");\r\n                i = 0;\r\n            } else if (src[i + 1] == \"*\") {\r\n                src = eatUntil(src.substr(i + 1), \"*/\");\r\n                i = 0;\r\n            } else {\r\n                semi += src[i];\r\n                i++;\r\n            }\r\n            break;\r\n        default:\r\n            semi += src[i];\r\n            i++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Search exports from semi\r\n    matches = semi.match(matcher);\r\n\r\n    // matches now contain strings defined in matcher. Re-match these to get\r\n    // exports. Matching can be done in one step, but I couldn't get it working\r\n    // so bear this extra step.\r\n    for (i = 0; i < matches.length; i++) {\r\n        tmp = /\\w+\\s+(\\w+)/.exec(matches[i]);\r\n        if (tmp) {\r\n            exports.push(tmp[1]);\r\n        }\r\n    }\r\n    return exports;\r\n}\r\n\r\n})();\r\n\nglobal.Easing = {\r\n  Linear: 1,\r\n  InQuad: 2,          OutQuad: 3,     InOutQuad: 4,           OutInQuad: 5,\r\n  InCubic: 6,         OutCubic: 7,    InOutCubic: 8,          OutInCubic: 9,\r\n  InQuart: 10,        OutQuart: 11,   InOutQuart: 12,         OutInQuart: 13,\r\n  InQuint: 14,        OutQuint: 15,   InOutQuint: 16,         OutInQuint: 17,\r\n  InSine: 18,         OutSine: 19,    InOutSine: 20,          OutInSine: 21,\r\n  InExpo: 22,         OutExpo: 23,    InOutExpo: 24,          OutInExpo: 25,\r\n  InCirc: 26,         OutCirc: 27,    InOutCirc: 28,          OutInCirc: 29,\r\n  InElastic: 30,      OutElastic: 31, InOutElastic: 32,       OutInElastic: 33,\r\n  InBack: 34,         OutBack: 35,    InOutBack: 36,          OutInBack: 37,\r\n  InBounce: 38,       OutBounce: 39,  InOutBounce: 40,        OutInBounce: 41\r\n}\r\n\nglobal.Font = {\r\n  // Capitalization\r\n  MixedCase: \"none\",\r\n  AllUppercase: \"uppercase\",\r\n  AllLowercase: \"lowercase\",\r\n  SmallCaps: \"smallcaps\",\r\n  Capitalize: \"capitalize\",\r\n  // Weight\r\n  Light: \"lighter\",\r\n  Normal: \"normal\",\r\n  DemiBold: \"600\",\r\n  Bold: \"bold\",\r\n  Black: \"bolder\",\r\n}\r\n\nglobal.qrc = {\r\n  includesFile: function(path) {\r\n    return typeof qrc[path] != 'undefined';\r\n  }\r\n};\r\n\nglobal.Qt = {\r\n  rgba: function(r,g,b,a) {\r\n    return \"rgba(\"\r\n      + Math.round(r * 255) + \",\"\r\n      + Math.round(g * 255) + \",\"\r\n      + Math.round(b * 255) + \",\"\r\n      + a + \")\";\r\n  },\r\n  openUrlExternally: function(url) {\r\n    page = window.open(url, '_blank');\r\n    page.focus();\r\n  },\r\n  // Load file, parse and construct as Component (.qml)\r\n  //FIXME: remove the parameter executionContext and get it autonomously.\r\n  createComponent: function(name, executionContext) {\r\n    if (name in engine.components)\r\n        return engine.components[name];\r\n\r\n    var nameIsUrl = name.indexOf(\"//\") >= 0 || name.indexOf(\":/\") >= 0; // e.g. // in protocol, or :/ in disk urls (D:/)\r\n\r\n    // Do not perform path lookups if name starts with @ sign.\r\n    // This is used when we load components from qmldir files\r\n    // because in that case we do not need any lookups.\r\n    if (name.length > 0 && name[0] == \"@\") {\r\n      nameIsUrl = true;\r\n      name = name.substr( 1,name.length-1 );\r\n    }\r\n\r\n    var file = nameIsUrl ? name : engine.$basePath + name;\r\n\r\n    var src = getUrlContents(file, true);\r\n    // if failed to load, and provided name is not direct url, try to load from dirs in importPathList()\r\n    if (src==false && !nameIsUrl) {\r\n      var moredirs = engine.importPathList();\r\n\r\n      for (var i=0; i<moredirs.length; i++) {\r\n        file = moredirs[i] + name;\r\n        src = getUrlContents(file, true);\r\n        if (src !== false) break;\r\n      }\r\n    }\r\n\r\n    // When createComponent failed to load content from all probable sources, it should return undefined.\r\n    if (src === false)\r\n      return undefined;\r\n\r\n    var tree = parseQML(src);\r\n\r\n    if (tree.$children.length !== 1)\r\n        console.error(\"A QML component must only contain one root element!\");\r\n\r\n    var component = new QMLComponent({ object: tree, context: executionContext });\r\n    component.$basePath = engine.extractBasePath( file );\r\n    component.$imports = tree.$imports;\r\n    component.$file = file; // just for debugging\r\n\r\n    engine.loadImports( tree.$imports,component.$basePath );\r\n\r\n    engine.components[name] = component;\r\n    return component;\r\n  },\r\n\r\n    // Returns url resolved relative to the URL of the caller.\r\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\r\n  resolvedUrl: function(url)\r\n  {\r\n    if (!url || !url.substr) // url is not a string object\r\n      return url;\r\n\r\n    // Must check for cases: D:/, file://, http://, or slash at the beginning. \r\n    // This means the url is absolute => we have to skip processing (except removing dot segments).\r\n    if (url == \"\" || url.indexOf(\":/\") != -1 || url.indexOf(\"/\") == 0)\r\n      return engine.removeDotSegments( url );\r\n\r\n    // we have $basePath variable placed in context of \"current\" document\r\n    // this is done in construct() function\r\n\r\n    // let's go to the callers and inspect their arguments\r\n    // The 2-nd argument of the callers we hope is context object\r\n    // e.g. see calling signature of bindings and signals\r\n\r\n    // Actually Qt cpp code is doing the same; the difference is that they know calling context\r\n    // https://qt.gitorious.org/qt/qtdeclarative/source/eeaba26596d447c531dfac9d6e6bf5cfe4537813:src/qml/qml/v8/qqmlbuiltinfunctions.cpp#L833\r\n\r\n    var detectedBasePath = \"\";\r\n    var currentCaller = Qt.resolvedUrl.caller;\r\n    var maxcount = 10;\r\n    while (maxcount-- > 0 && currentCaller) {\r\n      if (currentCaller.arguments[1] && currentCaller.arguments[1][\"$basePath\"])\r\n      {\r\n        detectedBasePath = currentCaller.arguments[1][\"$basePath\"];\r\n        break;\r\n      }\r\n      currentCaller = currentCaller.caller;\r\n    }\r\n\r\n    return engine.removeDotSegments( detectedBasePath + url )\r\n  },\r\n\r\n  // Buttons masks\r\n  LeftButton: 1,\r\n  RightButton: 2,\r\n  MiddleButton: 4,\r\n  // Modifiers masks\r\n  NoModifier: 0,\r\n  ShiftModifier: 1,\r\n  ControlModifier: 2,\r\n  AltModifier: 4,\r\n  MetaModifier: 8,\r\n  KeypadModifier: 16, // Note: Not available in web\r\n  // Layout directions\r\n  LeftToRight: 0,\r\n  RightToLeft: 1,\r\n  // Orientations\r\n  Vertical: 0,\r\n  Horizontal: 1,\r\n  // Keys\r\n  Key_Escape: 27,\r\n  Key_Tab: 9,\r\n  Key_Backtab: 245,\r\n  Key_Backspace: 8,\r\n  Key_Return: 13,\r\n  Key_Enter: 13,\r\n  Key_Insert: 45,\r\n  Key_Delete: 46,\r\n  Key_Pause: 19,\r\n  Key_Print: 42,\r\n  Key_SysReq: 0,\r\n  Key_Clear: 12,\r\n  Key_Home: 36,\r\n  Key_End: 35,\r\n  Key_Left: 37,\r\n  Key_Up: 38,\r\n  Key_Right: 39,\r\n  Key_Down: 40,\r\n  Key_PageUp: 33,\r\n  Key_PageDown: 34,\r\n  Key_Shift: 16,\r\n  Key_Control: 17,\r\n  Key_Meta: 91,\r\n  Key_Alt: 18,\r\n  Key_AltGr: 0,\r\n  Key_CapsLock: 20,\r\n  Key_NumLock: 144,\r\n  Key_ScrollLock: 145,\r\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117, Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122, Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127, Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132, Key_F22: 133, Key_F23: 134, Key_F24: 135, Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0, Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\r\n  Key_Super_L: 0,\r\n  Key_Super_R: 0,\r\n  Key_Menu: 0,\r\n  Key_Hyper_L: 0,\r\n  Key_Hyper_R: 0,\r\n  Key_Help: 6,\r\n  Key_Direction_L: 0,\r\n  Key_Direction_R: 0,\r\n  Key_Space: 32,\r\n  Key_Any:   32,\r\n  Key_Exclam: 161,\r\n  Key_QuoteDbl: 162,\r\n  Key_NumberSign: 163,\r\n  Key_Dollar: 164,\r\n  Key_Percent: 165,\r\n  Key_Ampersant: 166,\r\n  Key_Apostrophe: 222,\r\n  Key_ParenLeft: 168,\r\n  Key_ParenRight: 169,\r\n  Key_Asterisk: 170,\r\n  Key_Plus: 171,\r\n  Key_Comma: 188,\r\n  Key_Minus: 173,\r\n  Key_Period: 190,\r\n  Key_Slash: 191,\r\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52, Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\r\n  Key_Colon: 58,\r\n  Key_Semicolon: 59,\r\n  Key_Less: 60,\r\n  Key_Equal: 61,\r\n  Key_Greater: 62,\r\n  Key_Question: 63,\r\n  Key_At: 64,\r\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71, Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78, Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85, Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\r\n  Key_BracketLeft: 219,\r\n  Key_Backslash: 220,\r\n  Key_BracketRight: 221,\r\n  Key_AsciiCircum: 160,\r\n  Key_Underscore: 167,\r\n  Key_QuoteLeft: 0,\r\n  Key_BraceLeft: 174,\r\n  Key_Bar: 172,\r\n  Key_BraceRight: 175,\r\n  Key_AsciiTilde: 176,\r\n  Key_Back: 0,\r\n  Key_Forward: 0,\r\n  Key_Stop: 0,\r\n  Key_VolumeDown: 182,\r\n  Key_VolumeUp: 183,\r\n  Key_VolumeMute: 181,\r\n  Key_Yes: 0,\r\n  Key_multiply: 106,\r\n  Key_add: 107,\r\n  Key_substract: 109,\r\n  Key_divide: 111,\r\n  Key_News: 0,\r\n  Key_OfficeHome: 0,\r\n  Key_Option: 0,\r\n  Key_Paste: 0,\r\n  Key_Phone: 0,\r\n  Key_Calendar: 0,\r\n  Key_Reply: 0,\r\n  Key_Reload: 0,\r\n  Key_RotateWindows: 0,\r\n  Key_RotationPB: 0,\r\n  Key_RotationKB: 0,\r\n  Key_Save: 0,\r\n  Key_Send: 0,\r\n  Key_Spell: 0,\r\n  Key_SplitScreen: 0,\r\n  Key_Support: 0,\r\n  Key_TaskPane: 0,\r\n  Key_Terminal: 0,\r\n  Key_Tools: 0,\r\n  Key_Travel: 0,\r\n  Key_Video: 0,\r\n  Key_Word: 0,\r\n  Key_Xfer: 0,\r\n  Key_ZoomIn: 0,\r\n  Key_ZoomOut: 0,\r\n  Key_Away: 0,\r\n  Key_Messenger: 0,\r\n  Key_WebCam: 0,\r\n  Key_MailForward: 0,\r\n  Key_Pictures: 0,\r\n  Key_Music: 0,\r\n  Key_Battery: 0,\r\n  Key_Bluetooth: 0,\r\n  Key_WLAN: 0,\r\n  Key_UWB: 0,\r\n  Key_AudioForward: 0,\r\n  Key_AudioRepeat: 0,\r\n  Key_AudioRandomPlay: 0,\r\n  Key_Subtitle: 0,\r\n  Key_AudioCycleTrack: 0,\r\n  Key_Time: 0,\r\n  Key_Hibernate: 0,\r\n  Key_View: 0,\r\n  Key_TopMenu: 0,\r\n  Key_PowerDown: 0,\r\n  Key_Suspend: 0,\r\n  Key_ContrastAdjust: 0,\r\n  Key_MediaLast: 0,\r\n  Key_unknown: -1,\r\n  Key_Call: 0,\r\n  Key_Camera: 0,\r\n  Key_CameraFocus: 0,\r\n  Key_Context1: 0,\r\n  Key_Context2: 0,\r\n  Key_Context3: 0,\r\n  Key_Context4: 0,\r\n  Key_Flip: 0,\r\n  Key_Hangup: 0,\r\n  Key_No: 0,\r\n  Key_Select: 93,\r\n  Key_Yes: 0,\r\n  Key_ToggleCallHangup: 0,\r\n  Key_VoiceDial: 0,\r\n  Key_LastNumberRedial: 0,\r\n  Key_Execute: 43,\r\n  Key_Printer: 42,\r\n  Key_Play: 250,\r\n  Key_Sleep: 95,\r\n  Key_Zoom: 251,\r\n  Key_Cancel: 3\r\n}\r\n\n/**\r\n * Creates and returns a signal with the parameters specified in @p params.\r\n *\r\n * @param params Array with the parameters of the signal. Each element has to be\r\n *               an object with the two properties \"type\" and \"name\" specifying\r\n *               the datatype of the parameter and its name. The type is\r\n *               currently ignored.\r\n * @param options Options that allow finetuning of the signal.\r\n */\r\nglobal.Signal = function Signal(params, options) {\r\n    options = options || {};\r\n    var connectedSlots = [];\r\n    var obj = options.obj\r\n\r\n    var signal = function() {\r\n        for (var i in connectedSlots)\r\n            try {\r\n                connectedSlots[i].slot.apply(connectedSlots[i].thisObj, arguments);\r\n            } catch(err) {\r\n                console.log(err.message);\r\n            }\r\n    };\r\n    signal.parameters = params || [];\r\n    signal.connect = function() {\r\n        if (arguments.length == 1)\r\n            connectedSlots.push({thisObj: global, slot: arguments[0]});\r\n        else if (typeof arguments[1] == 'string' || arguments[1] instanceof String) {\r\n            if (arguments[0].$tidyupList && arguments[0] !== obj)\r\n                arguments[0].$tidyupList.push(this);\r\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[0][arguments[1]]});\r\n        } else {\r\n            if (arguments[0].$tidyupList && (!obj || (arguments[0] !== obj && arguments[0] !== obj.$parent)))\r\n                arguments[0].$tidyupList.push(this);\r\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[1]});\r\n        }\r\n\r\n        // Notify object of connect\r\n        if (options.obj && options.obj.$connectNotify) {\r\n            options.obj.$connectNotify(options);\r\n        }\r\n\r\n    }\r\n    signal.disconnect = function() {\r\n        var callType = arguments.length == 1 ? (arguments[0] instanceof Function ? 1 : 2)\r\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 3 : 4;\r\n        for (var i = 0; i < connectedSlots.length; i++) {\r\n            var item = connectedSlots[i];\r\n            if ((callType == 1 && item.slot == arguments[0])\r\n                || (callType == 2 && item.thisObj == arguments[0])\r\n                || (callType == 3 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\r\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\r\n            ) {\r\n                if (item.thisObj)\r\n                    item.thisObj.$tidyupList.splice(item.thisObj.$tidyupList.indexOf(this), 1);\r\n                connectedSlots.splice(i, 1);\r\n                i--; // We have removed an item from the list so the indexes shifted one backwards\r\n            }\r\n        }\r\n\r\n        // Notify object of disconnect\r\n        if (options.obj && options.obj.$disconnectNotify) {\r\n            options.obj.$disconnectNotify(options);\r\n        }\r\n    }\r\n    signal.isConnected = function() {\r\n        var callType = arguments.length == 1 ? 1\r\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 2 : 3;\r\n        for (var i in connectedSlots) {\r\n            var item = connectedSlots[i];\r\n            if ((callType == 1 && item.slot == arguments[0])\r\n                || (callType == 2 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\r\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\r\n            )\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    return signal;\r\n}\r\n\r\n\nvar GETTER = \"__defineGetter__\",\r\n    SETTER = \"__defineSetter__\",\r\n    // Property that is currently beeing evaluated. Used to get the information\r\n    // which property called the getter of a certain other property for\r\n    // evaluation and is thus dependant on it.\r\n    evaluatingProperty = undefined,\r\n    // All object constructors\r\n    constructors = {\r\n      int:         QMLInteger,\r\n      real:        Number,\r\n      double:      Number,\r\n      string:      String,\r\n      bool:        Boolean,\r\n      list:        QMLList,\r\n      color:       QMLColor,\r\n      enum:        Number,\r\n      url:         String,\r\n      variant:     QMLVariant,\r\n      'var':       QMLVariant,\r\n      QMLDocument: QMLComponent\r\n    };\r\nvar modules = {\r\n    Main: constructors\r\n  };\r\n\r\n// Helper. Adds a type to the constructor list\r\nglobal.registerGlobalQmlType = function (name, type) {\r\n  global[type.name]  = type;\r\n  constructors[name] = type;\r\n  modules.Main[name] = type;\r\n};\r\n\r\n// Helper. Register a type to a module\r\nglobal.registerQmlType = function(options) {\r\n  if (typeof options != 'object') {\r\n    registerGlobalQmlType(arguments[0], arguments[1]);\r\n  } else {\r\n    var moduleDescriptor = {\r\n      name:        options.name,\r\n      versions:    options.versions,\r\n      constructor: options.constructor\r\n    };\r\n\r\n    if (typeof modules[options.module] == 'undefined')\r\n      modules[options.module] = [];\r\n    modules[options.module].push(moduleDescriptor);\r\n\r\n    if (typeof options.baseClass !== 'undefined') {\r\n      inherit(options.constructor, options.baseClass);\r\n    }\r\n  }\r\n};\r\n\r\nglobal.getConstructor = function (moduleName, version, name) {\r\n  if (typeof modules[moduleName] != 'undefined') {\r\n    for (var i = 0 ; i < modules[moduleName].length ; ++i) {\r\n      var type = modules[moduleName][i];\r\n\r\n      if (type.name == name && type.versions.test(version))\r\n        return type.constructor;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nglobal.collectConstructorsForModule = function (moduleName, version) {\r\n  var constructors = {};\r\n\r\n  if (typeof modules[moduleName] == 'undefined') {\r\n    console.warn(\"module `\" + moduleName + \"` not found\");\r\n    return constructors;\r\n  }\r\n  for (var i = 0 ; i < modules[moduleName].length ; ++i) {\r\n    var module = modules[moduleName][i];\r\n\r\n    if (module.versions.test(version)) {\r\n      constructors[module.name] = module.constructor;\r\n    }\r\n  }\r\n  return constructors;\r\n};\r\n\r\nglobal.mergeObjects = function (obj1, obj2) {\r\n  var mergedObject = {};\r\n\r\n  if (typeof obj1 != 'undefined' && obj1 != null) {\r\n    for (var key in obj1) { mergedObject[key] = obj1[key]; }\r\n  }\r\n  if (typeof obj2 != 'undefined' && obj2 != null) {\r\n    for (var key in obj2) { mergedObject[key] = obj2[key]; }\r\n  }\r\n  return mergedObject;\r\n}\r\n\r\nglobal.perContextConstructors = {};\r\n\r\nglobal.loadImports = function (self, imports) {\r\n  constructors = mergeObjects(modules.Main, null);\r\n  for (var i = 0 ; i < imports.length ; ++i) {\r\n    var moduleName = imports[i][1],\r\n        moduleVersion = imports[i][2],\r\n        moduleAlias = imports[i][3],\r\n        moduleConstructors = collectConstructorsForModule(moduleName, moduleVersion);\r\n\r\n    if (moduleAlias !== \"\")\r\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\r\n    else\r\n      constructors = mergeObjects(constructors, moduleConstructors);\r\n  }\r\n  perContextConstructors[self.objectId] = constructors;\r\n}\r\n\r\nglobal.inherit = function(constructor, baseClass) {\r\n  var oldProto = constructor.prototype;\r\n  constructor.prototype = Object.create(baseClass.prototype);\r\n  Object.keys(oldProto).forEach(function(prop) {\r\n    constructor.prototype[prop] = oldProto[prop];\r\n  });\r\n  constructor.prototype.constructor = baseClass;\r\n}\r\n\r\n/**\r\n * QML Object constructor.\r\n * @param {Object} meta Meta information about the object and the creation context\r\n * @return {Object} New qml object\r\n */\r\nfunction construct(meta) {\r\n    var item,\r\n        component;\r\n\r\n    if (meta.object.$class in constructors) {\r\n        item = new constructors[meta.object.$class](meta);\r\n    }\r\n    else {\r\n        // Load component from file. Please look at import.js for main notes.\r\n        // Actually, we have to use that order:\r\n        // 1) try to load component from current basePath\r\n        // 2) from importPathList\r\n        // 3) from directories in imports statements and then\r\n        // 4) from qmldir files\r\n        // Currently we support only 1,2 and 4 and use order: 4,1,2\r\n        // TODO: engine.qmldirs is global for all loaded components. That's not qml's original behaviour.\r\n        var qdirInfo = engine.qmldirs[meta.object.$class]; // Are we have info on that component in some imported qmldir files?\r\n        if (qdirInfo) {\r\n            // We have that component in some qmldir, load it from qmldir's url\r\n            component = Qt.createComponent( \"@\" + qdirInfo.url, meta.context);\r\n        }\r\n        else\r\n            component = Qt.createComponent(meta.object.$class + \".qml\", meta.context);\r\n\r\n        if (component) {\r\n            var item = component.createObject(meta.parent);\r\n\r\n            if (typeof item.dom != 'undefined')\r\n                item.dom.className += \" \" + meta.object.$class + (meta.object.id ? \" \" + meta.object.id : \"\");\r\n            var dProp; // Handle default properties\r\n        } else {\r\n            console.log(\"No constructor found for \" + meta.object.$class);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // id\r\n    if (meta.object.id)\r\n        meta.context[meta.object.id] = item;\r\n\r\n    // keep path in item for probale use it later in Qt.resolvedUrl\r\n    item.$context[\"$basePath\"] = engine.$basePath; //gut\r\n\r\n    // Apply properties (Bindings won't get evaluated, yet)\r\n    applyProperties(meta.object, item, item, item.$context);\r\n\r\n    return item;\r\n}\r\n\r\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {String} propName Property name\r\n * @param {Object} [options] Options that allow finetuning of the property\r\n */\r\nfunction createSimpleProperty(type, obj, propName, options) {\r\n    var prop = new QMLProperty(type, obj, propName);\r\n    var getter, setter;\r\n\r\n    if (typeof options == 'undefined')\r\n      options = {};\r\n    else if (typeof options != 'object')\r\n      options = { default: options }\r\n\r\n    obj[propName + \"Changed\"] = prop.changed;\r\n    obj.$properties[propName] = prop;\r\n    obj.$properties[propName].set(options.default);\r\n    getter = function()       { return obj.$properties[propName].get(); };\r\n    if (!options.readOnly)\r\n      setter = function(newVal) { return obj.$properties[propName].set(newVal); };\r\n    else {\r\n      setter = function(newVal) {\r\n        if (obj.$canEditReadOnlyProperties != true)\r\n          throw \"property '\" + propName + \"' has read only access\";\r\n        return obj.$properties[propName].set(newVal);\r\n      }\r\n    }\r\n    setupGetterSetter(obj, propName, getter, setter);\r\n    if (obj.$isComponentRoot)\r\n        setupGetterSetter(obj.$context, propName, getter, setter);\r\n}\r\n\r\n/**\r\n * Set up simple getter function for property\r\n */\r\nvar setupGetter,\r\n    setupSetter,\r\n    setupGetterSetter;\r\n(function() {\r\n\r\n// todo: What's wrong with Object.defineProperty on some browsers?\r\n// Object.defineProperty is the standard way to setup getters and setters.\r\n// However, the following way to use Object.defineProperty don't work on some\r\n// webkit-based browsers, namely Safari, iPad, iPhone and Nokia N9 browser.\r\n// Chrome, firefox and opera still digest them fine.\r\n\r\n// So, if the deprecated __defineGetter__ is available, use those, and if not\r\n// use the standard Object.defineProperty (IE for example).\r\n\r\n    var useDefineProperty = !(Object[GETTER] && Object[SETTER]);\r\n\r\n    if (useDefineProperty) {\r\n\r\n        if (!Object.defineProperty) {\r\n            console.log(\"No __defineGetter__ or defineProperty available!\");\r\n        }\r\n\r\n        setupGetter = function(obj, propName, func) {\r\n            Object.defineProperty(obj, propName,\r\n                { get: func, configurable: true, enumerable: true } );\r\n        }\r\n        setupSetter = function(obj, propName, func) {\r\n            Object.defineProperty(obj, propName,\r\n                { set: func, configurable: true, enumerable: false });\r\n        }\r\n        setupGetterSetter = function(obj, propName, getter, setter) {\r\n            Object.defineProperty(obj, propName,\r\n                {get: getter, set: setter, configurable: true, enumerable: false });\r\n        }\r\n    } else {\r\n        setupGetter = function(obj, propName, func) {\r\n            obj[GETTER](propName, func);\r\n        }\r\n        setupSetter = function(obj, propName, func) {\r\n            obj[SETTER](propName, func);\r\n        }\r\n        setupGetterSetter = function(obj, propName, getter, setter) {\r\n            obj[GETTER](propName, getter);\r\n            obj[SETTER](propName, setter);\r\n        }\r\n    }\r\n\r\n})();\r\n/**\r\n * Apply properties from metaObject to item.\r\n * @param {Object} metaObject Source of properties\r\n * @param {Object} item Target of property apply\r\n * @param {Object} objectScope Scope in which properties should be evaluated\r\n * @param {Object} componentScope Component scope in which properties should be evaluated\r\n */\r\nfunction applyProperties(metaObject, item, objectScope, componentScope) {\r\n    var i;\r\n    objectScope = objectScope || item;\r\n    for (i in metaObject) {\r\n        var value = metaObject[i];\r\n        // skip global id's and internal values\r\n        if (i == \"id\" || i[0] == \"$\") {\r\n            continue;\r\n        }\r\n        // slots\r\n        if (i.indexOf(\"on\") == 0 && i[2].toUpperCase() == i[2]) {\r\n            var signalName =  i[2].toLowerCase() + i.slice(3);\r\n            if (!item[signalName]) {\r\n                console.warn(\"No signal called \" + signalName + \" found!\");\r\n                continue;\r\n            }\r\n            else if (typeof item[signalName].connect != 'function') {\r\n                console.warn(signalName + \" is not a signal!\");\r\n                continue;\r\n            }\r\n            if (!value.eval) {\r\n                var params = \"\";\r\n                for (var j in item[signalName].parameters) {\r\n                    params += j==0 ? \"\" : \", \";\r\n                    params += item[signalName].parameters[j].name;\r\n                }\r\n                value.src = \"(function(\" + params + \") {\" + value.src + \"})\";\r\n                value.function = false;\r\n                value.compile();\r\n            }\r\n            item[signalName].connect(item, value.eval(objectScope, componentScope));\r\n            continue;\r\n        }\r\n\r\n        if (value instanceof Object) {\r\n            if (value instanceof QMLSignalDefinition) {\r\n                item[i] = Signal(value.parameters);\r\n                if (item.$isComponentRoot)\r\n                    componentScope[i] = item[i];\r\n                continue;\r\n            } else if (value instanceof QMLMethod) {\r\n                value.compile();\r\n                item[i] = value.eval(objectScope, componentScope);\r\n                if (item.$isComponentRoot)\r\n                    componentScope[i] = item[i];\r\n                continue;\r\n            } else if (value instanceof QMLAliasDefinition) {\r\n                createSimpleProperty(\"alias\", item, i);\r\n                item.$properties[i].componentScope = componentScope;\r\n                item.$properties[i].val = value;\r\n                item.$properties[i].get = function() {\r\n                    var obj = this.componentScope[this.val.objectName];\r\n                    return this.val.propertyName ? obj.$properties[this.val.propertyName].get() : obj;\r\n                }\r\n                item.$properties[i].set = function(newVal, fromAnimation, objectScope, componentScope) {\r\n                    if (!this.val.propertyName)\r\n                        throw \"Cannot set alias property pointing to an QML object.\";\r\n                    this.componentScope[this.val.objectName].$properties[this.val.propertyName].set(newVal, fromAnimation, objectScope, componentScope);\r\n                }\r\n                continue;\r\n            } else if (value instanceof QMLPropertyDefinition) {\r\n                createSimpleProperty(value.type, item, i);\r\n                item.$properties[i].set(value.value, true, objectScope, componentScope);\r\n                continue;\r\n            } else if (item[i] && value instanceof QMLMetaPropertyGroup) {\r\n                // Apply properties one by one, otherwise apply at once\r\n                applyProperties(value, item[i], objectScope, componentScope);\r\n                continue;\r\n            }\r\n        }\r\n        if (item.$properties && i in item.$properties)\r\n            item.$properties[i].set(value, true, objectScope, componentScope);\r\n        else if (i in item)\r\n            item[i] = value;\r\n        else if (item.$setCustomData)\r\n            item.$setCustomData(i, value);\r\n        else\r\n            console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\r\n    }\r\n    if (metaObject.$children && metaObject.$children.length !== 0) {\r\n        if (item.$defaultProperty)\r\n            item.$properties[item.$defaultProperty].set(metaObject.$children, true, objectScope, componentScope);\r\n        else\r\n            throw \"Cannot assign to unexistant default property\";\r\n    }\r\n    // We purposefully set the default property AFTER using it, in order to only have it applied for\r\n    // instanciations of this component, but not for its internal children\r\n    if (metaObject.$defaultProperty)\r\n        item.$defaultProperty = metaObject.$defaultProperty;\r\n    if (typeof item.completed != 'undefined' && item.completedAlreadyCalled == false) {\r\n      item.completedAlreadyCalled = true;\r\n      item.completed();\r\n    }\r\n}\r\n\r\n// ItemModel. EXPORTED.\r\nJSItemModel = function() {\r\n    this.roleNames = [];\r\n\r\n    this.setRoleNames = function(names) {\r\n        this.roleNames = names;\r\n    }\r\n\r\n    this.dataChanged = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.rowsInserted = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.rowsMoved = Signal([\r\n        {type:\"int\", name:\"sourceStartIndex\"},\r\n        {type:\"int\", name:\"sourceEndIndex\"},\r\n        {type:\"int\", name:\"destinationIndex\"}\r\n    ]);\r\n    this.rowsRemoved = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.modelReset = Signal();\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Stuff below defines QML things\r\n// -----------------------------------------------------------------------------\r\n\r\n// Helper\r\nfunction unboundMethod() {\r\n    console.log(\"Unbound method for\", this);\r\n}\r\n\n(function() {\r\n  global.importJavascriptInContext = function (jsData, $context) {\r\n    with($context) {\r\n      eval(jsData.source);\r\n      for (var i = 0 ; i < jsData.exports.length ; ++i) {\r\n        var symbolName = jsData.exports[i];\r\n        $context[symbolName] = eval(symbolName);\r\n      }\r\n    }\r\n  }\r\n\r\n  global.jsparse = function (source) {\r\n    var obj = { exports: [], source: source };\r\n    var AST_Tree = qmlweb_parse(source, qmlweb_parse.JSResource);\r\n    var foo_function_scope = AST_Tree[2][2][3];\r\n\r\n    for (var i = 0 ; i < foo_function_scope.length ; ++i) {\r\n      var item = foo_function_scope[i];\r\n\r\n      switch (item[0]) {\r\n        case \"var\":\r\n          obj.exports.push(item[1][0][0]);\r\n          break ;\r\n        case \"defun\":\r\n          obj.exports.push(item[1]);\r\n          break ;\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n})();\r\n\n// Base object for all qml elements\r\nfunction QMLBaseObject(meta) {\r\n    QObject.call(this, meta.parent);\r\n    var i,\r\n        prop;\r\n\r\n    this.$draw = function(){};\r\n    this.$isComponentRoot = meta.isComponentRoot;\r\n    this.$context = meta.context;\r\n\r\n    // Component.onCompleted\r\n    this.Component = new QObject(this);\r\n    this.Component.completed = Signal([]);\r\n    engine.completedSignals.push(this.Component.completed);\r\n    this.completed = this.Component.completed;\r\n\r\n    this.Component.destruction = Signal([]);\r\n    this.destruction = this.Component.destruction;\r\n\r\n    // Component get own properties\r\n    var attributes = [];\r\n    for (var key in meta.object) {\r\n      if (meta.object.hasOwnProperty(key) &&\r\n          typeof meta.object[key] != 'undefined' && meta.object[key] != null &&\r\n          (meta.object[key].__proto__.constructor.name == 'QMLPropertyDefinition' ||\r\n           meta.object[key].__proto__.constructor.name == 'QMLAliasDefinition')) {\r\n        attributes.push(key);\r\n      }\r\n    }\r\n\r\n    this.Keys = new QObject(this);\r\n    this.Keys.asteriskPresed = Signal();\r\n    this.Keys.backPressed = Signal();\r\n    this.Keys.backtabPressed = Signal();\r\n    this.Keys.callPressed = Signal();\r\n    this.Keys.cancelPressed = Signal();\r\n    this.Keys.deletePressed = Signal();\r\n    for (var i = 0 ; i < 10 ; ++i)\r\n      this.Keys['digit'+i+'Pressed'] = Signal();\r\n    this.Keys.escapePressed = Signal();\r\n    this.Keys.flipPressed = Signal();\r\n    this.Keys.hangupPressed = Signal();\r\n    this.Keys.leftPressed = Signal();\r\n    this.Keys.menuPressed = Signal();\r\n    this.Keys.noPressed = Signal();\r\n    this.Keys.pressed = Signal();\r\n    this.Keys.released = Signal();\r\n    this.Keys.returnPressed = Signal();\r\n    this.Keys.rightPressed = Signal();\r\n    this.Keys.selectPressed = Signal();\r\n    this.Keys.spacePressed = Signal();\r\n    this.Keys.tabPressed = Signal();\r\n    this.Keys.upPressed = Signal();\r\n    this.Keys.volumeDownPressed = Signal();\r\n    this.Keys.volumeUpPressed = Signal();\r\n    this.Keys.yesPressed = Signal();\r\n\r\n    this.getAttributes = function() { return (attributes); }\r\n}\r\n\r\nregisterQmlType({\r\n    module: 'QtQuick',\r\n    name: 'QtObject',\r\n    versions: /.*/,\r\n    constructor: QMLBaseObject\r\n});\r\n\n// TODO\r\nfunction QMLColor(val) {\r\n  if (typeof val === \"number\") {\r\n    // we assume it is int value and must be converted to css hex with padding\r\n    // http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript\r\n    val = \"#\" + (Math.round(val) + 0x1000000).toString(16).substr(-6).toUpperCase();\r\n  } else {\r\n    if(typeof val === \"array\" && val.length >= 3) {\r\n      // array like [r,g,b] where r,g,b are in 0..1 range\r\n      var m = 255;\r\n      val = \"rgb(\" + Math.round(m * val[0]) + \",\" + Math.round(m * val[1]) + \",\" + Math.round(m * val[2]) + \")\";\r\n    }\r\n  }\r\n  return val;\r\n};\r\n\nfunction QMLContext() {\r\n    this.nameForObject = function(obj) {\r\n        for (var name in this) {\r\n            if (this[name] == obj)\r\n                return name;\r\n        }\r\n    }\r\n}\r\n\r\nQMLComponent.prototype.createObject = function(parent, properties) {\r\n    var oldState = engine.operationState;\r\n    engine.operationState = QMLOperationState.Init;\r\n    // change base path to current component base path\r\n    var bp = engine.$basePath; engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\r\n\r\n    var item = construct({\r\n        object: this.$metaObject,\r\n        parent: parent,\r\n        context: this.$context ? Object.create(this.$context) : new QMLContext(),\r\n        isComponentRoot: true\r\n    });\r\n\r\n    // change base path back\r\n    //TODO looks a bit hacky\r\n    engine.$basePath = bp;\r\n\r\n    engine.operationState = oldState;\r\n    return item;\r\n}\r\n\r\nfunction QMLComponent(meta) {\r\n    if (constructors[meta.object.$class] == QMLComponent)\r\n        this.$metaObject = meta.object.$children[0];\r\n    else\r\n        this.$metaObject = meta.object;\r\n    this.$context = meta.context;\r\n\r\n    var jsImports = [];\r\n\r\n    this.finalizeImports = (function($context) {\r\n      for (var i = 0 ; i < jsImports.length ; ++i) {\r\n        var importDesc = jsImports[i];\r\n        var src = importDesc[1];\r\n        var js;\r\n\r\n        if (typeof qmlEngine.$basePath != 'undefined')\r\n          src = qmlEngine.$basePath + src;\r\n        if (typeof qrc[src] != 'undefined')\r\n          js = qrc[src];\r\n        else\r\n          js = global.jsparse(getUrlContents(src));\r\n        if (importDesc[3] !== \"\") {\r\n          $context[importDesc[3]] = {};\r\n          importJavascriptInContext(js, $context[importDesc[3]]);\r\n        }\r\n        else\r\n          importJavascriptInContext(js, $context);\r\n      }\r\n    }).bind(this);\r\n\r\n    if (meta.object.$imports instanceof Array)\r\n    {\r\n      var moduleImports = [];\r\n      var loadImport    = (function(importDesc) {\r\n        if (/\\.js$/.test(importDesc[1]))\r\n          jsImports.push(importDesc);\r\n        else\r\n          moduleImports.push(importDesc);\r\n      }).bind(this);\r\n\r\n      for (var i = 0 ; i < meta.object.$imports.length ; ++i) {\r\n        loadImport(meta.object.$imports[i]);\r\n      }\r\n      loadImports(this, moduleImports);\r\n      if (typeof this.$context != 'undefined' && this.$context != null)\r\n        this.finalizeImports(this.$context);\r\n    }\r\n}\r\ninherit(QMLComponent, QMLBaseObject);\r\n\r\nregisterQmlType('Component',   QMLComponent);\r\nregisterQmlType('QMLDocument', QMLComponent);\r\n\n/*\r\n * - QMLEngine(element, options) -- Returns new qml engine object, for which:\r\n *   - loadFile(file) -- Load file to the engine (.qml or .qml.js atm)\r\n *   - start() -- start the engine/application\r\n *   - stop() -- stop the engine/application. Restarting is experimental.\r\n *   element is HTMLCanvasElement and options are for debugging.\r\n *   For further reference, see testpad and qml viewer applications.\r\n */\r\n\r\n// There can only be one running QMLEngine. This variable points to the currently running engine.\r\nvar engine = null;\r\n\r\n// QML engine. EXPORTED.\r\nQMLEngine = function (element, options) {\r\n//----------Public Members----------\r\n    this.fps = 60;\r\n    this.$interval = Math.floor(1000 / this.fps); // Math.floor, causes bugs to timing?\r\n    this.running = false;\r\n\r\n    // Mouse Handling\r\n    this.mouseAreas = [];\r\n    this.oldMousePos = {x:0, y:0};\r\n\r\n    // List of available Components\r\n    this.components = {};\r\n\r\n    this.rootElement = element;\r\n\r\n    // List of Component.completed signals\r\n    this.completedSignals = [];\r\n\r\n    // Current operation state of the engine (Idle, init, etc.)\r\n    this.operationState = 1;\r\n\r\n    // List of properties whose values are bindings. For internal use only.\r\n    this.bindedProperties = [];\r\n\r\n    // Root object of the engine\r\n    this.rootObject = null;\r\n\r\n    // Base path of qml engine (used for resource loading)\r\n    this.$basePath = \"\";\r\n\r\n\r\n//----------Public Methods----------\r\n    // Start the engine\r\n    this.start = function()\r\n    {\r\n        engine = this;\r\n        var i;\r\n        if (this.operationState !== QMLOperationState.Running) {\r\n            this.operationState = QMLOperationState.Running;\r\n            tickerId = setInterval(tick, this.$interval);\r\n            for (i = 0; i < whenStart.length; i++) {\r\n                whenStart[i]();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Stop the engine\r\n    this.stop = function()\r\n    {\r\n        var i;\r\n        if (this.operationState == QMLOperationState.Running) {\r\n            element.removeEventListener(\"touchstart\", touchHandler);\r\n            element.removeEventListener(\"mousemove\", mousemoveHandler);\r\n            clearInterval(tickerId);\r\n            this.operationState = QMLOperationState.Idle;\r\n            for (i = 0; i < whenStop.length; i++) {\r\n                whenStop[i]();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    this.ensureFileIsLoadedInQrc = function(file) {\r\n      if (!qrc.includesFile(file)) {\r\n        var src = getUrlContents(file);\r\n\r\n        if (src) {\r\n            console.log('Loading file [', file, ']');\r\n            qrc[file] = qmlparse(src);\r\n        } else {\r\n            console.log('Can not load file [', file, ']');\r\n        }\r\n      }\r\n    }\r\n\r\n    this.extractBasePath = function( file ) {\r\n       var basePath = file.split(/[\\/\\\\]/); // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\r\n       basePath[basePath.length - 1] = \"\";\r\n       basePath = basePath.join(\"/\");\r\n       return basePath;\r\n    }\r\n    // Load file, parse and construct (.qml or .qml.js)\r\n    this.loadFile = function(file) {\r\n        var tree;\r\n\r\n        this.$basePath = this.extractBasePath(file);\r\n        this.ensureFileIsLoadedInQrc(file);\r\n        tree = convertToEngine(qrc[file]);\r\n        this.loadQMLTree(tree);\r\n    }\r\n\r\n    // parse and construct qml\r\n    this.loadQML = function(src) {\r\n        this.loadQMLTree(parseQML(src));\r\n    }\r\n\r\n    this.loadQMLTree = function(tree, file) {\r\n        engine = this;\r\n        if (options.debugTree) {\r\n            options.debugTree(tree);\r\n        }\r\n\r\n        // Create and initialize objects\r\n        var component = new QMLComponent({ object: tree, parent: null });\r\n\r\n        this.loadImports( tree.$imports );\r\n        component.$basePath = engine.$basePath;\r\n        component.$imports = tree.$imports; // for later use\r\n        component.$file = file; // just for debugging\r\n\r\n        this.rootObject = component.createObject(null);\r\n        component.finalizeImports(this.rootContext());\r\n        this.$initializePropertyBindings();\r\n\r\n        this.start();\r\n\r\n        // Call completed signals\r\n        for (var i in this.completedSignals) {\r\n            this.completedSignals[i]();\r\n        }\r\n    }\r\n\r\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\r\n     *\r\n     * Removes dot segments in given path component, as described in\r\n     * RFC 3986, section 5.2.4.\r\n     *\r\n     * @param {string} path A non-empty path component.\r\n     * @return {string} Path component with removed dot segments.\r\n     */\r\n    this.removeDotSegments = function(path) {\r\n        var leadingSlash = (path && path[0] == \"/\");   // path.startsWith('/'); -- startsWith seems to be undefined in some browsers\r\n        var segments = path.split('/');\r\n        var out = [];\r\n\r\n        for (var pos = 0; pos < segments.length; ) {\r\n            var segment = segments[pos++];\r\n\r\n            if (segment == '.') {\r\n                if (leadingSlash && pos == segments.length) {\r\n                    out.push('');\r\n                }\r\n            } else if (segment == '..') {\r\n                if (out.length > 1 || out.length == 1 && out[0] != '') {\r\n                    out.pop();\r\n                }\r\n                if (leadingSlash && pos == segments.length) {\r\n                    out.push('');\r\n                }\r\n            } else {\r\n                out.push(segment);\r\n                leadingSlash = true;\r\n            }\r\n        }\r\n\r\n        return out.join('/');\r\n    };\r\n\r\n    /*\r\n      engine.loadImports( imports, currentDir ) : performs loading of qmldir files from given qml import records.\r\n\r\n      Input:\r\n      * parameter `importsArray` - import statements. It is in parser notation, e.g. [import1, import2, ...] where each importN is also array: [\"qmlimport\",\"name\",version,as,isQualifiedName]\r\n      * parameter `currentFileDir` - base dir for imports lookup. It will be used together with importPathList()\r\n\r\n      Implicit input:\r\n      * engine object function `importPathList()` - list of urls bases used for qmldir files lookup\r\n\r\n      Additional implicit input/output:\r\n      * engine object variable `qmldirsContents` - used for caching, e.g. memory for previously loaded qmldir files\r\n\r\n      Output: \r\n      * engine object variable `qmldirs` - new records will be added there\r\n\r\n      Return value: \r\n      * nothing\r\n\r\n      Details:\r\n\r\n      For each of given import statements, loadImports \r\n      1. computes qmldir file location according to http://doc.qt.io/qt-5/qtqml-syntax-imports.html\r\n      2. calls `readQmlDir` for actual reading and parsing of qmldir file content\r\n      3. gets `external` declarations of that qmldir file and pushes them to `engine.qmldirs` hash.\r\n\r\n      `engine.qmldirs` is a hash of form: { componentName => componentFileUrl }\r\n      This hash then used by `qml.js::construct` method for computing component urls.\r\n\r\n      Notes:\r\n      1. This method is not suited for loading js imports. This may be done probably after answering to Q1 (below).\r\n      2. Please look for additional notes at readQmlDir function.\r\n\r\n      QNA\r\n      Q1: How and where in engine component names might be prefixed? E.g. names with dot inside: SomeModule.Component1\r\n      A1: Seems it doesn't matter. Seems we may just save name with dot-inside right to qmldirs, and it may be used by construct() seamlessly. Check it..\r\n\r\n      Q2: How we may access component object from here, to store qmldirs info in components logical scope, and not at engine scope?\r\n      A2: Probably, answer is in Component.js and in global.loadImports\r\n\r\n      TODO \r\n      * We have to keep output in component scope, not in engine scope.\r\n      * We have to add module \"as\"-names to component's names (which is possible after keeping imports in component scope).\r\n      * Determine how this stuff is related to `global.loadImports`\r\n      * Check A1\r\n      * Make a complete picture of what going in with imports, including Component.js own imports loading\r\n      * Note importJs method in import.js \r\n    */\r\n\r\n    this.loadImports = function(importsArray, currentFileDir) {\r\n        if (!this.qmldirsContents) this.qmldirsContents = { \"QtQuick\":{}, \"QtQuick.Controls\":{} }; // cache\r\n        // putting initial keys in qmldirsContents - is a hack. We should find a way to explain to qmlweb, is this built-in module or qmldir-style module.\r\n\r\n        if (!this.qmldirs) this.qmldirs = {};                 // resulting components lookup table\r\n\r\n        if (!importsArray || importsArray.length == 0) return;\r\n        if (!currentFileDir) currentFileDir = this.$basePath;     // use this.$basePath by default\r\n\r\n        for (var i=0; i<importsArray.length; i++) {\r\n            var entry = importsArray[i];\r\n\r\n            var name = entry[1];\r\n\r\n            var nameIsUrl = name.indexOf(\"//\") == 0 || name.indexOf(\"://\") >= 0;  // is it url to remote resource\r\n            var nameIsQualifiedModuleName = entry[4]; // e.g. QtQuick, QtQuick.Controls, etc\r\n            var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl; // local [relative] dir\r\n\r\n            if (nameIsDir) {\r\n                // resolve name from relative to full dir path\r\n                // we hope all dirs are relative\r\n                name = this.removeDotSegments( currentFileDir + name );\r\n                if (name[ name.length-1 ] == \"/\")\r\n                    name = name.substr( 0, name.length-1 ); // remove trailing slash as it required for `readQmlDir`\r\n            }\r\n            // TODO if nameIsDir, we have also to add `name` to importPathList() for current component...\r\n\r\n            // check if we have already loaded that qmldir file\r\n            if (this.qmldirsContents[ name ]) continue;\r\n\r\n            var content = false;\r\n            if (nameIsQualifiedModuleName && this.userAddedModulePaths && this.userAddedModulePaths[ name ]) {\r\n                // 1. we have qualified module and user had configured path for that module with this.addModulePath\r\n                content = readQmlDir( this.userAddedModulePaths[ name ] );\r\n            }\r\n            else if (nameIsUrl || nameIsDir)\r\n            {\r\n                // 2. direct load\r\n                // nameIsUrl => url do not need dirs\r\n                // nameIsDir => already computed full path above\r\n                content = readQmlDir( name );\r\n            }\r\n            else\r\n            {\r\n                // 3. qt-style lookup for qualified module\r\n                var probableDirs = [currentFileDir].concat( this.importPathList() )\r\n                var diredName = name.replace( /\\./g,\"/\" );\r\n\r\n                for (var k=0; k<probableDirs.length; k++) {\r\n                    var file = probableDirs[k] + diredName;\r\n                    content = readQmlDir( file );\r\n                    if (content) break;\r\n                }\r\n            }\r\n\r\n            if (!content) {\r\n                console.log(\"qmlengine::loadImports: cannot load qmldir file for import name=\",name );\r\n                // save blank info, meaning that we failed to load import\r\n                // this prevents repeated lookups\r\n                this.qmldirsContents[ name ] = {};\r\n\r\n               // NEW\r\n               // add that dir to import path list\r\n               // that means, lookup qml files in that failed dir by trying to load them directly\r\n               // this is not the same behavior as in Qt for \"url\" schemes,\r\n               // but it is same as for ordirnal disk files. \r\n               // So, we do it for experimental purposes.\r\n               if (nameIsDir) \r\n                 this.addImportPath( name + \"/\" );\r\n\r\n               continue;\r\n            }\r\n\r\n            // copy founded externals to global var\r\n            // TODO actually we have to copy it to current component\r\n            for (var attrname in content.externals) { this.qmldirs[attrname] = content.externals[attrname]; }\r\n\r\n            // keep already loaded qmldir files\r\n            this.qmldirsContents[ name ] = content;\r\n        }\r\n\r\n    }\r\n\r\n    this.rootContext = function() {\r\n      return this.rootObject.$context;\r\n    }\r\n\r\n    this.focusedElement = (function() {\r\n      return this.rootContext().activeFocus;\r\n    }).bind(this);\r\n\r\n    // KEYBOARD MANAGEMENT\r\n    var keyboardSignals = {};\r\n    keyboardSignals[Qt.Key_Asterisk]   = 'asteriskPressed';\r\n    keyboardSignals[Qt.Key_Back]       = 'backPressed';\r\n    keyboardSignals[Qt.Key_Backtab]    = 'backtabPressed';\r\n    keyboardSignals[Qt.Key_Call]       = 'callPressed';\r\n    keyboardSignals[Qt.Key_Cancel]     = 'cancelPressed';\r\n    keyboardSignals[Qt.Key_Delete]     = 'deletePressed';\r\n    keyboardSignals[Qt.Key_0]          = 'digit0Pressed';\r\n    keyboardSignals[Qt.Key_1]          = 'digit1Pressed';\r\n    keyboardSignals[Qt.Key_2]          = 'digit2Pressed';\r\n    keyboardSignals[Qt.Key_3]          = 'digit3Pressed';\r\n    keyboardSignals[Qt.Key_4]          = 'digit4Pressed';\r\n    keyboardSignals[Qt.Key_5]          = 'digit5Pressed';\r\n    keyboardSignals[Qt.Key_6]          = 'digit6Pressed';\r\n    keyboardSignals[Qt.Key_7]          = 'digit7Pressed';\r\n    keyboardSignals[Qt.Key_8]          = 'digit8Pressed';\r\n    keyboardSignals[Qt.Key_9]          = 'digit9Pressed';\r\n    keyboardSignals[Qt.Key_Escape]     = 'escapePressed';\r\n    keyboardSignals[Qt.Key_Flip]       = 'flipPressed';\r\n    keyboardSignals[Qt.Key_Hangup]     = 'hangupPressed';\r\n    keyboardSignals[Qt.Key_Menu]       = 'menuPressed';\r\n    keyboardSignals[Qt.Key_No]         = 'noPressed';\r\n    keyboardSignals[Qt.Key_Return]     = 'returnPressed';\r\n    keyboardSignals[Qt.Key_Select]     = 'selectPressed';\r\n    keyboardSignals[Qt.Key_Space]      = 'spacePressed';\r\n    keyboardSignals[Qt.Key_Tab]        = 'tabPressed';\r\n    keyboardSignals[Qt.Key_VolumeDown] = 'volumeDownPressed';\r\n    keyboardSignals[Qt.Key_VolumeUp]   = 'volumeUpPressed';\r\n    keyboardSignals[Qt.Key_Yes]        = 'yesPressed';\r\n    keyboardSignals[Qt.Key_Up]         = 'upPressed';\r\n    keyboardSignals[Qt.Key_Right]      = 'rightPressed';\r\n    keyboardSignals[Qt.Key_Down]       = 'downPressed';\r\n    keyboardSignals[Qt.Key_Left]       = 'leftPressed';\r\n\r\n    function keyCodeToQt(e) {\r\n      if (e.keyCode >= 96 && e.keyCode <= 111) {\r\n        e.keypad = true;\r\n      }\r\n      if (e.keyCode == Qt.Key_Tab && e.shiftKey == true)\r\n        return Qt.Key_Backtab;\r\n      else if (e.keyCode >= 97 && e.keyCode <= 122)\r\n        return e.keyCode - (97 - Qt.Key_A);\r\n      return e.keyCode;\r\n    }\r\n\r\n    function eventToKeyboard(e) {\r\n        return {\r\n            accepted: false,\r\n            count: 1,\r\n            isAutoRepeat: false,\r\n            key: keyCodeToQt(e),\r\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\r\n                    | (e.altKey   * Qt.AltModifier)\r\n                    | (e.shiftKey * Qt.ShiftModifier)\r\n                    | (e.metaKey  * Qt.MetaModifier)\r\n                    | (e.keypad   * Qt.KeypadModifier),\r\n            text: String.fromCharCode(e.charCode)\r\n        };\r\n    }\r\n\r\n    document.onkeypress = (function(e) {\r\n      var focusedElement = this.focusedElement();\r\n      var event          = eventToKeyboard(e || window.event);\r\n      var eventName      = keyboardSignals[event.key];\r\n\r\n      while (event.accepted != true && focusedElement != null) {\r\n        var backup       = focusedElement.$context.event;\r\n\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.pressed(event);\r\n        if (eventName != null)\r\n          focusedElement.Keys[eventName](event);\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted == true)\r\n          e.preventDefault();\r\n        else\r\n          focusedElement = focusedElement.$parent;\r\n      }\r\n    }).bind(this);\r\n\r\n    document.onkeyup = (function(e) {\r\n      var focusedElement = this.focusedElement();\r\n      var event          = eventToKeyboard(e || window.event);\r\n\r\n      while (event.accepted != true && focusedElement != null) {\r\n        var backup       = focusedElement.$context.event;\r\n\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.released(event);\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted == true)\r\n          e.preventDefault();\r\n        else\r\n          focusedElement = focusedElement.$parent;\r\n      }\r\n    }).bind(this);\r\n    // END KEYBOARD MANAGEMENT\r\n\r\n    this.registerProperty = function(obj, propName)\r\n    {\r\n        var dependantProperties = [];\r\n        var value = obj[propName];\r\n\r\n        function getter() {\r\n            if (evaluatingProperty && dependantProperties.indexOf(evaluatingProperty) == -1)\r\n                dependantProperties.push(evaluatingProperty);\r\n\r\n            return value;\r\n        }\r\n\r\n        function setter(newVal) {\r\n            value = newVal;\r\n\r\n            for (i in dependantProperties)\r\n                dependantProperties[i].update();\r\n        }\r\n\r\n        setupGetterSetter(obj, propName, getter, setter);\r\n    }\r\n\r\n    // next 3 methods used in Qt.createComponent for qml files lookup\r\n    // please open qt site for documentation\r\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\r\n\r\n    this.addImportPath = function( dirpath ) {\r\n        if (!this.userAddedImportPaths) this.userAddedImportPaths = [];\r\n        this.userAddedImportPaths.push( dirpath );\r\n    }\r\n\r\n    this.setImportPathList = function( arrayOfDirs )\r\n    {\r\n        this.userAddedImportPaths = arrayOfDirs;\r\n    }\r\n\r\n    this.importPathList = function() {\r\n        return (this.userAddedImportPaths || []);\r\n    }\r\n\r\n    // `addModulePath` defines conrete path for module lookup\r\n    // e.g. addModulePath( \"QtQuick.Controls\",\"http://someserver.com/controls\" )\r\n    // will force system to `import QtQuick.Controls` module from `http://someserver.com/controls/qmldir`\r\n\r\n    this.addModulePath = function( moduleName, dirPath ) {\r\n\r\n        // remove trailing slash as it required for `readQmlDir`\r\n        if (dirPath[ dirPath.length-1 ] == \"/\")\r\n            dirPath = dirPath.substr( 0, dirPath.length-1 );\r\n\r\n        // keep the mapping. It will be used in loadImports() function .\r\n        if (!this.userAddedModulePaths) this.userAddedModulePaths = {};\r\n        this.userAddedModulePaths[ moduleName ] = dirPath;\r\n    }\r\n\r\n//Intern\r\n\r\n    // Load file, parse and construct as Component (.qml)\r\n    this.loadComponent = function(name)\r\n    {\r\n        if (name in this.components)\r\n            return this.components[name];\r\n\r\n        var file = qmlEngine.$basePath + name + \".qml\";\r\n\r\n        this.ensureFileIsLoadedInQrc(file);\r\n        tree = convertToEngine(qrc[file]);\r\n        this.components[name] = tree;\r\n        return tree;\r\n    }\r\n\r\n    this.$initializePropertyBindings = function() {\r\n        // Initialize property bindings\r\n        for (var i = 0; i < this.bindedProperties.length; i++) {\r\n            var property = this.bindedProperties[i];\r\n            property.binding.compile();\r\n            property.update();\r\n        }\r\n        this.bindedProperties = [];\r\n    }\r\n\r\n    this.$getTextMetrics = function(text, fontCss)\r\n    {\r\n        canvas.save();\r\n        canvas.font = fontCss;\r\n        var metrics = canvas.measureText(text);\r\n        canvas.restore();\r\n        return metrics;\r\n    }\r\n\r\n    // Return a path to load the file\r\n    this.$resolvePath = function(file)\r\n    {\r\n        // probably, replace :// with :/ ?\r\n        if (file == \"\" || file.indexOf(\"://\") != -1 || file.indexOf(\"/\") == 0 || file.indexOf(\"data:\") == 0 || file.indexOf(\"blob:\") == 0) {\r\n            return file;\r\n        }\r\n        return this.$basePath + file;\r\n    }\r\n\r\n    this.$registerStart = function(f)\r\n    {\r\n        whenStart.push(f);\r\n    }\r\n\r\n    this.$registerStop = function(f)\r\n    {\r\n        whenStop.push(f);\r\n    }\r\n\r\n    this.$addTicker = function(t)\r\n    {\r\n        tickers.push(t);\r\n    }\r\n\r\n    this.$removeTicker = function(t)\r\n    {\r\n        var index = tickers.indexOf(t);\r\n        if (index != -1) {\r\n            tickers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    this.size = function()\r\n    {\r\n        return { width: this.rootObject.getWidth(), height: this.rootObject.getHeight() };\r\n    }\r\n\r\n    // Performance measurements\r\n    this.$perfDraw = function(canvas)\r\n    {\r\n        this.rootObject.$draw(canvas);\r\n    }\r\n\r\n//----------Private Methods----------\r\n    // In JS we cannot easily access public members from\r\n    // private members so self acts as a bridge\r\n    var self = this;\r\n\r\n    // Listen also to touchstart events on supporting devices\r\n    // Makes clicks more responsive (do not wait for click event anymore)\r\n    function touchHandler(e)\r\n    {\r\n        // preventDefault also disables pinching and scrolling while touching\r\n        // on qml application\r\n        e.preventDefault();\r\n        var at = {\r\n            layerX: e.touches[0].pageX - element.offsetLeft,\r\n            layerY: e.touches[0].pageY - element.offsetTop,\r\n            button: 1\r\n        }\r\n        element.onclick(at);\r\n\r\n    }\r\n\r\n    function mousemoveHandler(e)\r\n    {\r\n        var i;\r\n        for (i in self.mouseAreas) {\r\n            var l = self.mouseAreas[i];\r\n            if (l && l.hoverEnabled\r\n                  && (self.oldMousePos.x >= l.left\r\n                      && self.oldMousePos.x <= l.right\r\n                      && self.oldMousePos.y >= l.top\r\n                      && self.oldMousePos.y <= l.bottom)\r\n                  && !(e.pageX - element.offsetLeft >= l.left\r\n                       && e.pageX - element.offsetLeft <= l.right\r\n                       && e.pageY - element.offsetTop >= l.top\r\n                       && e.pageY - element.offsetTop <= l.bottom) )\r\n                l.exited();\r\n        }\r\n        for (i in self.mouseAreas) {\r\n            var l = self.mouseAreas[i];\r\n            if (l && l.hoverEnabled\r\n                  && (e.pageX - element.offsetLeft >= l.left\r\n                      && e.pageX - element.offsetLeft <= l.right\r\n                      && e.pageY - element.offsetTop >= l.top\r\n                      && e.pageY - element.offsetTop <= l.bottom)\r\n                  && !(self.oldMousePos.x >= l.left\r\n                       && self.oldMousePos.x <= l.right\r\n                       && self.oldMousePos.y >= l.top\r\n                       && self.oldMousePos.y <= l.bottom))\r\n                l.entered();\r\n        }\r\n        self.oldMousePos = { x: e.pageX - element.offsetLeft,\r\n                            y: e.pageY - element.offsetTop };\r\n    }\r\n\r\n    function tick()\r\n    {\r\n        var i,\r\n            now = (new Date).getTime(),\r\n            elapsed = now - lastTick;\r\n        lastTick = now;\r\n        for (i = 0; i < tickers.length; i++) {\r\n            tickers[i](now, elapsed);\r\n        }\r\n    }\r\n\r\n\r\n//----------Private Members----------\r\n    // Target canvas\r\n    var // Callbacks for stopping or starting the engine\r\n        whenStop = [],\r\n        whenStart = [],\r\n        // Ticker resource id and ticker callbacks\r\n        tickerId,\r\n        tickers = [],\r\n        lastTick = new Date().getTime(),\r\n        i;\r\n\r\n\r\n//----------Construct----------\r\n\r\n    options = options || {};\r\n\r\n    if (options.debugConsole) {\r\n        // Replace QML-side console.log\r\n        console = {};\r\n        console.log = function() {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            options.debugConsole.apply(undefined, args);\r\n        };\r\n    }\r\n}\r\n\r\n\nfunction QMLInteger(val) {\r\n    return (val|0);\r\n}\r\n\nfunction QMLItem(meta) {\r\n    QMLBaseObject.call(this, meta);\r\n    var child,\r\n        o, i;\r\n\r\n    this.completed = Signal();\r\n    this.completedAlreadyCalled = false;\r\n\r\n    if (this.$parent === null) { // This is the root element. Initialize it.\r\n        this.dom = engine.rootElement || document.body;\r\n        this.dom.innerHTML = \"\";\r\n        var self = this;\r\n        this.dom.style.position = \"relative\"; // Needed to make absolute positioning work\r\n        this.dom.style.top = \"0\";\r\n        this.dom.style.left = \"0\";\r\n        this.dom.style.overflow = \"hidden\"; // No QML stuff should stand out the root element\r\n    } else {\r\n        if (!this.dom) // Create a dom element for this item.\r\n            this.dom = document.createElement(\"div\");\r\n        this.dom.style.position = \"absolute\";\r\n    }\r\n    this.dom.style.pointerEvents = \"none\";\r\n    this.dom.className = meta.object.$class + (this.id ? \" \" + this.id : \"\");\r\n    this.dom.qml = this;\r\n    this.css = this.dom.style;\r\n\r\n    this.css.boxSizing = 'border-box';\r\n\r\n    createSimpleProperty(\"list\", this, \"data\");\r\n    this.$defaultProperty = \"data\";\r\n    createSimpleProperty(\"list\", this, \"children\");\r\n    createSimpleProperty(\"list\", this, \"resources\");\r\n    createSimpleProperty(\"Item\", this, \"parent\");\r\n    this.children = [];\r\n    this.resources = [];\r\n    this.parentChanged.connect(this, function(newParent, oldParent) {\r\n        if (oldParent) {\r\n            oldParent.children.splice(oldParent.children.indexOf(this), 1);\r\n            oldParent.childrenChanged();\r\n            oldParent.dom.removeChild(this.dom);\r\n        }\r\n        if (newParent && newParent.children.indexOf(this) == -1) {\r\n            newParent.children.push(this);\r\n            newParent.childrenChanged();\r\n        }\r\n        if (newParent)\r\n            newParent.dom.appendChild(this.dom);\r\n    });\r\n    this.parentChanged.connect(this, updateHGeometry);\r\n    this.parentChanged.connect(this, updateVGeometry);\r\n    this.dataChanged.connect(this, function(newData) {\r\n        for (var i in newData) {\r\n            var child = newData[i];\r\n            if (child.hasOwnProperty(\"parent\")) // Seems to be an Item. TODO: Use real inheritance and ask using instanceof.\r\n                child.parent = this; // This will also add it to children.\r\n            else\r\n                this.resources.push(child);\r\n        }\r\n    });\r\n\r\n    if (this.$isComponentRoot)\r\n      createSimpleProperty(\"var\", this, \"activeFocus\");\r\n    createSimpleProperty(\"real\", this, \"x\");\r\n    createSimpleProperty(\"real\", this, \"y\");\r\n    createSimpleProperty(\"real\", this, \"width\");\r\n    createSimpleProperty(\"real\", this, \"height\");\r\n    createSimpleProperty(\"real\", this, \"implicitWidth\");\r\n    createSimpleProperty(\"real\", this, \"implicitHeight\");\r\n    createSimpleProperty(\"real\", this, \"left\");\r\n    createSimpleProperty(\"real\", this, \"right\");\r\n    createSimpleProperty(\"real\", this, \"top\");\r\n    createSimpleProperty(\"real\", this, \"bottom\");\r\n    createSimpleProperty(\"real\", this, \"horizontalCenter\");\r\n    createSimpleProperty(\"real\", this, \"verticalCenter\");\r\n    createSimpleProperty(\"real\", this, \"rotation\");\r\n    createSimpleProperty(\"real\", this, \"scale\");\r\n    createSimpleProperty(\"real\", this, \"z\");\r\n    createSimpleProperty(\"list\", this, \"transform\");\r\n    createSimpleProperty(\"bool\", this, \"visible\");\r\n    createSimpleProperty(\"real\", this, \"opacity\");\r\n    createSimpleProperty(\"bool\", this, \"clip\");\r\n    createSimpleProperty(\"bool\", this, \"focus\");\r\n    this.xChanged.connect(this, updateHGeometry);\r\n    this.yChanged.connect(this, updateVGeometry);\r\n    this.widthChanged.connect(this, updateHGeometry);\r\n    this.heightChanged.connect(this, updateVGeometry);\r\n    this.implicitWidthChanged.connect(this, updateHGeometry);\r\n    this.implicitHeightChanged.connect(this, updateVGeometry);\r\n    this.focus = false;\r\n\r\n    this.setupFocusOnDom = (function(element) {\r\n      var updateFocus = (function() {\r\n        var hasFocus = document.activeElement == this.dom || document.activeElement == this.dom.firstChild;\r\n\r\n        if (this.focus != hasFocus)\r\n          this.focus = hasFocus;\r\n      }).bind(this);\r\n      element.addEventListener(\"focus\", updateFocus);\r\n      element.addEventListener(\"blur\",  updateFocus);\r\n    }).bind(this);\r\n\r\n    this.focusChanged.connect(this, (function(newVal) {\r\n      if (newVal == true) {\r\n        if (this.dom.firstChild != null)\r\n          this.dom.firstChild.focus();\r\n        document.qmlFocus = this;\r\n        this.$context.activeFocus = this;\r\n      } else if (document.qmlFocus == this) {\r\n        document.getElementsByTagName(\"BODY\")[0].focus();\r\n        document.qmlFocus = qmlEngine.rootContext().base;\r\n        this.$context.activeFocus = null;\r\n      }\r\n    }).bind(this));\r\n\r\n    this.$isUsingImplicitWidth = true;\r\n    this.$isUsingImplicitHeight = true;\r\n\r\n    this.anchors = new QObject(this);\r\n    createSimpleProperty(\"real\", this.anchors, \"left\");\r\n    createSimpleProperty(\"real\", this.anchors, \"right\");\r\n    createSimpleProperty(\"real\", this.anchors, \"top\");\r\n    createSimpleProperty(\"real\", this.anchors, \"bottom\");\r\n    createSimpleProperty(\"real\", this.anchors, \"horizontalCenter\");\r\n    createSimpleProperty(\"real\", this.anchors, \"verticalCenter\");\r\n    createSimpleProperty(\"real\", this.anchors, \"fill\");\r\n    createSimpleProperty(\"real\", this.anchors, \"centerIn\");\r\n    createSimpleProperty(\"real\", this.anchors, \"margins\");\r\n    createSimpleProperty(\"real\", this.anchors, \"leftMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"rightMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"topMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"bottomMargin\");\r\n    this.anchors.leftChanged.connect(this, updateHGeometry);\r\n    this.anchors.rightChanged.connect(this, updateHGeometry);\r\n    this.anchors.topChanged.connect(this, updateVGeometry);\r\n    this.anchors.bottomChanged.connect(this, updateVGeometry);\r\n    this.anchors.horizontalCenterChanged.connect(this, updateHGeometry);\r\n    this.anchors.verticalCenterChanged.connect(this, updateVGeometry);\r\n    this.anchors.fillChanged.connect(this, updateHGeometry);\r\n    this.anchors.fillChanged.connect(this, updateVGeometry);\r\n    this.anchors.centerInChanged.connect(this, updateHGeometry);\r\n    this.anchors.centerInChanged.connect(this, updateVGeometry);\r\n    this.anchors.leftMarginChanged.connect(this, updateHGeometry);\r\n    this.anchors.rightMarginChanged.connect(this, updateHGeometry);\r\n    this.anchors.topMarginChanged.connect(this, updateVGeometry);\r\n    this.anchors.bottomMarginChanged.connect(this, updateVGeometry);\r\n    this.anchors.marginsChanged.connect(this, updateHGeometry);\r\n    this.anchors.marginsChanged.connect(this, updateVGeometry);\r\n\r\n    createSimpleProperty(\"list\", this, \"states\");\r\n    createSimpleProperty(\"string\", this, \"state\");\r\n    createSimpleProperty(\"list\", this, \"transitions\");\r\n    this.stateChanged.connect(this, function(newVal, oldVal) {\r\n        var oldState, newState, i, j, k;\r\n        for (i = 0; i < this.states.length; i++)\r\n            if (this.states[i].name === newVal)\r\n                newState = this.states[i];\r\n            else if (this.states[i].name === oldVal)\r\n                oldState = this.states[i];\r\n\r\n        var actions = this.$revertActions.slice();\r\n\r\n        // Get current values for revert actions\r\n        for (i in actions) {\r\n            var action  = actions[i];\r\n            action.from = action.target[action.property];\r\n        }\r\n        if (newState) {\r\n            var changes = newState.$getAllChanges();\r\n\r\n            // Get all actions we need to do and create actions to revert them\r\n            for (i = 0; i < changes.length; i++) {\r\n                var change = changes[i];\r\n\r\n                for (j = 0; j < change.$actions.length; j++) {\r\n                    var item = change.$actions[j];\r\n\r\n                    var action = {\r\n                        target: change.target,\r\n                        property: item.property,\r\n                        origValue: change.target.$properties[item.property].binding\r\n                                    || change.target.$properties[item.property].val,\r\n                        value: item.value,\r\n                        from: change.target[item.property],\r\n                        to: undefined,\r\n                        explicit: change.explicit\r\n                    };\r\n                    var found = false;\r\n                    for (k in actions)\r\n                        if (actions[k].target == action.target\r\n                            && actions[k].property == action.property) {\r\n                            found = true;\r\n                            actions[k] = action;\r\n                            break;\r\n                        }\r\n                    if (!found)\r\n                        actions.push(action);\r\n\r\n                    // Look for existing revert action, else create it\r\n                    var found = false;\r\n                    for (k = 0; k < this.$revertActions.length; k++)\r\n                        if (this.$revertActions[k].target == change.target\r\n                            && this.$revertActions[k].property == item.property) {\r\n                            if (!change.restoreEntryValues)\r\n                                this.$revertActions.splice(k, 1); // We don't want to revert, so remove it\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    if (!found && change.restoreEntryValues)\r\n                        this.$revertActions.push({\r\n                            target: change.target,\r\n                            property: item.property,\r\n                            value: change.target.$properties[item.property].binding\r\n                                        || change.target.$properties[item.property].val,\r\n                            from: undefined,\r\n                            to: change.target[item.property]\r\n                        });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Set all property changes and fetch the actual values afterwards\r\n        // The latter is needed for transitions. We need to set all properties\r\n        // before we fetch the values because properties can be interdependent.\r\n        for (i in actions) {\r\n            var action = actions[i];\r\n            action.target.$properties[action.property].set(action.value, false, action.target,\r\n                                                           newState ? newState.$context: action.target.$context);\r\n        }\r\n        for (i in actions) {\r\n            var action = actions[i];\r\n            action.to = action.target[action.property];\r\n            if (action.explicit) {\r\n                action.target[action.property] = action.target[action.property]; //Remove binding\r\n                action.value = action.target[action.property];\r\n            }\r\n        }\r\n\r\n        // Find the best transition to use\r\n        var transition,\r\n            rating = 0;\r\n        for (var i = 0; i < this.transitions.length; i++) {\r\n            this.transitions[i].$stop(); // We need to stop running transitions, so let's do\r\n                                        // it while iterating through the transitions anyway\r\n            var curTransition = this.transitions[i],\r\n                curRating = 0;\r\n            if (curTransition.from == oldVal || curTransition.reversible && curTransition.from == newVal)\r\n                curRating += 2;\r\n            else if (curTransition.from == \"*\")\r\n                curRating++;\r\n            else\r\n                continue;\r\n            if (curTransition.to == newVal || curTransition.reversible && curTransition.to == oldVal)\r\n                curRating += 2;\r\n            else if (curTransition.to == \"*\")\r\n                curRating++;\r\n            else\r\n                continue;\r\n            if (curRating > rating) {\r\n                rating = curRating;\r\n                transition = curTransition;\r\n            }\r\n        }\r\n        if (transition)\r\n            transition.$start(actions);\r\n    });\r\n\r\n    var QMLRotation  = getConstructor('QtQuick', '2.0', 'Rotation');\r\n    var QMLScale     = getConstructor('QtQuick', '2.0', 'Scale');\r\n    var QMLTranslate = getConstructor('QtQuick', '2.0', 'Translate');\r\n\r\n    this.$updateTransform = function() {\r\n            var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\r\n            var filter = \"\";\r\n            var transformStyle = \"preserve-3d\";\r\n\r\n            for (var i = 0; i < this.transform.length; i++) {\r\n                var t = this.transform[i];\r\n                if (t instanceof QMLRotation)\r\n                    transform += \" rotate3d(\" + t.axis.x + \", \" + t.axis.y + \", \" + t.axis.z + \", \" + t.angle + \"deg)\";\r\n                else if (t instanceof QMLScale)\r\n                    transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\r\n                else if (t instanceof QMLTranslate)\r\n                    transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\r\n                else if (typeof t.transformType != 'undefined') {\r\n                    if (t.transformType == 'filter')\r\n                      filter += t.operation + '(' + t.parameters + ') ';\r\n                }\r\n                else if (typeof t == 'string')\r\n                    transform += t;\r\n            }\r\n            if (typeof this.z == \"number\")\r\n              transform += \" translate3d(0, 0, \" + this.z + \"px)\";\r\n            this.dom.style.transform = transform;\r\n            this.dom.style.transformStyle = transformStyle;\r\n            this.dom.style.MozTransform = transform;    // Firefox\r\n            this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\r\n            this.dom.style.webkitTransformStyle = transformStyle;\r\n            this.dom.style.OTransform = transform;      // Opera\r\n            this.dom.style.msTransform = transform;     // IE\r\n            this.dom.style.filter = filter;\r\n            this.dom.style.msFilter = filter;     // IE\r\n            this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\r\n            this.dom.style.MozFilter = filter;    // Firefox\r\n    }\r\n    this.rotationChanged.connect(this, this.$updateTransform);\r\n    this.scaleChanged.connect(this, this.$updateTransform);\r\n    this.transformChanged.connect(this, this.$updateTransform);\r\n    this.visibleChanged.connect(this, function(newVal) {\r\n        this.css.visibility = newVal ? \"inherit\" : \"hidden\";\r\n    });\r\n    this.opacityChanged.connect(this, function(newVal) {\r\n        this.css.opacity = newVal;\r\n    });\r\n    this.clipChanged.connect(this, function(newVal) {\r\n        this.css.overflow = newVal ? \"hidden\" : \"visible\";\r\n    });\r\n    this.zChanged.connect(this, function(newVal) {\r\n        this.$updateTransform();\r\n    });\r\n    this.xChanged.connect(this, function(newVal) {\r\n        this.css.left = newVal + \"px\";\r\n    });\r\n    this.yChanged.connect(this, function(newVal) {\r\n        this.css.top = newVal + \"px\";\r\n    });\r\n    this.widthChanged.connect(this, function(newVal) {\r\n        this.css.width = newVal ? newVal + \"px\" : \"auto\";\r\n    });\r\n    this.heightChanged.connect(this, function(newVal) {\r\n        this.css.height = newVal ? newVal + \"px\" : \"auto\";\r\n    });\r\n\r\n    this.implicitHeight = 0;\r\n    this.implicitWidth = 0;\r\n    this.spacing = 0;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.anchors.margins = 0;\r\n    this.visible = true;\r\n    this.opacity = 1;\r\n    this.$revertActions = [];\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.state = \"\";\r\n    this.transform = [];\r\n    this.rotation = 0;\r\n    this.scale = 1;\r\n\r\n    // Init size of root element\r\n    if (this.$parent === null) {\r\n        if (engine.rootElement == undefined) {\r\n            window.onresize = function() {\r\n                self.implicitHeight = window.innerHeight;\r\n                self.implicitWidth = window.innerWidth;\r\n            }\r\n            window.onresize();\r\n        } else {\r\n            this.implicitHeight = this.dom.offsetHeight;\r\n            this.implicitWidth = this.dom.offsetWidth;\r\n        }\r\n    }\r\n\r\n    this.$draw = function(c) {\r\n        var i;\r\n        if (this.visible !== false) { // Undefined means inherit, means true\r\n            if (this.$drawItem ) {\r\n                var rotRad = (this.rotation || 0) / 180 * Math.PI,\r\n                    rotOffsetX = Math.sin(rotRad) * this.width,\r\n                    rotOffsetY = Math.sin(rotRad) * this.height;\r\n                c.save();\r\n\r\n                // Handle rotation\r\n                // todo: implement transformOrigin\r\n                c.globalAlpha = this.opacity;\r\n                c.translate(this.left + rotOffsetX, this.top + rotOffsetY);\r\n                c.rotate(rotRad);\r\n                c.translate(-this.left, -this.top);\r\n                // Leave offset for drawing...\r\n                this.$drawItem(c);\r\n                c.translate(-rotOffsetX, -rotOffsetY);\r\n                c.restore();\r\n            }\r\n            for (i = 0; i < this.children.length; i++) {\r\n                if (this.children[i]\r\n                    && this.children[i].$draw) {\r\n                    this.children[i].$draw(c);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\ninherit(QMLItem, QMLBaseObject);\r\n\r\nconstructors['Item'] = QMLItem;\r\n\n\nfunction QMLList(meta) {\r\n    var list = [];\r\n    if (meta.object instanceof Array)\r\n        for (var i in meta.object)\r\n            list.push(construct({object: meta.object[i], parent: meta.parent, context: meta.context }));\r\n    else if (meta.object instanceof QMLMetaElement)\r\n        list.push(construct({object: meta.object, parent: meta.parent, context: meta.context }));\r\n\r\n    return list;\r\n}\r\n\nQMLOperationState = {\r\n    Idle: 1,\r\n    Init: 2,\r\n    Running: 3\r\n};\r\n\nfunction QMLPositioner(meta) {\r\n    QMLItem.call(this, meta);\r\n\r\n    createSimpleProperty(\"int\", this, \"spacing\");\r\n    this.spacingChanged.connect(this, this.layoutChildren);\r\n    this.childrenChanged.connect(this, this.layoutChildren);\r\n    this.childrenChanged.connect(this, QMLPositioner.slotChildrenChanged);\r\n\r\n    this.spacing = 0;\r\n}\r\ninherit(QMLPositioner, QMLItem);\r\n\r\nQMLPositioner.slotChildrenChanged = function() {\r\n    for (var i = 0; i < this.children.length; i++) {\r\n        var child = this.children[i];\r\n        if (!child.widthChanged.isConnected(this, this.layoutChildren))\r\n            child.widthChanged.connect(this, this.layoutChildren);\r\n        if (!child.heightChanged.isConnected(this, this.layoutChildren))\r\n            child.heightChanged.connect(this, this.layoutChildren);\r\n        if (!child.visibleChanged.isConnected(this, this.layoutChildren))\r\n            child.visibleChanged.connect(this, this.layoutChildren);\r\n        if (!child.opacityChanged.isConnected(this, this.layoutChildren))\r\n            child.opacityChanged.connect(this, this.layoutChildren);\r\n    }\r\n}\r\n\r\n\nfunction QMLProperty(type, obj, name) {\r\n    this.obj = obj;\r\n    this.name = name;\r\n    this.changed = Signal([], {obj:obj});\r\n    this.binding = null;\r\n    this.objectScope = null;\r\n    this.componentScope = null;\r\n    this.value = undefined;\r\n    this.type = type;\r\n    this.animation = null;\r\n\r\n    // This list contains all signals that hold references to this object.\r\n    // It is needed when deleting, as we need to tidy up all references to this object.\r\n    this.$tidyupList = [];\r\n}\r\n\r\n// Updater recalculates the value of a property if one of the\r\n// dependencies changed\r\nQMLProperty.prototype.update = function() {\r\n    if (!this.binding)\r\n        return;\r\n\r\n    var oldVal = this.val;\r\n    evaluatingProperty = this;\r\n    this.val = this.binding.eval(this.objectScope, this.componentScope);\r\n    evaluatingProperty = undefined;\r\n\r\n    if (this.animation) {\r\n        this.animation.$actions = [{\r\n            target: this.animation.target || this.obj,\r\n            property: this.animation.property || this.name,\r\n            from: this.animation.from || oldVal,\r\n            to: this.animation.to || this.val\r\n        }];\r\n        this.animation.restart();\r\n    }\r\n\r\n    if (this.val !== oldVal)\r\n        this.changed(this.val, oldVal, this.name);\r\n}\r\n\r\n// Define getter\r\nQMLProperty.prototype.get = function() {\r\n    // If this call to the getter is due to a property that is dependant on this\r\n    // one, we need it to take track of changes\r\n    if (evaluatingProperty && !this.changed.isConnected(evaluatingProperty, QMLProperty.prototype.update))\r\n        this.changed.connect(evaluatingProperty, QMLProperty.prototype.update);\r\n\r\n    return this.val;\r\n}\r\n\r\n// Define setter\r\nQMLProperty.prototype.set = function(newVal, fromAnimation, objectScope, componentScope) {\r\n    var i,\r\n        oldVal = this.val;\r\n\r\n    if (newVal instanceof QMLBinding) {\r\n        if (!objectScope || !componentScope)\r\n            throw \"Internal error: binding assigned without scope\";\r\n        this.binding = newVal;\r\n        this.objectScope = objectScope;\r\n        this.componentScope = componentScope;\r\n\r\n        if (engine.operationState !== QMLOperationState.Init) {\r\n            if (!newVal.eval)\r\n                newVal.compile();\r\n\r\n            evaluatingProperty = this;\r\n            newVal = this.binding.eval(objectScope, componentScope);\r\n            evaluatingProperty = null;\r\n        } else {\r\n            engine.bindedProperties.push(this);\r\n            return;\r\n        }\r\n    } else {\r\n        if (!fromAnimation)\r\n            this.binding = null;\r\n        if (newVal instanceof Array)\r\n            newVal = newVal.slice(); // Copies the array\r\n    }\r\n\r\n    if (constructors[this.type] == QMLList) {\r\n        this.val = QMLList({ object: newVal, parent: this.obj, context: componentScope });\r\n    } else if (newVal instanceof QMLMetaElement) {\r\n        if (constructors[newVal.$class] == QMLComponent || constructors[this.type] == QMLComponent)\r\n            this.val = new QMLComponent({ object: newVal, parent: this.obj, context: componentScope });\r\n        else\r\n            this.val = construct({ object: newVal, parent: this.obj, context: componentScope });\r\n    } else if (newVal instanceof Object || !newVal) {\r\n        this.val = newVal;\r\n    } else {\r\n        this.val = constructors[this.type](newVal);\r\n    }\r\n\r\n    if (this.val !== oldVal) {\r\n        if (this.animation && !fromAnimation) {\r\n            this.animation.running = false;\r\n            this.animation.$actions = [{\r\n                target: this.animation.target || this.obj,\r\n                property: this.animation.property || this.name,\r\n                from: this.animation.from || oldVal,\r\n                to: this.animation.to || this.val\r\n            }];\r\n            this.animation.running = true;\r\n        }\r\n        if (this.obj.$syncPropertyToRemote instanceof Function && !fromAnimation) { // is a remote object from e.g. a QWebChannel\r\n            this.obj.$syncPropertyToRemote(this.name, newVal);\r\n        } else {\r\n            this.changed(this.val, oldVal, this.name);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\nfunction QMLPropertyChanges(meta) {\r\n    QMLBaseObject.call(this, meta);\r\n\r\n    createSimpleProperty(\"QtObject\", this, \"target\");\r\n    createSimpleProperty(\"bool\", this, \"explicit\");\r\n    createSimpleProperty(\"bool\", this, \"restoreEntryValues\");\r\n\r\n    this.explicit = false;\r\n    this.restoreEntryValues = true;\r\n    this.$actions = [];\r\n\r\n    this.$setCustomData = function(propName, value) {\r\n        this.$actions.push({\r\n            property: propName,\r\n            value: value\r\n        });\r\n    }\r\n}\r\ninherit(QMLPropertyChanges, QMLBaseObject);\r\n\r\nregisterQmlType('PropertyChanges', QMLPropertyChanges);\r\n\nfunction QMLVariant(val) {\r\n    return val;\r\n}\r\n\n// Base object for all qml thingies\r\nvar objectIds = 0;\r\nfunction QObject(parent) {\r\n    this.$parent = parent;\r\n    if (parent && parent.$tidyupList)\r\n        parent.$tidyupList.push(this);\r\n    // List of things to tidy up when deleting this object.\r\n    this.$tidyupList = [];\r\n    this.$properties = {};\r\n\r\n    this.objectId = objectIds++;\r\n    this.$delete = function() {\r\n        if (this.$Component)\r\n          this.$Component.destruction();\r\n\r\n        while (this.$tidyupList.length > 0) {\r\n            var item = this.$tidyupList[0];\r\n            if (item.$delete) // It's a QObject\r\n                item.$delete();\r\n            else // It must be a signal\r\n                item.disconnect(this);\r\n        }\r\n\r\n        for (var i in this.$properties) {\r\n            var prop = this.$properties[i];\r\n            while (prop.$tidyupList.length > 0)\r\n                prop.$tidyupList[0].disconnect(prop);\r\n        }\r\n\r\n        if (this.$parent && this.$parent.$tidyupList)\r\n            this.$parent.$tidyupList.splice(this.$parent.$tidyupList.indexOf(this), 1);\r\n\r\n        // must do this:\r\n        // 1) parent will be notified and erase object from it's children.\r\n        // 2) DOM node will be removed.\r\n        this.parent = undefined;\r\n    }\r\n}\r\n\nfunction updateHGeometry(newVal, oldVal, propName) {\r\n    var anchors = this.anchors || this;\r\n    if (this.$updatingGeometry)\r\n        return;\r\n    this.$updatingGeometry = true;\r\n\r\n    var t, w, width, x, left, hC, right,\r\n        lM = anchors.leftMargin || anchors.margins,\r\n        rM = anchors.rightMargin || anchors.margins;\r\n\r\n    // Width\r\n    if (this.$isUsingImplicitWidth && propName == \"implicitWidth\")\r\n        width = this.implicitWidth;\r\n    else if (propName == \"width\")\r\n        this.$isUsingImplicitWidth = false;\r\n\r\n    // Position TODO: Layouts\r\n    if ((t = anchors.fill) !== undefined) {\r\n        if (!t.$properties.left.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.left.changed.connect(this, updateHGeometry);\r\n        if (!t.$properties.width.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.width.changed.connect(this, updateHGeometry);\r\n\r\n        this.$isUsingImplicitWidth = false;\r\n        width = t.width - lM - rM;\r\n        x = t.left - (this.parent ? this.parent.left : 0) + lM;\r\n        left = t.left + lM;\r\n        right = t.right - rM;\r\n        hC = (left + right) / 2;\r\n    } else if ((t = anchors.centerIn) !== undefined) {\r\n        if (!t.$properties.horizontalCenter.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.horizontalCenter.changed.connect(this, updateHGeometry);\r\n\r\n        w = width || this.width;\r\n        hC = t.horizontalCenter;\r\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\r\n        left = hC - w / 2;\r\n        right = hC + w / 2;\r\n    } else if ((t = anchors.left) !== undefined) {\r\n        left = t + lM\r\n        if ((u = anchors.right) !== undefined) {\r\n            right = u - rM;\r\n            this.$isUsingImplicitWidth = false;\r\n            width = right - left;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            hC = (right + left) / 2;\r\n        } else if ((hC = anchors.horizontalCenter) !== undefined) {\r\n            this.$isUsingImplicitWidth = false;\r\n            width = (hC - left) * 2;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            right = 2 * hC - left;\r\n        } else {\r\n            w = width || this.width;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            right = left + w;\r\n            hC = left + w / 2;\r\n        }\r\n    } else if ((t = anchors.right) !== undefined) {\r\n        right = t - rM;\r\n        if ((hC = anchors.horizontalCenter) !== undefined) {\r\n            this.$isUsingImplicitWidth = false;\r\n            width = (right - hC) * 2;\r\n            x = 2 * hC - right - (this.parent ? this.parent.left : 0);\r\n            left = 2 * hC - right;\r\n        } else {\r\n            w = width || this.width;\r\n            x = right - w - (this.parent ? this.parent.left : 0);\r\n            left = right - w;\r\n            hC = right - w / 2;\r\n        }\r\n    } else if ((hC = anchors.horizontalCenter) !== undefined) {\r\n        w = width || this.width;\r\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\r\n        left = hC - w / 2;\r\n        right = hC + w / 2;\r\n    } else {\r\n        if (this.parent && !this.parent.$properties.left.changed.isConnected(this, updateHGeometry))\r\n            this.parent.$properties.left.changed.connect(this, updateHGeometry);\r\n\r\n        w = width || this.width;\r\n        left = this.x + (this.parent ? this.parent.left : 0);\r\n        right = left + w;\r\n        hC = left + w / 2;\r\n    }\r\n\r\n    if (left !== undefined)\r\n        this.left = left;\r\n    if (hC !== undefined)\r\n        this.horizontalCenter = hC;\r\n    if (right !== undefined)\r\n        this.right = right;\r\n    if (x !== undefined)\r\n        this.x = x;\r\n    if (width !== undefined)\r\n        this.width = width;\r\n\r\n    this.$updatingGeometry = false;\r\n}\r\n\r\nfunction updateVGeometry(newVal, oldVal, propName) {\r\n    var anchors = this.anchors || this;\r\n    if (this.$updatingGeometry)\r\n        return;\r\n    this.$updatingGeometry = true;\r\n\r\n    var t, w, height, y, top, vC, bottom,\r\n        tM = anchors.topMargin || anchors.margins,\r\n        bM = anchors.bottomMargin || anchors.margins;\r\n\r\n    // Height\r\n    if (this.$isUsingImplicitHeight && propName == \"implicitHeight\")\r\n        height = this.implicitHeight;\r\n    else if (propName == \"height\")\r\n        this.$isUsingImplicitHeight = false;\r\n\r\n    // Position TODO: Layouts\r\n    if ((t = anchors.fill) !== undefined) {\r\n        if (!t.$properties.top.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.top.changed.connect(this, updateVGeometry);\r\n        if (!t.$properties.height.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.height.changed.connect(this, updateVGeometry);\r\n\r\n        this.$isUsingImplicitHeight = false;\r\n        height = t.height - tM - bM;\r\n        y = t.top - (this.parent ? this.parent.top : 0) + tM;\r\n        top = t.top + tM;\r\n        bottom = t.bottom - bM;\r\n        vC = (top + bottom) / 2;\r\n    } else if ((t = anchors.centerIn) !== undefined) {\r\n        if (!t.$properties.verticalCenter.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.verticalCenter.changed.connect(this, updateVGeometry);\r\n\r\n        w = height || this.height;\r\n        vC = t.verticalCenter;\r\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\r\n        top = vC - w / 2;\r\n        bottom = vC + w / 2;\r\n    } else if ((t = anchors.top) !== undefined) {\r\n        top = t + tM\r\n        if ((u = anchors.bottom) !== undefined) {\r\n            bottom = u - bM;\r\n            this.$isUsingImplicitHeight = false;\r\n            height = bottom - top;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            vC = (bottom + top) / 2;\r\n        } else if ((vC = anchors.verticalCenter) !== undefined) {\r\n            this.$isUsingImplicitHeight = false;\r\n            height = (vC - top) * 2;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            bottom = 2 * vC - top;\r\n        } else {\r\n            w = height || this.height;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            bottom = top + w;\r\n            vC = top + w / 2;\r\n        }\r\n    } else if ((t = anchors.bottom) !== undefined) {\r\n        bottom = t - bM;\r\n        if ((vC = anchors.verticalCenter) !== undefined) {\r\n            this.$isUsingImplicitHeight = false;\r\n            height = (bottom - vC) * 2;\r\n            y = 2 * vC - bottom - (this.parent ? this.parent.top : 0);\r\n            top = 2 * vC - bottom;\r\n        } else {\r\n            w = height || this.height;\r\n            y = bottom - w - (this.parent ? this.parent.top : 0);\r\n            top = bottom - w;\r\n            vC = bottom - w / 2;\r\n        }\r\n    } else if ((vC = anchors.verticalCenter) !== undefined) {\r\n        w = height || this.height;\r\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\r\n        top = vC - w / 2;\r\n        bottom = vC + w / 2;\r\n    } else {\r\n        if (this.parent && !this.parent.$properties.top.changed.isConnected(this, updateVGeometry))\r\n            this.parent.$properties.top.changed.connect(this, updateVGeometry);\r\n\r\n        w = height || this.height;\r\n        top = this.y + (this.parent ? this.parent.top : 0);\r\n        bottom = top + w;\r\n        vC = top + w / 2;\r\n    }\r\n\r\n    if (top !== undefined)\r\n        this.top = top;\r\n    if (vC !== undefined)\r\n        this.verticalCenter = vC;\r\n    if (bottom !== undefined)\r\n        this.bottom = bottom;\r\n    if (y !== undefined)\r\n        this.y = y;\r\n    if (height !== undefined)\r\n        this.height = height;\r\n\r\n    this.$updatingGeometry = false;\r\n}\r\n\r\n\r\n\nregisterQmlType({\r\n  module:   'QmlWeb',\r\n  name:     'RestModel',\r\n  versions: /.*/,\r\n  baseClass: QMLItem,\r\n  constructor: function QMLRestModel(meta) {\r\n    QMLItem.call(this, meta);\r\n    var self = this;\r\n    var attributes = this.getAttributes();\r\n\r\n    createSimpleProperty(\"string\", this, \"url\");\r\n    createSimpleProperty(\"bool\",   this, \"isLoading\");\r\n    createSimpleProperty(\"string\", this, \"mimeType\");\r\n    createSimpleProperty(\"string\", this, \"queryMimeType\");\r\n\r\n    this.mimeType      = \"application/json\";\r\n    this.queryMimeType = \"application/x-www-urlencoded\";\r\n    this.isLoading     = false;\r\n    this.attributes    = attributes;\r\n\r\n    this.fetched = Signal();\r\n    this.saved   = Signal();\r\n\r\n    this.runningRequests = 0;\r\n\r\n    this.fetch = function() {\r\n      ajax({\r\n        method:   'GET',\r\n        mimeType: self.mimetype,\r\n        success: function(xhr) {\r\n          xhrReadResponse(xhr);\r\n          self.fetched();\r\n        }\r\n      });\r\n    };\r\n\r\n    this.create = function() {\r\n      sendToServer('POST');\r\n    };\r\n\r\n    this.save = function() {\r\n      sendToServer('PUT');\r\n    };\r\n\r\n    function sendToServer(method) {\r\n      var body = generateBodyForPostQuery();\r\n\r\n      ajax({\r\n        method:   method,\r\n        mimeType: self.queryMimeType,\r\n        body:     body,\r\n        success:  function(xhr) {\r\n          xhrReadResponse(xhr);\r\n          self.saved();\r\n        }\r\n      });\r\n    }\r\n\r\n    this.remove = function() {\r\n      ajax({\r\n        method: 'DELETE',\r\n        success: function(xhr) {\r\n          self.destroy();\r\n        }\r\n      });\r\n    };\r\n\r\n    function generateBodyForPostQuery() {\r\n      var object     = {};\r\n      var body;\r\n\r\n      for (var i = 0 ; i < self.attributes.length ; ++i)\r\n        object[self.attributes[i]] = self.$properties[self.attributes[i]].get();\r\n      console.log(object);\r\n      if (self.queryMimeType == 'application/json' || self.queryMimeType == 'text/json')\r\n        body = JSON.stringify(object);\r\n      else if (self.queryMimeType == 'application/x-www-urlencoded')\r\n        body = objectToUrlEncoded(object);\r\n      return body;\r\n    }\r\n\r\n    function myEncodeURIComponent(str) {\r\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\r\n        return '%' + c.charCodeAt(0).toString(16);\r\n      });\r\n    }\r\n\r\n    function objectToUrlEncoded(object, prefix) {\r\n      var str = '';\r\n      for (var key in object) {\r\n        if (object.hasOwnProperty(key)) {\r\n          var value = object[key];\r\n          if (str != '')\r\n            str += '&';\r\n          if (typeof prefix != 'undefined')\r\n            key  = prefix + '[' + key + ']';\r\n          if (typeof value == 'object')\r\n            str += objectToUrlEncoded(value, key);\r\n          else\r\n            str += myEncodeURIComponent(key) + '=' + myEncodeURIComponent(value);\r\n        }\r\n      }\r\n      return str;\r\n    }\r\n\r\n    function ajax(options) {\r\n      var xhr = new XMLHttpRequest();\r\n\r\n      xhr.overrideMimeType(self.mimeType);\r\n      xhr.onreadystatechange = function() {\r\n        if (xhr.readyState == XMLHttpRequest.DONE) {\r\n          if (xhr.status == 200)\r\n            options.success(xhr);\r\n          else\r\n            options.failure(xhr);\r\n          self.runningRequests -= 1;\r\n          if (self.runningRequests <= 0)\r\n            self.isLoading = false;\r\n        }\r\n      }\r\n      xhr.open(options.method, self.url, true);\r\n      if (typeof options.body != 'undefined') {\r\n        xhr.setRequestHeader('Content-Type', self.queryMimeType);\r\n        xhr.send(options.body);\r\n      }\r\n      else\r\n        xhr.send(null);\r\n      self.runningRequests += 1;\r\n      self.isLoading = true;\r\n    }\r\n\r\n    function xhrReadResponse(xhr) {\r\n      var responseObject;\r\n\r\n      if (self.mimeType == 'application/json' || self.mimeType == 'text/json') {\r\n        responseObject = JSON.parse(xhr.responseText);\r\n      }\r\n      updatePropertiesFromResponseObject(responseObject);\r\n    }\r\n\r\n    function updatePropertiesFromResponseObject(responseObject) {\r\n      for (var key in responseObject) {\r\n        if (responseObject.hasOwnProperty(key) && self.$hasProperty(key)) {\r\n          self.$properties[key].set(responseObject[key]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.$hasProperty = function(name) {\r\n      return (typeof self.$properties[name] != 'undefined');\r\n    }\r\n  }\r\n});\r\n\nregisterQmlType({\r\n  module: 'QtQuick',\r\n  name:   'Settings',\r\n  versions: /.*/,\r\n  baseClass: QMLItem,\r\n  constructor: function QMLSettings(meta) {\r\n    QMLItem.call(this, meta);\r\n\r\n    createSimpleProperty(\"string\", this, \"category\");\r\n\r\n    if (typeof window.localStorage == 'undefined')\r\n      return ;\r\n\r\n    var attributes;\r\n\r\n    var getKey = (function(attrName) {\r\n      return this.category + '/' + attrName;\r\n    }).bind(this);\r\n\r\n    var loadProperties = (function() {\r\n      for (var i = 0 ; i < attributes.length ; ++i) {\r\n        this[attributes[i]] = localStorage.getItem(getKey(attributes[i]));\r\n      }\r\n    }).bind(this);\r\n\r\n    var initializeProperties = (function() {\r\n      for (var i = 0 ; i < attributes.length ; ++i) {\r\n        var attrName   = attributes[i];\r\n        var signalName = attrName + 'Changed';\r\n        var emitter    = this;\r\n\r\n        if (this.$properties[attrName].type == 'alias') {\r\n          emitter    = this.$context[this.$properties[attrName].val.objectName];\r\n          signalName = this.$properties[attrName].val.propertyName + 'Changed';\r\n        }\r\n        emitter[signalName].connect(this, (function() {\r\n          localStorage.setItem(getKey(this.attrName), this.self[this.attrName]);\r\n        }).bind({ self: this, attrName: attrName }));\r\n      }\r\n    }).bind(this);\r\n\r\n    this.Component.completed.connect(this, (function() {\r\n      attributes = this.getAttributes();\r\n      loadProperties();\r\n      initializeProperties();\r\n    }).bind(this));\r\n  }\r\n});\r\n\n})(typeof global != 'undefined' ? global : typeof window != 'undefined' ? window : this);","(function(global){\r\n\n/**\r\n * Create QML binding.\r\n * @param {Variant} val Sourcecode or function representing the binding\r\n * @param {Array} tree Parser tree of the binding\r\n * @return {Object} Object representing the binding\r\n */\r\nglobal.QMLBinding = function(val, tree) {\r\n    // this.function states whether the binding is a simple js statement or a function containing a\r\n    // return statement. We decide this on whether it is a code block or not. If it is, we require a\r\n    // return statement. If it is a code block it could though also be a object definition, so we\r\n    // need to check that as well (it is, if the content is labels).\r\n    this.function = tree && tree[0] == \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\r\n    this.src = val;\r\n}\r\n\r\nglobal.QMLBinding.prototype.toJSON = function() {\r\n    return {src: this.src,\r\n        deps: JSON.stringify(this.deps),\r\n        tree: JSON.stringify(this.tree) };\r\n}\r\n\r\n/**\r\n * Compile binding. Afterwards you may call binding.eval to evaluate.\r\n */\r\nQMLBinding.prototype.compile = function() {\r\n    this.eval = new Function('__executionObject', '__executionContext', \"with(__executionContext) with(__executionObject) \" + ( this.function ? \"\" : \"return \" ) + this.src);\r\n}\r\n\n/***********************************************************************\r\n\r\n  A JavaScript tokenizer / parser / beautifier / compressor.\r\n  https://github.com/mishoo/UglifyJS2\r\n\r\n  -------------------------------- (C) ---------------------------------\r\n\r\n                           Author: Mihai Bazon\r\n                         <mihai.bazon@gmail.com>\r\n                       http://mihai.bazon.net/blog\r\n\r\n  Distributed under the BSD license:\r\n\r\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions\r\n    are met:\r\n\r\n        * Redistributions of source code must retain the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer.\r\n\r\n        * Redistributions in binary form must reproduce the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer in the documentation and/or other materials\r\n          provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n    SUCH DAMAGE.\r\n\r\n ***********************************************************************/\r\n\r\n\"use strict\";\r\n\r\nfunction DEFNODE(type, props, methods, base) {\r\n    if (arguments.length < 4) base = AST_Node;\r\n    if (!props) props = [];\r\n    else props = props.split(/\\s+/);\r\n    var self_props = props;\r\n    if (base && base.PROPS)\r\n        props = props.concat(base.PROPS);\r\n    var code = \"return function AST_\" + type + \"(props){ if (props) { \";\r\n    for (var i = props.length; --i >= 0;) {\r\n        code += \"this.\" + props[i] + \" = props.\" + props[i] + \";\";\r\n    }\r\n    var proto = base && new base;\r\n    if (proto && proto.initialize || (methods && methods.initialize))\r\n        code += \"this.initialize();\";\r\n    code += \"}}\";\r\n    var ctor = new Function(code)();\r\n    if (proto) {\r\n        ctor.prototype = proto;\r\n        ctor.BASE = base;\r\n    }\r\n    if (base) base.SUBCLASSES.push(ctor);\r\n    ctor.prototype.CTOR = ctor;\r\n    ctor.PROPS = props || null;\r\n    ctor.SELF_PROPS = self_props;\r\n    ctor.SUBCLASSES = [];\r\n    if (type) {\r\n        ctor.prototype.TYPE = ctor.TYPE = type;\r\n    }\r\n    if (methods) for (i in methods) if (methods.hasOwnProperty(i)) {\r\n        if (/^\\$/.test(i)) {\r\n            ctor[i.substr(1)] = methods[i];\r\n        } else {\r\n            ctor.prototype[i] = methods[i];\r\n        }\r\n    }\r\n    ctor.DEFMETHOD = function(name, method) {\r\n        this.prototype[name] = method;\r\n    };\r\n    return ctor;\r\n};\r\n\r\nvar AST_Token = DEFNODE(\"Token\", \"type value line col pos endline endcol endpos nlb comments_before file\", {\r\n}, null);\r\n\r\nvar AST_Node = DEFNODE(\"Node\", \"start end\", {\r\n    clone: function() {\r\n        return new this.CTOR(this);\r\n    },\r\n    $documentation: \"Base class of all AST nodes\",\r\n    $propdoc: {\r\n        start: \"[AST_Token] The first token of this node\",\r\n        end: \"[AST_Token] The last token of this node\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this);\r\n    },\r\n    walk: function(visitor) {\r\n        return this._walk(visitor); // not sure the indirection will be any help\r\n    }\r\n}, null);\r\n\r\nAST_Node.warn_function = null;\r\nAST_Node.warn = function(txt, props) {\r\n    if (AST_Node.warn_function)\r\n        AST_Node.warn_function(string_template(txt, props));\r\n};\r\n\r\n/* -----[ statements ]----- */\r\n\r\nvar AST_Statement = DEFNODE(\"Statement\", null, {\r\n    $documentation: \"Base class of all statements\",\r\n});\r\n\r\nvar AST_Debugger = DEFNODE(\"Debugger\", null, {\r\n    $documentation: \"Represents a debugger statement\",\r\n}, AST_Statement);\r\n\r\nvar AST_Directive = DEFNODE(\"Directive\", \"value scope quote\", {\r\n    $documentation: \"Represents a directive, like \\\"use strict\\\";\",\r\n    $propdoc: {\r\n        value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\r\n        scope: \"[AST_Scope/S] The scope that this directive affects\",\r\n        quote: \"[string] the original quote character\"\r\n    },\r\n}, AST_Statement);\r\n\r\nvar AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\r\n    $documentation: \"A statement consisting of an expression, i.e. a = 1 + 2\",\r\n    $propdoc: {\r\n        body: \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_Statement);\r\n\r\nfunction walk_body(node, visitor) {\r\n    if (node.body instanceof AST_Statement) {\r\n        node.body._walk(visitor);\r\n    }\r\n    else node.body.forEach(function(stat){\r\n        stat._walk(visitor);\r\n    });\r\n};\r\n\r\nvar AST_Block = DEFNODE(\"Block\", \"body\", {\r\n    $documentation: \"A body of statements (usually bracketed)\",\r\n    $propdoc: {\r\n        body: \"[AST_Statement*] an array of statements\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            walk_body(this, visitor);\r\n        });\r\n    }\r\n}, AST_Statement);\r\n\r\nvar AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\r\n    $documentation: \"A block statement\",\r\n}, AST_Block);\r\n\r\nvar AST_EmptyStatement = DEFNODE(\"EmptyStatement\", null, {\r\n    $documentation: \"The empty statement (empty block or simply a semicolon)\",\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this);\r\n    }\r\n}, AST_Statement);\r\n\r\nvar AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\r\n    $documentation: \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\r\n    $propdoc: {\r\n        body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_Statement);\r\n\r\nvar AST_LabeledStatement = DEFNODE(\"LabeledStatement\", \"label\", {\r\n    $documentation: \"Statement with a label\",\r\n    $propdoc: {\r\n        label: \"[AST_Label] a label definition\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.label._walk(visitor);\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_StatementWithBody);\r\n\r\nvar AST_IterationStatement = DEFNODE(\"IterationStatement\", null, {\r\n    $documentation: \"Internal class.  All loops inherit from it.\"\r\n}, AST_StatementWithBody);\r\n\r\nvar AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\r\n    $documentation: \"Base class for do/while statements\",\r\n    $propdoc: {\r\n        condition: \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\r\n    }\r\n}, AST_IterationStatement);\r\n\r\nvar AST_Do = DEFNODE(\"Do\", null, {\r\n    $documentation: \"A `do` statement\",\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.body._walk(visitor);\r\n            this.condition._walk(visitor);\r\n        });\r\n    }\r\n}, AST_DWLoop);\r\n\r\nvar AST_While = DEFNODE(\"While\", null, {\r\n    $documentation: \"A `while` statement\",\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.condition._walk(visitor);\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_DWLoop);\r\n\r\nvar AST_For = DEFNODE(\"For\", \"init condition step\", {\r\n    $documentation: \"A `for` statement\",\r\n    $propdoc: {\r\n        init: \"[AST_Node?] the `for` initialization code, or null if empty\",\r\n        condition: \"[AST_Node?] the `for` termination clause, or null if empty\",\r\n        step: \"[AST_Node?] the `for` update clause, or null if empty\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            if (this.init) this.init._walk(visitor);\r\n            if (this.condition) this.condition._walk(visitor);\r\n            if (this.step) this.step._walk(visitor);\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_IterationStatement);\r\n\r\nvar AST_ForIn = DEFNODE(\"ForIn\", \"init name object\", {\r\n    $documentation: \"A `for ... in` statement\",\r\n    $propdoc: {\r\n        init: \"[AST_Node] the `for/in` initialization code\",\r\n        name: \"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var\",\r\n        object: \"[AST_Node] the object that we're looping through\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.init._walk(visitor);\r\n            this.object._walk(visitor);\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_IterationStatement);\r\n\r\nvar AST_With = DEFNODE(\"With\", \"expression\", {\r\n    $documentation: \"A `with` statement\",\r\n    $propdoc: {\r\n        expression: \"[AST_Node] the `with` expression\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n            this.body._walk(visitor);\r\n        });\r\n    }\r\n}, AST_StatementWithBody);\r\n\r\n/* -----[ scope and functions ]----- */\r\n\r\nvar AST_Scope = DEFNODE(\"Scope\", \"directives variables functions uses_with uses_eval parent_scope enclosed cname\", {\r\n    $documentation: \"Base class for all statements introducing a lexical scope\",\r\n    $propdoc: {\r\n        directives: \"[string*/S] an array of directives declared in this scope\",\r\n        variables: \"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\r\n        functions: \"[Object/S] like `variables`, but only lists function declarations\",\r\n        uses_with: \"[boolean/S] tells whether this scope uses the `with` statement\",\r\n        uses_eval: \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\r\n        parent_scope: \"[AST_Scope?/S] link to the parent scope\",\r\n        enclosed: \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\r\n        cname: \"[integer/S] current index for mangling variables (used internally by the mangler)\",\r\n    },\r\n}, AST_Block);\r\n\r\nvar AST_Toplevel = DEFNODE(\"Toplevel\", \"globals\", {\r\n    $documentation: \"The toplevel scope\",\r\n    $propdoc: {\r\n        globals: \"[Object/S] a map of name -> SymbolDef for all undeclared names\",\r\n    },\r\n    wrap_enclose: function(arg_parameter_pairs) {\r\n        var self = this;\r\n        var args = [];\r\n        var parameters = [];\r\n\r\n        arg_parameter_pairs.forEach(function(pair) {\r\n            var splitAt = pair.lastIndexOf(\":\");\r\n\r\n            args.push(pair.substr(0, splitAt));\r\n            parameters.push(pair.substr(splitAt + 1));\r\n        });\r\n\r\n        var wrapped_tl = \"(function(\" + parameters.join(\",\") + \"){ '$ORIG'; })(\" + args.join(\",\") + \")\";\r\n        wrapped_tl = parse(wrapped_tl);\r\n        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){\r\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\r\n                return MAP.splice(self.body);\r\n            }\r\n        }));\r\n        return wrapped_tl;\r\n    },\r\n    wrap_commonjs: function(name, export_all) {\r\n        var self = this;\r\n        var to_export = [];\r\n        if (export_all) {\r\n            self.figure_out_scope();\r\n            self.walk(new TreeWalker(function(node){\r\n                if (node instanceof AST_SymbolDeclaration && node.definition().global) {\r\n                    if (!find_if(function(n){ return n.name == node.name }, to_export))\r\n                        to_export.push(node);\r\n                }\r\n            }));\r\n        }\r\n        var wrapped_tl = \"(function(exports, global){ global['\" + name + \"'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))\";\r\n        wrapped_tl = parse(wrapped_tl);\r\n        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){\r\n            if (node instanceof AST_SimpleStatement) {\r\n                node = node.body;\r\n                if (node instanceof AST_String) switch (node.getValue()) {\r\n                  case \"$ORIG\":\r\n                    return MAP.splice(self.body);\r\n                  case \"$EXPORTS\":\r\n                    var body = [];\r\n                    to_export.forEach(function(sym){\r\n                        body.push(new AST_SimpleStatement({\r\n                            body: new AST_Assign({\r\n                                left: new AST_Sub({\r\n                                    expression: new AST_SymbolRef({ name: \"exports\" }),\r\n                                    property: new AST_String({ value: sym.name }),\r\n                                }),\r\n                                operator: \"=\",\r\n                                right: new AST_SymbolRef(sym),\r\n                            }),\r\n                        }));\r\n                    });\r\n                    return MAP.splice(body);\r\n                }\r\n            }\r\n        }));\r\n        return wrapped_tl;\r\n    }\r\n}, AST_Scope);\r\n\r\nvar AST_Lambda = DEFNODE(\"Lambda\", \"name argnames uses_arguments\", {\r\n    $documentation: \"Base class for functions\",\r\n    $propdoc: {\r\n        name: \"[AST_SymbolDeclaration?] the name of this function\",\r\n        argnames: \"[AST_SymbolFunarg*] array of function arguments\",\r\n        uses_arguments: \"[boolean/S] tells whether this function accesses the arguments array\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            if (this.name) this.name._walk(visitor);\r\n            this.argnames.forEach(function(arg){\r\n                arg._walk(visitor);\r\n            });\r\n            walk_body(this, visitor);\r\n        });\r\n    }\r\n}, AST_Scope);\r\n\r\nvar AST_Accessor = DEFNODE(\"Accessor\", null, {\r\n    $documentation: \"A setter/getter function.  The `name` property is always null.\"\r\n}, AST_Lambda);\r\n\r\nvar AST_Function = DEFNODE(\"Function\", null, {\r\n    $documentation: \"A function expression\"\r\n}, AST_Lambda);\r\n\r\nvar AST_Defun = DEFNODE(\"Defun\", null, {\r\n    $documentation: \"A function definition\"\r\n}, AST_Lambda);\r\n\r\n/* -----[ JUMPS ]----- */\r\n\r\nvar AST_Jump = DEFNODE(\"Jump\", null, {\r\n    $documentation: \"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)\"\r\n}, AST_Statement);\r\n\r\nvar AST_Exit = DEFNODE(\"Exit\", \"value\", {\r\n    $documentation: \"Base class for exits (`return` and `throw`)\",\r\n    $propdoc: {\r\n        value: \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, this.value && function(){\r\n            this.value._walk(visitor);\r\n        });\r\n    }\r\n}, AST_Jump);\r\n\r\nvar AST_Return = DEFNODE(\"Return\", null, {\r\n    $documentation: \"A `return` statement\"\r\n}, AST_Exit);\r\n\r\nvar AST_Throw = DEFNODE(\"Throw\", null, {\r\n    $documentation: \"A `throw` statement\"\r\n}, AST_Exit);\r\n\r\nvar AST_LoopControl = DEFNODE(\"LoopControl\", \"label\", {\r\n    $documentation: \"Base class for loop control statements (`break` and `continue`)\",\r\n    $propdoc: {\r\n        label: \"[AST_LabelRef?] the label, or null if none\",\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, this.label && function(){\r\n            this.label._walk(visitor);\r\n        });\r\n    }\r\n}, AST_Jump);\r\n\r\nvar AST_Break = DEFNODE(\"Break\", null, {\r\n    $documentation: \"A `break` statement\"\r\n}, AST_LoopControl);\r\n\r\nvar AST_Continue = DEFNODE(\"Continue\", null, {\r\n    $documentation: \"A `continue` statement\"\r\n}, AST_LoopControl);\r\n\r\n/* -----[ IF ]----- */\r\n\r\nvar AST_If = DEFNODE(\"If\", \"condition alternative\", {\r\n    $documentation: \"A `if` statement\",\r\n    $propdoc: {\r\n        condition: \"[AST_Node] the `if` condition\",\r\n        alternative: \"[AST_Statement?] the `else` part, or null if not present\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.condition._walk(visitor);\r\n            this.body._walk(visitor);\r\n            if (this.alternative) this.alternative._walk(visitor);\r\n        });\r\n    }\r\n}, AST_StatementWithBody);\r\n\r\n/* -----[ SWITCH ]----- */\r\n\r\nvar AST_Switch = DEFNODE(\"Switch\", \"expression\", {\r\n    $documentation: \"A `switch` statement\",\r\n    $propdoc: {\r\n        expression: \"[AST_Node] the `switch` discriminant\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n            walk_body(this, visitor);\r\n        });\r\n    }\r\n}, AST_Block);\r\n\r\nvar AST_SwitchBranch = DEFNODE(\"SwitchBranch\", null, {\r\n    $documentation: \"Base class for `switch` branches\",\r\n}, AST_Block);\r\n\r\nvar AST_Default = DEFNODE(\"Default\", null, {\r\n    $documentation: \"A `default` switch branch\",\r\n}, AST_SwitchBranch);\r\n\r\nvar AST_Case = DEFNODE(\"Case\", \"expression\", {\r\n    $documentation: \"A `case` switch branch\",\r\n    $propdoc: {\r\n        expression: \"[AST_Node] the `case` expression\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n            walk_body(this, visitor);\r\n        });\r\n    }\r\n}, AST_SwitchBranch);\r\n\r\n/* -----[ EXCEPTIONS ]----- */\r\n\r\nvar AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\r\n    $documentation: \"A `try` statement\",\r\n    $propdoc: {\r\n        bcatch: \"[AST_Catch?] the catch block, or null if not present\",\r\n        bfinally: \"[AST_Finally?] the finally block, or null if not present\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            walk_body(this, visitor);\r\n            if (this.bcatch) this.bcatch._walk(visitor);\r\n            if (this.bfinally) this.bfinally._walk(visitor);\r\n        });\r\n    }\r\n}, AST_Block);\r\n\r\nvar AST_Catch = DEFNODE(\"Catch\", \"argname\", {\r\n    $documentation: \"A `catch` node; only makes sense as part of a `try` statement\",\r\n    $propdoc: {\r\n        argname: \"[AST_SymbolCatch] symbol for the exception\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.argname._walk(visitor);\r\n            walk_body(this, visitor);\r\n        });\r\n    }\r\n}, AST_Block);\r\n\r\nvar AST_Finally = DEFNODE(\"Finally\", null, {\r\n    $documentation: \"A `finally` node; only makes sense as part of a `try` statement\"\r\n}, AST_Block);\r\n\r\n/* -----[ VAR/CONST ]----- */\r\n\r\nvar AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\r\n    $documentation: \"Base class for `var` or `const` nodes (variable declarations/initializations)\",\r\n    $propdoc: {\r\n        definitions: \"[AST_VarDef*] array of variable definitions\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.definitions.forEach(function(def){\r\n                def._walk(visitor);\r\n            });\r\n        });\r\n    }\r\n}, AST_Statement);\r\n\r\nvar AST_Var = DEFNODE(\"Var\", null, {\r\n    $documentation: \"A `var` statement\"\r\n}, AST_Definitions);\r\n\r\nvar AST_Const = DEFNODE(\"Const\", null, {\r\n    $documentation: \"A `const` statement\"\r\n}, AST_Definitions);\r\n\r\nvar AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\r\n    $documentation: \"A variable declaration; only appears in a AST_Definitions node\",\r\n    $propdoc: {\r\n        name: \"[AST_SymbolVar|AST_SymbolConst] name of the variable\",\r\n        value: \"[AST_Node?] initializer, or null of there's no initializer\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.name._walk(visitor);\r\n            if (this.value) this.value._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\n/* -----[ OTHER ]----- */\r\n\r\nvar AST_Call = DEFNODE(\"Call\", \"expression args\", {\r\n    $documentation: \"A function call expression\",\r\n    $propdoc: {\r\n        expression: \"[AST_Node] expression to invoke as function\",\r\n        args: \"[AST_Node*] array of arguments\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n            this.args.forEach(function(arg){\r\n                arg._walk(visitor);\r\n            });\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_New = DEFNODE(\"New\", null, {\r\n    $documentation: \"An object instantiation.  Derives from a function call since it has exactly the same properties\"\r\n}, AST_Call);\r\n\r\nvar AST_Seq = DEFNODE(\"Seq\", \"car cdr\", {\r\n    $documentation: \"A sequence expression (two comma-separated expressions)\",\r\n    $propdoc: {\r\n        car: \"[AST_Node] first element in sequence\",\r\n        cdr: \"[AST_Node] second element in sequence\"\r\n    },\r\n    $cons: function(x, y) {\r\n        var seq = new AST_Seq(x);\r\n        seq.car = x;\r\n        seq.cdr = y;\r\n        return seq;\r\n    },\r\n    $from_array: function(array) {\r\n        if (array.length == 0) return null;\r\n        if (array.length == 1) return array[0].clone();\r\n        var list = null;\r\n        for (var i = array.length; --i >= 0;) {\r\n            list = AST_Seq.cons(array[i], list);\r\n        }\r\n        var p = list;\r\n        while (p) {\r\n            if (p.cdr && !p.cdr.cdr) {\r\n                p.cdr = p.cdr.car;\r\n                break;\r\n            }\r\n            p = p.cdr;\r\n        }\r\n        return list;\r\n    },\r\n    to_array: function() {\r\n        var p = this, a = [];\r\n        while (p) {\r\n            a.push(p.car);\r\n            if (p.cdr && !(p.cdr instanceof AST_Seq)) {\r\n                a.push(p.cdr);\r\n                break;\r\n            }\r\n            p = p.cdr;\r\n        }\r\n        return a;\r\n    },\r\n    add: function(node) {\r\n        var p = this;\r\n        while (p) {\r\n            if (!(p.cdr instanceof AST_Seq)) {\r\n                var cell = AST_Seq.cons(p.cdr, node);\r\n                return p.cdr = cell;\r\n            }\r\n            p = p.cdr;\r\n        }\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.car._walk(visitor);\r\n            if (this.cdr) this.cdr._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_PropAccess = DEFNODE(\"PropAccess\", \"expression property\", {\r\n    $documentation: \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\r\n    $propdoc: {\r\n        expression: \"[AST_Node] the container expression\",\r\n        property: \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"\r\n    }\r\n});\r\n\r\nvar AST_Dot = DEFNODE(\"Dot\", null, {\r\n    $documentation: \"A dotted property access expression\",\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n        });\r\n    }\r\n}, AST_PropAccess);\r\n\r\nvar AST_Sub = DEFNODE(\"Sub\", null, {\r\n    $documentation: \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n            this.property._walk(visitor);\r\n        });\r\n    }\r\n}, AST_PropAccess);\r\n\r\nvar AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\r\n    $documentation: \"Base class for unary expressions\",\r\n    $propdoc: {\r\n        operator: \"[string] the operator\",\r\n        expression: \"[AST_Node] expression that this unary operator applies to\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.expression._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\r\n    $documentation: \"Unary prefix expression, i.e. `typeof i` or `++i`\"\r\n}, AST_Unary);\r\n\r\nvar AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\r\n    $documentation: \"Unary postfix expression, i.e. `i++`\"\r\n}, AST_Unary);\r\n\r\nvar AST_Binary = DEFNODE(\"Binary\", \"left operator right\", {\r\n    $documentation: \"Binary expression, i.e. `a + b`\",\r\n    $propdoc: {\r\n        left: \"[AST_Node] left-hand side expression\",\r\n        operator: \"[string] the operator\",\r\n        right: \"[AST_Node] right-hand side expression\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.left._walk(visitor);\r\n            this.right._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\r\n    $documentation: \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\r\n    $propdoc: {\r\n        condition: \"[AST_Node]\",\r\n        consequent: \"[AST_Node]\",\r\n        alternative: \"[AST_Node]\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.condition._walk(visitor);\r\n            this.consequent._walk(visitor);\r\n            this.alternative._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_Assign = DEFNODE(\"Assign\", null, {\r\n    $documentation: \"An assignment expression  `a = b + 5`\",\r\n}, AST_Binary);\r\n\r\n/* -----[ LITERALS ]----- */\r\n\r\nvar AST_Array = DEFNODE(\"Array\", \"elements\", {\r\n    $documentation: \"An array literal\",\r\n    $propdoc: {\r\n        elements: \"[AST_Node*] array of elements\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.elements.forEach(function(el){\r\n                el._walk(visitor);\r\n            });\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_Object = DEFNODE(\"Object\", \"properties\", {\r\n    $documentation: \"An object literal\",\r\n    $propdoc: {\r\n        properties: \"[AST_ObjectProperty*] array of properties\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.properties.forEach(function(prop){\r\n                prop._walk(visitor);\r\n            });\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value\", {\r\n    $documentation: \"Base class for literal object properties\",\r\n    $propdoc: {\r\n        key: \"[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.\",\r\n        value: \"[AST_Node] property value.  For setters and getters this is an AST_Function.\"\r\n    },\r\n    _walk: function(visitor) {\r\n        return visitor._visit(this, function(){\r\n            this.value._walk(visitor);\r\n        });\r\n    }\r\n});\r\n\r\nvar AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", \"quote\", {\r\n    $documentation: \"A key: value object property\",\r\n    $propdoc: {\r\n        quote: \"[string] the original quote character\"\r\n    }\r\n}, AST_ObjectProperty);\r\n\r\nvar AST_ObjectSetter = DEFNODE(\"ObjectSetter\", null, {\r\n    $documentation: \"An object setter property\",\r\n}, AST_ObjectProperty);\r\n\r\nvar AST_ObjectGetter = DEFNODE(\"ObjectGetter\", null, {\r\n    $documentation: \"An object getter property\",\r\n}, AST_ObjectProperty);\r\n\r\nvar AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\r\n    $propdoc: {\r\n        name: \"[string] name of this symbol\",\r\n        scope: \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\r\n        thedef: \"[SymbolDef/S] the definition of this symbol\"\r\n    },\r\n    $documentation: \"Base class for all symbols\",\r\n});\r\n\r\nvar AST_SymbolAccessor = DEFNODE(\"SymbolAccessor\", null, {\r\n    $documentation: \"The name of a property accessor (setter/getter function)\"\r\n}, AST_Symbol);\r\n\r\nvar AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\r\n    $documentation: \"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\",\r\n    $propdoc: {\r\n        init: \"[AST_Node*/S] array of initializers for this declaration.\"\r\n    }\r\n}, AST_Symbol);\r\n\r\nvar AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\r\n    $documentation: \"Symbol defining a variable\",\r\n}, AST_SymbolDeclaration);\r\n\r\nvar AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\r\n    $documentation: \"A constant declaration\"\r\n}, AST_SymbolDeclaration);\r\n\r\nvar AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", null, {\r\n    $documentation: \"Symbol naming a function argument\",\r\n}, AST_SymbolVar);\r\n\r\nvar AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\r\n    $documentation: \"Symbol defining a function\",\r\n}, AST_SymbolDeclaration);\r\n\r\nvar AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\r\n    $documentation: \"Symbol naming a function expression\",\r\n}, AST_SymbolDeclaration);\r\n\r\nvar AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\r\n    $documentation: \"Symbol naming the exception in catch\",\r\n}, AST_SymbolDeclaration);\r\n\r\nvar AST_Label = DEFNODE(\"Label\", \"references\", {\r\n    $documentation: \"Symbol naming a label (declaration)\",\r\n    $propdoc: {\r\n        references: \"[AST_LoopControl*] a list of nodes referring to this label\"\r\n    },\r\n    initialize: function() {\r\n        this.references = [];\r\n        this.thedef = this;\r\n    }\r\n}, AST_Symbol);\r\n\r\nvar AST_SymbolRef = DEFNODE(\"SymbolRef\", null, {\r\n    $documentation: \"Reference to some symbol (not definition/declaration)\",\r\n}, AST_Symbol);\r\n\r\nvar AST_LabelRef = DEFNODE(\"LabelRef\", null, {\r\n    $documentation: \"Reference to a label symbol\",\r\n}, AST_Symbol);\r\n\r\nvar AST_This = DEFNODE(\"This\", null, {\r\n    $documentation: \"The `this` symbol\",\r\n}, AST_Symbol);\r\n\r\nvar AST_Constant = DEFNODE(\"Constant\", null, {\r\n    $documentation: \"Base class for all constants\",\r\n    getValue: function() {\r\n        return this.value;\r\n    }\r\n});\r\n\r\nvar AST_String = DEFNODE(\"String\", \"value quote\", {\r\n    $documentation: \"A string literal\",\r\n    $propdoc: {\r\n        value: \"[string] the contents of this string\",\r\n        quote: \"[string] the original quote character\"\r\n    }\r\n}, AST_Constant);\r\n\r\nvar AST_Number = DEFNODE(\"Number\", \"value\", {\r\n    $documentation: \"A number literal\",\r\n    $propdoc: {\r\n        value: \"[number] the numeric value\"\r\n    }\r\n}, AST_Constant);\r\n\r\nvar AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\r\n    $documentation: \"A regexp literal\",\r\n    $propdoc: {\r\n        value: \"[RegExp] the actual regexp\"\r\n    }\r\n}, AST_Constant);\r\n\r\nvar AST_Atom = DEFNODE(\"Atom\", null, {\r\n    $documentation: \"Base class for atoms\",\r\n}, AST_Constant);\r\n\r\nvar AST_Null = DEFNODE(\"Null\", null, {\r\n    $documentation: \"The `null` atom\",\r\n    value: null\r\n}, AST_Atom);\r\n\r\nvar AST_NaN = DEFNODE(\"NaN\", null, {\r\n    $documentation: \"The impossible value\",\r\n    value: 0/0\r\n}, AST_Atom);\r\n\r\nvar AST_Undefined = DEFNODE(\"Undefined\", null, {\r\n    $documentation: \"The `undefined` value\",\r\n    value: (function(){}())\r\n}, AST_Atom);\r\n\r\nvar AST_Hole = DEFNODE(\"Hole\", null, {\r\n    $documentation: \"A hole in an array\",\r\n    value: (function(){}())\r\n}, AST_Atom);\r\n\r\nvar AST_Infinity = DEFNODE(\"Infinity\", null, {\r\n    $documentation: \"The `Infinity` value\",\r\n    value: 1/0\r\n}, AST_Atom);\r\n\r\nvar AST_Boolean = DEFNODE(\"Boolean\", null, {\r\n    $documentation: \"Base class for booleans\",\r\n}, AST_Atom);\r\n\r\nvar AST_False = DEFNODE(\"False\", null, {\r\n    $documentation: \"The `false` atom\",\r\n    value: false\r\n}, AST_Boolean);\r\n\r\nvar AST_True = DEFNODE(\"True\", null, {\r\n    $documentation: \"The `true` atom\",\r\n    value: true\r\n}, AST_Boolean);\r\n\r\n/* -----[ TreeWalker ]----- */\r\n\r\nfunction TreeWalker(callback) {\r\n    this.visit = callback;\r\n    this.stack = [];\r\n};\r\nTreeWalker.prototype = {\r\n    _visit: function(node, descend) {\r\n        this.stack.push(node);\r\n        var ret = this.visit(node, descend ? function(){\r\n            descend.call(node);\r\n        } : noop);\r\n        if (!ret && descend) {\r\n            descend.call(node);\r\n        }\r\n        this.stack.pop();\r\n        return ret;\r\n    },\r\n    parent: function(n) {\r\n        return this.stack[this.stack.length - 2 - (n || 0)];\r\n    },\r\n    push: function (node) {\r\n        this.stack.push(node);\r\n    },\r\n    pop: function() {\r\n        return this.stack.pop();\r\n    },\r\n    self: function() {\r\n        return this.stack[this.stack.length - 1];\r\n    },\r\n    find_parent: function(type) {\r\n        var stack = this.stack;\r\n        for (var i = stack.length; --i >= 0;) {\r\n            var x = stack[i];\r\n            if (x instanceof type) return x;\r\n        }\r\n    },\r\n    has_directive: function(type) {\r\n        return this.find_parent(AST_Scope).has_directive(type);\r\n    },\r\n    in_boolean_context: function() {\r\n        var stack = this.stack;\r\n        var i = stack.length, self = stack[--i];\r\n        while (i > 0) {\r\n            var p = stack[--i];\r\n            if ((p instanceof AST_If           && p.condition === self) ||\r\n                (p instanceof AST_Conditional  && p.condition === self) ||\r\n                (p instanceof AST_DWLoop       && p.condition === self) ||\r\n                (p instanceof AST_For          && p.condition === self) ||\r\n                (p instanceof AST_UnaryPrefix  && p.operator == \"!\" && p.expression === self))\r\n            {\r\n                return true;\r\n            }\r\n            if (!(p instanceof AST_Binary && (p.operator == \"&&\" || p.operator == \"||\")))\r\n                return false;\r\n            self = p;\r\n        }\r\n    },\r\n    loopcontrol_target: function(label) {\r\n        var stack = this.stack;\r\n        if (label) for (var i = stack.length; --i >= 0;) {\r\n            var x = stack[i];\r\n            if (x instanceof AST_LabeledStatement && x.label.name == label.name) {\r\n                return x.body;\r\n            }\r\n        } else for (var i = stack.length; --i >= 0;) {\r\n            var x = stack[i];\r\n            if (x instanceof AST_Switch || x instanceof AST_IterationStatement)\r\n                return x;\r\n        }\r\n    }\r\n};\r\n\n/***********************************************************************\r\n\r\n  A JavaScript tokenizer / parser / beautifier / compressor.\r\n  https://github.com/mishoo/UglifyJS2\r\n\r\n  -------------------------------- (C) ---------------------------------\r\n\r\n                           Author: Mihai Bazon\r\n                         <mihai.bazon@gmail.com>\r\n                       http://mihai.bazon.net/blog\r\n\r\n  Distributed under the BSD license:\r\n\r\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\r\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions\r\n    are met:\r\n\r\n        * Redistributions of source code must retain the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer.\r\n\r\n        * Redistributions in binary form must reproduce the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer in the documentation and/or other materials\r\n          provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n    SUCH DAMAGE.\r\n\r\n ***********************************************************************/\r\n\r\n\"use strict\";\r\n\r\nvar KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';\r\nvar KEYWORDS_ATOM = 'false null true';\r\nvar RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield'\r\n    + \" \" + KEYWORDS_ATOM + \" \" + KEYWORDS;\r\nvar KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';\r\n\r\nKEYWORDS = makePredicate(KEYWORDS);\r\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\r\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\r\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\r\n\r\nvar OPERATOR_CHARS = makePredicate(characters(\"+-*&%=<>!?|~^\"));\r\n\r\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\r\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\r\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\r\n\r\nvar OPERATORS = makePredicate([\r\n    \"in\",\r\n    \"instanceof\",\r\n    \"typeof\",\r\n    \"new\",\r\n    \"void\",\r\n    \"delete\",\r\n    \"++\",\r\n    \"--\",\r\n    \"+\",\r\n    \"-\",\r\n    \"!\",\r\n    \"~\",\r\n    \"&\",\r\n    \"|\",\r\n    \"^\",\r\n    \"*\",\r\n    \"/\",\r\n    \"%\",\r\n    \">>\",\r\n    \"<<\",\r\n    \">>>\",\r\n    \"<\",\r\n    \">\",\r\n    \"<=\",\r\n    \">=\",\r\n    \"==\",\r\n    \"===\",\r\n    \"!=\",\r\n    \"!==\",\r\n    \"?\",\r\n    \"=\",\r\n    \"+=\",\r\n    \"-=\",\r\n    \"/=\",\r\n    \"*=\",\r\n    \"%=\",\r\n    \">>=\",\r\n    \"<<=\",\r\n    \">>>=\",\r\n    \"|=\",\r\n    \"^=\",\r\n    \"&=\",\r\n    \"&&\",\r\n    \"||\"\r\n]);\r\n\r\nvar WHITESPACE_CHARS = makePredicate(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\"));\r\n\r\nvar PUNC_BEFORE_EXPRESSION = makePredicate(characters(\"[{(,.;:\"));\r\n\r\nvar PUNC_CHARS = makePredicate(characters(\"[]{}(),;:\"));\r\n\r\nvar REGEXP_MODIFIERS = makePredicate(characters(\"gmsiy\"));\r\n\r\n/* -----[ Tokenizer ]----- */\r\n\r\n// regexps adapted from http://xregexp.com/plugins/#unicode\r\nvar UNICODE = {\r\n    letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0-\\\\u08B2\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA69D\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA7AD\\\\uA7B0\\\\uA7B1\\\\uA7F7-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uA9E0-\\\\uA9E4\\\\uA9E6-\\\\uA9EF\\\\uA9FA-\\\\uA9FE\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA7E-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB5F\\\\uAB64\\\\uAB65\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\r\n    digit: new RegExp(\"[\\\\u0030-\\\\u0039\\\\u0660-\\\\u0669\\\\u06F0-\\\\u06F9\\\\u07C0-\\\\u07C9\\\\u0966-\\\\u096F\\\\u09E6-\\\\u09EF\\\\u0A66-\\\\u0A6F\\\\u0AE6-\\\\u0AEF\\\\u0B66-\\\\u0B6F\\\\u0BE6-\\\\u0BEF\\\\u0C66-\\\\u0C6F\\\\u0CE6-\\\\u0CEF\\\\u0D66-\\\\u0D6F\\\\u0DE6-\\\\u0DEF\\\\u0E50-\\\\u0E59\\\\u0ED0-\\\\u0ED9\\\\u0F20-\\\\u0F29\\\\u1040-\\\\u1049\\\\u1090-\\\\u1099\\\\u17E0-\\\\u17E9\\\\u1810-\\\\u1819\\\\u1946-\\\\u194F\\\\u19D0-\\\\u19D9\\\\u1A80-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1B50-\\\\u1B59\\\\u1BB0-\\\\u1BB9\\\\u1C40-\\\\u1C49\\\\u1C50-\\\\u1C59\\\\uA620-\\\\uA629\\\\uA8D0-\\\\uA8D9\\\\uA900-\\\\uA909\\\\uA9D0-\\\\uA9D9\\\\uA9F0-\\\\uA9F9\\\\uAA50-\\\\uAA59\\\\uABF0-\\\\uABF9\\\\uFF10-\\\\uFF19]\"),\r\n    non_spacing_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\r\n    space_combining_mark: new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\r\n    connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\r\n};\r\n\r\nfunction is_letter(code) {\r\n    return (code >= 97 && code <= 122)\r\n        || (code >= 65 && code <= 90)\r\n        || (code >= 0xaa && UNICODE.letter.test(String.fromCharCode(code)));\r\n};\r\n\r\nfunction is_digit(code) {\r\n    return code >= 48 && code <= 57;\r\n};\r\n\r\nfunction is_alphanumeric_char(code) {\r\n    return is_digit(code) || is_letter(code);\r\n};\r\n\r\nfunction is_unicode_digit(code) {\r\n    return UNICODE.digit.test(String.fromCharCode(code));\r\n}\r\n\r\nfunction is_unicode_combining_mark(ch) {\r\n    return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\r\n};\r\n\r\nfunction is_unicode_connector_punctuation(ch) {\r\n    return UNICODE.connector_punctuation.test(ch);\r\n};\r\n\r\nfunction is_identifier(name) {\r\n    return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);\r\n};\r\n\r\nfunction is_identifier_start(code) {\r\n    return code == 36 || code == 95 || is_letter(code);\r\n};\r\n\r\nfunction is_identifier_char(ch) {\r\n    var code = ch.charCodeAt(0);\r\n    return is_identifier_start(code)\r\n        || is_digit(code)\r\n        || code == 8204 // \\u200c: zero-width non-joiner <ZWNJ>\r\n        || code == 8205 // \\u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\r\n        || is_unicode_combining_mark(ch)\r\n        || is_unicode_connector_punctuation(ch)\r\n        || is_unicode_digit(code)\r\n    ;\r\n};\r\n\r\nfunction is_identifier_string(str){\r\n    return /^[a-z_$][a-z0-9_$]*$/i.test(str);\r\n};\r\n\r\nfunction parse_js_number(num) {\r\n    if (RE_HEX_NUMBER.test(num)) {\r\n        return parseInt(num.substr(2), 16);\r\n    } else if (RE_OCT_NUMBER.test(num)) {\r\n        return parseInt(num.substr(1), 8);\r\n    } else if (RE_DEC_NUMBER.test(num)) {\r\n        return parseFloat(num);\r\n    }\r\n};\r\n\r\nfunction JS_Parse_Error(message, filename, line, col, pos) {\r\n    this.message = message;\r\n    this.filename = filename;\r\n    this.line = line;\r\n    this.col = col;\r\n    this.pos = pos;\r\n    this.stack = new Error().stack;\r\n};\r\n\r\nJS_Parse_Error.prototype.toString = function() {\r\n    return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\\n\" + this.stack;\r\n};\r\n\r\nfunction js_error(message, filename, line, col, pos) {\r\n    throw new JS_Parse_Error(message, filename, line, col, pos);\r\n};\r\n\r\nfunction is_token(token, type, val) {\r\n    return token.type == type && (val == null || token.value == val);\r\n};\r\n\r\nvar EX_EOF = {};\r\n\r\nfunction tokenizer($TEXT, filename, html5_comments) {\r\n\r\n    var S = {\r\n        text            : $TEXT,\r\n        filename        : filename,\r\n        pos             : 0,\r\n        tokpos          : 0,\r\n        line            : 1,\r\n        tokline         : 0,\r\n        col             : 0,\r\n        tokcol          : 0,\r\n        newline_before  : false,\r\n        regex_allowed   : false,\r\n        comments_before : []\r\n    };\r\n\r\n    function peek() { return S.text.charAt(S.pos); };\r\n\r\n    function next(signal_eof, in_string) {\r\n        var ch = S.text.charAt(S.pos++);\r\n        if (signal_eof && !ch)\r\n            throw EX_EOF;\r\n        if (\"\\r\\n\\u2028\\u2029\".indexOf(ch) >= 0) {\r\n            S.newline_before = S.newline_before || !in_string;\r\n            ++S.line;\r\n            S.col = 0;\r\n            if (!in_string && ch == \"\\r\" && peek() == \"\\n\") {\r\n                // treat a \\r\\n sequence as a single \\n\r\n                ++S.pos;\r\n                ch = \"\\n\";\r\n            }\r\n        } else {\r\n            ++S.col;\r\n        }\r\n        return ch;\r\n    };\r\n\r\n    function forward(i) {\r\n        while (i-- > 0) next();\r\n    };\r\n\r\n    function looking_at(str) {\r\n        return S.text.substr(S.pos, str.length) == str;\r\n    };\r\n\r\n    function find(what, signal_eof) {\r\n        var pos = S.text.indexOf(what, S.pos);\r\n        if (signal_eof && pos == -1) throw EX_EOF;\r\n        return pos;\r\n    };\r\n\r\n    function start_token() {\r\n        S.tokline = S.line;\r\n        S.tokcol = S.col;\r\n        S.tokpos = S.pos;\r\n    };\r\n\r\n    var prev_was_dot = false;\r\n    function token(type, value, is_comment) {\r\n        S.regex_allowed = ((type == \"operator\" && !UNARY_POSTFIX(value)) ||\r\n                           (type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION(value)) ||\r\n                           (type == \"punc\" && PUNC_BEFORE_EXPRESSION(value)));\r\n        prev_was_dot = (type == \"punc\" && value == \".\");\r\n        var ret = {\r\n            type    : type,\r\n            value   : value,\r\n            line    : S.tokline,\r\n            col     : S.tokcol,\r\n            pos     : S.tokpos,\r\n            endline : S.line,\r\n            endcol  : S.col,\r\n            endpos  : S.pos,\r\n            nlb     : S.newline_before,\r\n            file    : filename\r\n        };\r\n        if (!is_comment) {\r\n            ret.comments_before = S.comments_before;\r\n            S.comments_before = [];\r\n            // make note of any newlines in the comments that came before\r\n            for (var i = 0, len = ret.comments_before.length; i < len; i++) {\r\n                ret.nlb = ret.nlb || ret.comments_before[i].nlb;\r\n            }\r\n        }\r\n        S.newline_before = false;\r\n        return new AST_Token(ret);\r\n    };\r\n\r\n    function skip_whitespace() {\r\n        var ch;\r\n        while (WHITESPACE_CHARS(ch = peek()) || ch == \"\\u2028\" || ch == \"\\u2029\")\r\n            next();\r\n    };\r\n\r\n    function read_while(pred) {\r\n        var ret = \"\", ch, i = 0;\r\n        while ((ch = peek()) && pred(ch, i++))\r\n            ret += next();\r\n        return ret;\r\n    };\r\n\r\n    function parse_error(err) {\r\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\r\n    };\r\n\r\n    function read_num(prefix) {\r\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\r\n        var num = read_while(function(ch, i){\r\n            var code = ch.charCodeAt(0);\r\n            switch (code) {\r\n              case 120: case 88: // xX\r\n                return has_x ? false : (has_x = true);\r\n              case 101: case 69: // eE\r\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\r\n              case 45: // -\r\n                return after_e || (i == 0 && !prefix);\r\n              case 43: // +\r\n                return after_e;\r\n              case (after_e = false, 46): // .\r\n                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;\r\n            }\r\n            return is_alphanumeric_char(code);\r\n        });\r\n        if (prefix) num = prefix + num;\r\n        var valid = parse_js_number(num);\r\n        if (!isNaN(valid)) {\r\n            return token(\"num\", valid);\r\n        } else {\r\n            parse_error(\"Invalid syntax: \" + num);\r\n        }\r\n    };\r\n\r\n    function read_escaped_char(in_string) {\r\n        var ch = next(true, in_string);\r\n        switch (ch.charCodeAt(0)) {\r\n          case 110 : return \"\\n\";\r\n          case 114 : return \"\\r\";\r\n          case 116 : return \"\\t\";\r\n          case 98  : return \"\\b\";\r\n          case 118 : return \"\\u000b\"; // \\v\r\n          case 102 : return \"\\f\";\r\n          case 48  : return \"\\0\";\r\n          case 120 : return String.fromCharCode(hex_bytes(2)); // \\x\r\n          case 117 : return String.fromCharCode(hex_bytes(4)); // \\u\r\n          case 10  : return \"\"; // newline\r\n          case 13  :            // \\r\r\n            if (peek() == \"\\n\") { // DOS newline\r\n                next(true, in_string);\r\n                return \"\";\r\n            }\r\n        }\r\n        return ch;\r\n    };\r\n\r\n    function hex_bytes(n) {\r\n        var num = 0;\r\n        for (; n > 0; --n) {\r\n            var digit = parseInt(next(true), 16);\r\n            if (isNaN(digit))\r\n                parse_error(\"Invalid hex-character pattern in string\");\r\n            num = (num << 4) | digit;\r\n        }\r\n        return num;\r\n    };\r\n\r\n    var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char){\r\n        var quote = next(), ret = \"\";\r\n        for (;;) {\r\n            var ch = next(true, true);\r\n            if (ch == \"\\\\\") {\r\n                // read OctalEscapeSequence (XXX: deprecated if \"strict mode\")\r\n                // https://github.com/mishoo/UglifyJS/issues/178\r\n                var octal_len = 0, first = null;\r\n                ch = read_while(function(ch){\r\n                    if (ch >= \"0\" && ch <= \"7\") {\r\n                        if (!first) {\r\n                            first = ch;\r\n                            return ++octal_len;\r\n                        }\r\n                        else if (first <= \"3\" && octal_len <= 2) return ++octal_len;\r\n                        else if (first >= \"4\" && octal_len <= 1) return ++octal_len;\r\n                    }\r\n                    return false;\r\n                });\r\n                if (octal_len > 0) ch = String.fromCharCode(parseInt(ch, 8));\r\n                else ch = read_escaped_char(true);\r\n            }\r\n            else if (ch == quote) break;\r\n            ret += ch;\r\n        }\r\n        var tok = token(\"string\", ret);\r\n        tok.quote = quote_char;\r\n        return tok;\r\n    });\r\n\r\n    function skip_line_comment(type) {\r\n        var regex_allowed = S.regex_allowed;\r\n        var i = find(\"\\n\"), ret;\r\n        if (i == -1) {\r\n            ret = S.text.substr(S.pos);\r\n            S.pos = S.text.length;\r\n        } else {\r\n            ret = S.text.substring(S.pos, i);\r\n            S.pos = i;\r\n        }\r\n        S.col = S.tokcol + (S.pos - S.tokpos);\r\n        S.comments_before.push(token(type, ret, true));\r\n        S.regex_allowed = regex_allowed;\r\n        return next_token();\r\n    };\r\n\r\n    var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function(){\r\n        var regex_allowed = S.regex_allowed;\r\n        var i = find(\"*/\", true);\r\n        var text = S.text.substring(S.pos, i);\r\n        var a = text.split(\"\\n\"), n = a.length;\r\n        // update stream position\r\n        S.pos = i + 2;\r\n        S.line += n - 1;\r\n        if (n > 1) S.col = a[n - 1].length;\r\n        else S.col += a[n - 1].length;\r\n        S.col += 2;\r\n        var nlb = S.newline_before = S.newline_before || text.indexOf(\"\\n\") >= 0;\r\n        S.comments_before.push(token(\"comment2\", text, true));\r\n        S.regex_allowed = regex_allowed;\r\n        S.newline_before = nlb;\r\n        return next_token();\r\n    });\r\n\r\n    function read_name() {\r\n        var backslash = false, name = \"\", ch, escaped = false, hex;\r\n        while ((ch = peek()) != null) {\r\n            if (!backslash) {\r\n                if (ch == \"\\\\\") escaped = backslash = true, next();\r\n                else if (is_identifier_char(ch)) name += next();\r\n                else break;\r\n            }\r\n            else {\r\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\r\n                ch = read_escaped_char();\r\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\r\n                name += ch;\r\n                backslash = false;\r\n            }\r\n        }\r\n        if (KEYWORDS(name) && escaped) {\r\n            hex = name.charCodeAt(0).toString(16).toUpperCase();\r\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\r\n        }\r\n        return name;\r\n    };\r\n\r\n    var read_regexp = with_eof_error(\"Unterminated regular expression\", function(regexp){\r\n        var prev_backslash = false, ch, in_class = false;\r\n        while ((ch = next(true))) if (prev_backslash) {\r\n            regexp += \"\\\\\" + ch;\r\n            prev_backslash = false;\r\n        } else if (ch == \"[\") {\r\n            in_class = true;\r\n            regexp += ch;\r\n        } else if (ch == \"]\" && in_class) {\r\n            in_class = false;\r\n            regexp += ch;\r\n        } else if (ch == \"/\" && !in_class) {\r\n            break;\r\n        } else if (ch == \"\\\\\") {\r\n            prev_backslash = true;\r\n        } else {\r\n            regexp += ch;\r\n        }\r\n        var mods = read_name();\r\n        return token(\"regexp\", new RegExp(regexp, mods));\r\n    });\r\n\r\n    function read_operator(prefix) {\r\n        function grow(op) {\r\n            if (!peek()) return op;\r\n            var bigger = op + peek();\r\n            if (OPERATORS(bigger)) {\r\n                next();\r\n                return grow(bigger);\r\n            } else {\r\n                return op;\r\n            }\r\n        };\r\n        return token(\"operator\", grow(prefix || next()));\r\n    };\r\n\r\n    function handle_slash() {\r\n        next();\r\n        switch (peek()) {\r\n          case \"/\":\r\n            next();\r\n            return skip_line_comment(\"comment1\");\r\n          case \"*\":\r\n            next();\r\n            return skip_multiline_comment();\r\n        }\r\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\r\n    };\r\n\r\n    function handle_dot() {\r\n        next();\r\n        return is_digit(peek().charCodeAt(0))\r\n            ? read_num(\".\")\r\n            : token(\"punc\", \".\");\r\n    };\r\n\r\n    function read_word() {\r\n        var word = read_name();\r\n        if (prev_was_dot) return token(\"name\", word);\r\n        return KEYWORDS_ATOM(word) ? token(\"atom\", word)\r\n            : !KEYWORDS(word) ? token(\"name\", word)\r\n            : OPERATORS(word) ? token(\"operator\", word)\r\n            : token(\"keyword\", word);\r\n    };\r\n\r\n    function with_eof_error(eof_error, cont) {\r\n        return function(x) {\r\n            try {\r\n                return cont(x);\r\n            } catch(ex) {\r\n                if (ex === EX_EOF) parse_error(eof_error);\r\n                else throw ex;\r\n            }\r\n        };\r\n    };\r\n\r\n    function next_token(force_regexp) {\r\n        if (force_regexp != null)\r\n            return read_regexp(force_regexp);\r\n        skip_whitespace();\r\n        start_token();\r\n        if (html5_comments) {\r\n            if (looking_at(\"<!--\")) {\r\n                forward(4);\r\n                return skip_line_comment(\"comment3\");\r\n            }\r\n            if (looking_at(\"-->\") && S.newline_before) {\r\n                forward(3);\r\n                return skip_line_comment(\"comment4\");\r\n            }\r\n        }\r\n        var ch = peek();\r\n        if (!ch) return token(\"eof\");\r\n        var code = ch.charCodeAt(0);\r\n        switch (code) {\r\n          case 34: case 39: return read_string(ch);\r\n          case 46: return handle_dot();\r\n          case 47: return handle_slash();\r\n        }\r\n        if (is_digit(code)) return read_num();\r\n        if (PUNC_CHARS(ch)) return token(\"punc\", next());\r\n        if (OPERATOR_CHARS(ch)) return read_operator();\r\n        if (code == 92 || is_identifier_start(code)) return read_word();\r\n        parse_error(\"Unexpected character '\" + ch + \"'\");\r\n    };\r\n\r\n    next_token.context = function(nc) {\r\n        if (nc) S = nc;\r\n        return S;\r\n    };\r\n\r\n    return next_token;\r\n\r\n};\r\n\r\n/* -----[ Parser (constants) ]----- */\r\n\r\nvar UNARY_PREFIX = makePredicate([\r\n    \"typeof\",\r\n    \"void\",\r\n    \"delete\",\r\n    \"--\",\r\n    \"++\",\r\n    \"!\",\r\n    \"~\",\r\n    \"-\",\r\n    \"+\"\r\n]);\r\n\r\nvar UNARY_POSTFIX = makePredicate([ \"--\", \"++\" ]);\r\n\r\nvar ASSIGNMENT = makePredicate([ \"=\", \"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\" ]);\r\n\r\nvar PRECEDENCE = (function(a, ret){\r\n    for (var i = 0; i < a.length; ++i) {\r\n        var b = a[i];\r\n        for (var j = 0; j < b.length; ++j) {\r\n            ret[b[j]] = i + 1;\r\n        }\r\n    }\r\n    return ret;\r\n})(\r\n    [\r\n        [\"||\"],\r\n        [\"&&\"],\r\n        [\"|\"],\r\n        [\"^\"],\r\n        [\"&\"],\r\n        [\"==\", \"===\", \"!=\", \"!==\"],\r\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\r\n        [\">>\", \"<<\", \">>>\"],\r\n        [\"+\", \"-\"],\r\n        [\"*\", \"/\", \"%\"]\r\n    ],\r\n    {}\r\n);\r\n\r\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\r\n\r\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\r\n\r\n/* -----[ Parser ]----- */\r\n\r\nfunction parse($TEXT, options) {\r\n\r\n    options = defaults(options, {\r\n        strict         : false,\r\n        filename       : null,\r\n        toplevel       : null,\r\n        expression     : false,\r\n        html5_comments : true,\r\n        bare_returns   : false,\r\n    });\r\n\r\n    var S = {\r\n        input         : (typeof $TEXT == \"string\"\r\n                         ? tokenizer($TEXT, options.filename,\r\n                                     options.html5_comments)\r\n                         : $TEXT),\r\n        token         : null,\r\n        prev          : null,\r\n        peeked        : null,\r\n        in_function   : 0,\r\n        in_directives : true,\r\n        in_loop       : 0,\r\n        labels        : []\r\n    };\r\n\r\n    S.token = next();\r\n\r\n    function is(type, value) {\r\n        return is_token(S.token, type, value);\r\n    };\r\n\r\n    function peek() { return S.peeked || (S.peeked = S.input()); };\r\n\r\n    function next() {\r\n        S.prev = S.token;\r\n        if (S.peeked) {\r\n            S.token = S.peeked;\r\n            S.peeked = null;\r\n        } else {\r\n            S.token = S.input();\r\n        }\r\n        S.in_directives = S.in_directives && (\r\n            S.token.type == \"string\" || is(\"punc\", \";\")\r\n        );\r\n        return S.token;\r\n    };\r\n\r\n    function prev() {\r\n        return S.prev;\r\n    };\r\n\r\n    function croak(msg, line, col, pos) {\r\n        var ctx = S.input.context();\r\n        js_error(msg,\r\n                 ctx.filename,\r\n                 line != null ? line : ctx.tokline,\r\n                 col != null ? col : ctx.tokcol,\r\n                 pos != null ? pos : ctx.tokpos);\r\n    };\r\n\r\n    function token_error(token, msg) {\r\n        croak(msg, token.line, token.col);\r\n    };\r\n\r\n    function unexpected(token) {\r\n        if (token == null)\r\n            token = S.token;\r\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\r\n    };\r\n\r\n    function expect_token(type, val) {\r\n        if (is(type, val)) {\r\n            return next();\r\n        }\r\n        token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.value + \"\" + \", expected \" + type + \" \" + val + \"\");\r\n    };\r\n\r\n    function expect(punc) { return expect_token(\"punc\", punc); };\r\n\r\n    function can_insert_semicolon() {\r\n        return !options.strict && (\r\n            S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\r\n        );\r\n    };\r\n\r\n    function semicolon() {\r\n        if (is(\"punc\", \";\")) next();\r\n        else if (!can_insert_semicolon()) unexpected();\r\n    };\r\n\r\n    function parenthesised() {\r\n        expect(\"(\");\r\n        var exp = expression(true);\r\n        expect(\")\");\r\n        return exp;\r\n    };\r\n\r\n    function embed_tokens(parser) {\r\n        return function() {\r\n            var start = S.token;\r\n            var expr = parser();\r\n            var end = prev();\r\n            expr.start = start;\r\n            expr.end = end;\r\n            return expr;\r\n        };\r\n    };\r\n\r\n    function handle_regexp() {\r\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\r\n            S.peeked = null;\r\n            S.token = S.input(S.token.value.substr(1)); // force regexp\r\n        }\r\n    };\r\n\r\n    var statement = embed_tokens(function() {\r\n        var tmp;\r\n        handle_regexp();\r\n        switch (S.token.type) {\r\n          case \"string\":\r\n            var dir = S.in_directives, stat = simple_statement();\r\n            // XXXv2: decide how to fix directives\r\n            if (dir && stat.body instanceof AST_String && !is(\"punc\", \",\")) {\r\n                return new AST_Directive({\r\n                    start : stat.body.start,\r\n                    end   : stat.body.end,\r\n                    quote : stat.body.quote,\r\n                    value : stat.body.value,\r\n                });\r\n            }\r\n            return stat;\r\n          case \"num\":\r\n          case \"regexp\":\r\n          case \"operator\":\r\n          case \"atom\":\r\n            return simple_statement();\r\n\r\n          case \"name\":\r\n            return is_token(peek(), \"punc\", \":\")\r\n                ? labeled_statement()\r\n                : simple_statement();\r\n\r\n          case \"punc\":\r\n            switch (S.token.value) {\r\n              case \"{\":\r\n                return new AST_BlockStatement({\r\n                    start : S.token,\r\n                    body  : block_(),\r\n                    end   : prev()\r\n                });\r\n              case \"[\":\r\n              case \"(\":\r\n                return simple_statement();\r\n              case \";\":\r\n                next();\r\n                return new AST_EmptyStatement();\r\n              default:\r\n                unexpected();\r\n            }\r\n\r\n          case \"keyword\":\r\n            switch (tmp = S.token.value, next(), tmp) {\r\n              case \"break\":\r\n                return break_cont(AST_Break);\r\n\r\n              case \"continue\":\r\n                return break_cont(AST_Continue);\r\n\r\n              case \"debugger\":\r\n                semicolon();\r\n                return new AST_Debugger();\r\n\r\n              case \"do\":\r\n                return new AST_Do({\r\n                    body      : in_loop(statement),\r\n                    condition : (expect_token(\"keyword\", \"while\"), tmp = parenthesised(), semicolon(), tmp)\r\n                });\r\n\r\n              case \"while\":\r\n                return new AST_While({\r\n                    condition : parenthesised(),\r\n                    body      : in_loop(statement)\r\n                });\r\n\r\n              case \"for\":\r\n                return for_();\r\n\r\n              case \"function\":\r\n                return function_(AST_Defun);\r\n\r\n              case \"if\":\r\n                return if_();\r\n\r\n              case \"return\":\r\n                if (S.in_function == 0 && !options.bare_returns)\r\n                    croak(\"'return' outside of function\");\r\n                return new AST_Return({\r\n                    value: ( is(\"punc\", \";\")\r\n                             ? (next(), null)\r\n                             : can_insert_semicolon()\r\n                             ? null\r\n                             : (tmp = expression(true), semicolon(), tmp) )\r\n                });\r\n\r\n              case \"switch\":\r\n                return new AST_Switch({\r\n                    expression : parenthesised(),\r\n                    body       : in_loop(switch_body_)\r\n                });\r\n\r\n              case \"throw\":\r\n                if (S.token.nlb)\r\n                    croak(\"Illegal newline after 'throw'\");\r\n                return new AST_Throw({\r\n                    value: (tmp = expression(true), semicolon(), tmp)\r\n                });\r\n\r\n              case \"try\":\r\n                return try_();\r\n\r\n              case \"var\":\r\n                return tmp = var_(), semicolon(), tmp;\r\n\r\n              case \"const\":\r\n                return tmp = const_(), semicolon(), tmp;\r\n\r\n              case \"with\":\r\n                return new AST_With({\r\n                    expression : parenthesised(),\r\n                    body       : statement()\r\n                });\r\n\r\n              default:\r\n                unexpected();\r\n            }\r\n        }\r\n    });\r\n\r\n    function labeled_statement() {\r\n        var label = as_symbol(AST_Label);\r\n        if (find_if(function(l){ return l.name == label.name }, S.labels)) {\r\n            // ECMA-262, 12.12: An ECMAScript program is considered\r\n            // syntactically incorrect if it contains a\r\n            // LabelledStatement that is enclosed by a\r\n            // LabelledStatement with the same Identifier as label.\r\n            croak(\"Label \" + label.name + \" defined twice\");\r\n        }\r\n        expect(\":\");\r\n        S.labels.push(label);\r\n        var stat = statement();\r\n        S.labels.pop();\r\n        if (!(stat instanceof AST_IterationStatement)) {\r\n            // check for `continue` that refers to this label.\r\n            // those should be reported as syntax errors.\r\n            // https://github.com/mishoo/UglifyJS2/issues/287\r\n            label.references.forEach(function(ref){\r\n                if (ref instanceof AST_Continue) {\r\n                    ref = ref.label.start;\r\n                    croak(\"Continue label `\" + label.name + \"` refers to non-IterationStatement.\",\r\n                          ref.line, ref.col, ref.pos);\r\n                }\r\n            });\r\n        }\r\n        return new AST_LabeledStatement({ body: stat, label: label });\r\n    };\r\n\r\n    function simple_statement(tmp) {\r\n        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });\r\n    };\r\n\r\n    function break_cont(type) {\r\n        var label = null, ldef;\r\n        if (!can_insert_semicolon()) {\r\n            label = as_symbol(AST_LabelRef, true);\r\n        }\r\n        if (label != null) {\r\n            ldef = find_if(function(l){ return l.name == label.name }, S.labels);\r\n            if (!ldef)\r\n                croak(\"Undefined label \" + label.name);\r\n            label.thedef = ldef;\r\n        }\r\n        else if (S.in_loop == 0)\r\n            croak(type.TYPE + \" not inside a loop or switch\");\r\n        semicolon();\r\n        var stat = new type({ label: label });\r\n        if (ldef) ldef.references.push(stat);\r\n        return stat;\r\n    };\r\n\r\n    function for_() {\r\n        expect(\"(\");\r\n        var init = null;\r\n        if (!is(\"punc\", \";\")) {\r\n            init = is(\"keyword\", \"var\")\r\n                ? (next(), var_(true))\r\n                : expression(true, true);\r\n            if (is(\"operator\", \"in\")) {\r\n                if (init instanceof AST_Var && init.definitions.length > 1)\r\n                    croak(\"Only one variable declaration allowed in for..in loop\");\r\n                next();\r\n                return for_in(init);\r\n            }\r\n        }\r\n        return regular_for(init);\r\n    };\r\n\r\n    function regular_for(init) {\r\n        expect(\";\");\r\n        var test = is(\"punc\", \";\") ? null : expression(true);\r\n        expect(\";\");\r\n        var step = is(\"punc\", \")\") ? null : expression(true);\r\n        expect(\")\");\r\n        return new AST_For({\r\n            init      : init,\r\n            condition : test,\r\n            step      : step,\r\n            body      : in_loop(statement)\r\n        });\r\n    };\r\n\r\n    function for_in(init) {\r\n        var lhs = init instanceof AST_Var ? init.definitions[0].name : null;\r\n        var obj = expression(true);\r\n        expect(\")\");\r\n        return new AST_ForIn({\r\n            init   : init,\r\n            name   : lhs,\r\n            object : obj,\r\n            body   : in_loop(statement)\r\n        });\r\n    };\r\n\r\n    var function_ = function(ctor) {\r\n        var in_statement = ctor === AST_Defun;\r\n        var name = is(\"name\") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;\r\n        if (in_statement && !name)\r\n            unexpected();\r\n        expect(\"(\");\r\n        return new ctor({\r\n            name: name,\r\n            argnames: (function(first, a){\r\n                while (!is(\"punc\", \")\")) {\r\n                    if (first) first = false; else expect(\",\");\r\n                    a.push(as_symbol(AST_SymbolFunarg));\r\n                }\r\n                next();\r\n                return a;\r\n            })(true, []),\r\n            body: (function(loop, labels){\r\n                ++S.in_function;\r\n                S.in_directives = true;\r\n                S.in_loop = 0;\r\n                S.labels = [];\r\n                var a = block_();\r\n                --S.in_function;\r\n                S.in_loop = loop;\r\n                S.labels = labels;\r\n                return a;\r\n            })(S.in_loop, S.labels)\r\n        });\r\n    };\r\n\r\n    function if_() {\r\n        var cond = parenthesised(), body = statement(), belse = null;\r\n        if (is(\"keyword\", \"else\")) {\r\n            next();\r\n            belse = statement();\r\n        }\r\n        return new AST_If({\r\n            condition   : cond,\r\n            body        : body,\r\n            alternative : belse\r\n        });\r\n    };\r\n\r\n    function block_() {\r\n        expect(\"{\");\r\n        var a = [];\r\n        while (!is(\"punc\", \"}\")) {\r\n            if (is(\"eof\")) unexpected();\r\n            a.push(statement());\r\n        }\r\n        next();\r\n        return a;\r\n    };\r\n\r\n    function switch_body_() {\r\n        expect(\"{\");\r\n        var a = [], cur = null, branch = null, tmp;\r\n        while (!is(\"punc\", \"}\")) {\r\n            if (is(\"eof\")) unexpected();\r\n            if (is(\"keyword\", \"case\")) {\r\n                if (branch) branch.end = prev();\r\n                cur = [];\r\n                branch = new AST_Case({\r\n                    start      : (tmp = S.token, next(), tmp),\r\n                    expression : expression(true),\r\n                    body       : cur\r\n                });\r\n                a.push(branch);\r\n                expect(\":\");\r\n            }\r\n            else if (is(\"keyword\", \"default\")) {\r\n                if (branch) branch.end = prev();\r\n                cur = [];\r\n                branch = new AST_Default({\r\n                    start : (tmp = S.token, next(), expect(\":\"), tmp),\r\n                    body  : cur\r\n                });\r\n                a.push(branch);\r\n            }\r\n            else {\r\n                if (!cur) unexpected();\r\n                cur.push(statement());\r\n            }\r\n        }\r\n        if (branch) branch.end = prev();\r\n        next();\r\n        return a;\r\n    };\r\n\r\n    function try_() {\r\n        var body = block_(), bcatch = null, bfinally = null;\r\n        if (is(\"keyword\", \"catch\")) {\r\n            var start = S.token;\r\n            next();\r\n            expect(\"(\");\r\n            var name = as_symbol(AST_SymbolCatch);\r\n            expect(\")\");\r\n            bcatch = new AST_Catch({\r\n                start   : start,\r\n                argname : name,\r\n                body    : block_(),\r\n                end     : prev()\r\n            });\r\n        }\r\n        if (is(\"keyword\", \"finally\")) {\r\n            var start = S.token;\r\n            next();\r\n            bfinally = new AST_Finally({\r\n                start : start,\r\n                body  : block_(),\r\n                end   : prev()\r\n            });\r\n        }\r\n        if (!bcatch && !bfinally)\r\n            croak(\"Missing catch/finally blocks\");\r\n        return new AST_Try({\r\n            body     : body,\r\n            bcatch   : bcatch,\r\n            bfinally : bfinally\r\n        });\r\n    };\r\n\r\n    function vardefs(no_in, in_const) {\r\n        var a = [];\r\n        for (;;) {\r\n            a.push(new AST_VarDef({\r\n                start : S.token,\r\n                name  : as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),\r\n                value : is(\"operator\", \"=\") ? (next(), expression(false, no_in)) : null,\r\n                end   : prev()\r\n            }));\r\n            if (!is(\"punc\", \",\"))\r\n                break;\r\n            next();\r\n        }\r\n        return a;\r\n    };\r\n\r\n    var var_ = function(no_in) {\r\n        return new AST_Var({\r\n            start       : prev(),\r\n            definitions : vardefs(no_in, false),\r\n            end         : prev()\r\n        });\r\n    };\r\n\r\n    var const_ = function() {\r\n        return new AST_Const({\r\n            start       : prev(),\r\n            definitions : vardefs(false, true),\r\n            end         : prev()\r\n        });\r\n    };\r\n\r\n    var new_ = function() {\r\n        var start = S.token;\r\n        expect_token(\"operator\", \"new\");\r\n        var newexp = expr_atom(false), args;\r\n        if (is(\"punc\", \"(\")) {\r\n            next();\r\n            args = expr_list(\")\");\r\n        } else {\r\n            args = [];\r\n        }\r\n        return subscripts(new AST_New({\r\n            start      : start,\r\n            expression : newexp,\r\n            args       : args,\r\n            end        : prev()\r\n        }), true);\r\n    };\r\n\r\n    function as_atom_node() {\r\n        var tok = S.token, ret;\r\n        switch (tok.type) {\r\n          case \"name\":\r\n          case \"keyword\":\r\n            ret = _make_symbol(AST_SymbolRef);\r\n            break;\r\n          case \"num\":\r\n            ret = new AST_Number({ start: tok, end: tok, value: tok.value });\r\n            break;\r\n          case \"string\":\r\n            ret = new AST_String({\r\n                start : tok,\r\n                end   : tok,\r\n                value : tok.value,\r\n                quote : tok.quote\r\n            });\r\n            break;\r\n          case \"regexp\":\r\n            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });\r\n            break;\r\n          case \"atom\":\r\n            switch (tok.value) {\r\n              case \"false\":\r\n                ret = new AST_False({ start: tok, end: tok });\r\n                break;\r\n              case \"true\":\r\n                ret = new AST_True({ start: tok, end: tok });\r\n                break;\r\n              case \"null\":\r\n                ret = new AST_Null({ start: tok, end: tok });\r\n                break;\r\n            }\r\n            break;\r\n        }\r\n        next();\r\n        return ret;\r\n    };\r\n\r\n    var expr_atom = function(allow_calls) {\r\n        if (is(\"operator\", \"new\")) {\r\n            return new_();\r\n        }\r\n        var start = S.token;\r\n        if (is(\"punc\")) {\r\n            switch (start.value) {\r\n              case \"(\":\r\n                next();\r\n                var ex = expression(true);\r\n                ex.start = start;\r\n                ex.end = S.token;\r\n                expect(\")\");\r\n                return subscripts(ex, allow_calls);\r\n              case \"[\":\r\n                return subscripts(array_(), allow_calls);\r\n              case \"{\":\r\n                return subscripts(object_(), allow_calls);\r\n            }\r\n            unexpected();\r\n        }\r\n        if (is(\"keyword\", \"function\")) {\r\n            next();\r\n            var func = function_(AST_Function);\r\n            func.start = start;\r\n            func.end = prev();\r\n            return subscripts(func, allow_calls);\r\n        }\r\n        if (ATOMIC_START_TOKEN[S.token.type]) {\r\n            return subscripts(as_atom_node(), allow_calls);\r\n        }\r\n        unexpected();\r\n    };\r\n\r\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\r\n        var first = true, a = [];\r\n        while (!is(\"punc\", closing)) {\r\n            if (first) first = false; else expect(\",\");\r\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\r\n            if (is(\"punc\", \",\") && allow_empty) {\r\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\r\n            } else {\r\n                a.push(expression(false));\r\n            }\r\n        }\r\n        next();\r\n        return a;\r\n    };\r\n\r\n    var array_ = embed_tokens(function() {\r\n        expect(\"[\");\r\n        return new AST_Array({\r\n            elements: expr_list(\"]\", !options.strict, true)\r\n        });\r\n    });\r\n\r\n    var object_ = embed_tokens(function() {\r\n        expect(\"{\");\r\n        var first = true, a = [];\r\n        while (!is(\"punc\", \"}\")) {\r\n            if (first) first = false; else expect(\",\");\r\n            if (!options.strict && is(\"punc\", \"}\"))\r\n                // allow trailing comma\r\n                break;\r\n            var start = S.token;\r\n            var type = start.type;\r\n            var name = as_property_name();\r\n            if (type == \"name\" && !is(\"punc\", \":\")) {\r\n                if (name == \"get\") {\r\n                    a.push(new AST_ObjectGetter({\r\n                        start : start,\r\n                        key   : as_atom_node(),\r\n                        value : function_(AST_Accessor),\r\n                        end   : prev()\r\n                    }));\r\n                    continue;\r\n                }\r\n                if (name == \"set\") {\r\n                    a.push(new AST_ObjectSetter({\r\n                        start : start,\r\n                        key   : as_atom_node(),\r\n                        value : function_(AST_Accessor),\r\n                        end   : prev()\r\n                    }));\r\n                    continue;\r\n                }\r\n            }\r\n            expect(\":\");\r\n            a.push(new AST_ObjectKeyVal({\r\n                start : start,\r\n                quote : start.quote,\r\n                key   : name,\r\n                value : expression(false),\r\n                end   : prev()\r\n            }));\r\n        }\r\n        next();\r\n        return new AST_Object({ properties: a });\r\n    });\r\n\r\n    function as_property_name() {\r\n        var tmp = S.token;\r\n        next();\r\n        switch (tmp.type) {\r\n          case \"num\":\r\n          case \"string\":\r\n          case \"name\":\r\n          case \"operator\":\r\n          case \"keyword\":\r\n          case \"atom\":\r\n            return tmp.value;\r\n          default:\r\n            unexpected();\r\n        }\r\n    };\r\n\r\n    function as_name() {\r\n        var tmp = S.token;\r\n        next();\r\n        switch (tmp.type) {\r\n          case \"name\":\r\n          case \"operator\":\r\n          case \"keyword\":\r\n          case \"atom\":\r\n            return tmp.value;\r\n          default:\r\n            unexpected();\r\n        }\r\n    };\r\n\r\n    function _make_symbol(type) {\r\n        var name = S.token.value;\r\n        return new (name == \"this\" ? AST_This : type)({\r\n            name  : String(name),\r\n            start : S.token,\r\n            end   : S.token\r\n        });\r\n    };\r\n\r\n    function as_symbol(type, noerror) {\r\n        if (!is(\"name\")) {\r\n            if (!noerror) croak(\"Name expected\");\r\n            return null;\r\n        }\r\n        var sym = _make_symbol(type);\r\n        next();\r\n        return sym;\r\n    };\r\n\r\n    var subscripts = function(expr, allow_calls) {\r\n        var start = expr.start;\r\n        if (is(\"punc\", \".\")) {\r\n            next();\r\n            return subscripts(new AST_Dot({\r\n                start      : start,\r\n                expression : expr,\r\n                property   : as_name(),\r\n                end        : prev()\r\n            }), allow_calls);\r\n        }\r\n        if (is(\"punc\", \"[\")) {\r\n            next();\r\n            var prop = expression(true);\r\n            expect(\"]\");\r\n            return subscripts(new AST_Sub({\r\n                start      : start,\r\n                expression : expr,\r\n                property   : prop,\r\n                end        : prev()\r\n            }), allow_calls);\r\n        }\r\n        if (allow_calls && is(\"punc\", \"(\")) {\r\n            next();\r\n            return subscripts(new AST_Call({\r\n                start      : start,\r\n                expression : expr,\r\n                args       : expr_list(\")\"),\r\n                end        : prev()\r\n            }), true);\r\n        }\r\n        return expr;\r\n    };\r\n\r\n    var maybe_unary = function(allow_calls) {\r\n        var start = S.token;\r\n        if (is(\"operator\") && UNARY_PREFIX(start.value)) {\r\n            next();\r\n            handle_regexp();\r\n            var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));\r\n            ex.start = start;\r\n            ex.end = prev();\r\n            return ex;\r\n        }\r\n        var val = expr_atom(allow_calls);\r\n        while (is(\"operator\") && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {\r\n            val = make_unary(AST_UnaryPostfix, S.token.value, val);\r\n            val.start = start;\r\n            val.end = S.token;\r\n            next();\r\n        }\r\n        return val;\r\n    };\r\n\r\n    function make_unary(ctor, op, expr) {\r\n        if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\r\n            croak(\"Invalid use of \" + op + \" operator\");\r\n        return new ctor({ operator: op, expression: expr });\r\n    };\r\n\r\n    var expr_op = function(left, min_prec, no_in) {\r\n        var op = is(\"operator\") ? S.token.value : null;\r\n        if (op == \"in\" && no_in) op = null;\r\n        var prec = op != null ? PRECEDENCE[op] : null;\r\n        if (prec != null && prec > min_prec) {\r\n            next();\r\n            var right = expr_op(maybe_unary(true), prec, no_in);\r\n            return expr_op(new AST_Binary({\r\n                start    : left.start,\r\n                left     : left,\r\n                operator : op,\r\n                right    : right,\r\n                end      : right.end\r\n            }), min_prec, no_in);\r\n        }\r\n        return left;\r\n    };\r\n\r\n    function expr_ops(no_in) {\r\n        return expr_op(maybe_unary(true), 0, no_in);\r\n    };\r\n\r\n    var maybe_conditional = function(no_in) {\r\n        var start = S.token;\r\n        var expr = expr_ops(no_in);\r\n        if (is(\"operator\", \"?\")) {\r\n            next();\r\n            var yes = expression(false);\r\n            expect(\":\");\r\n            return new AST_Conditional({\r\n                start       : start,\r\n                condition   : expr,\r\n                consequent  : yes,\r\n                alternative : expression(false, no_in),\r\n                end         : prev()\r\n            });\r\n        }\r\n        return expr;\r\n    };\r\n\r\n    function is_assignable(expr) {\r\n        if (!options.strict) return true;\r\n        if (expr instanceof AST_This) return false;\r\n        return (expr instanceof AST_PropAccess || expr instanceof AST_Symbol);\r\n    };\r\n\r\n    var maybe_assign = function(no_in) {\r\n        var start = S.token;\r\n        var left = maybe_conditional(no_in), val = S.token.value;\r\n        if (is(\"operator\") && ASSIGNMENT(val)) {\r\n            if (is_assignable(left)) {\r\n                next();\r\n                return new AST_Assign({\r\n                    start    : start,\r\n                    left     : left,\r\n                    operator : val,\r\n                    right    : maybe_assign(no_in),\r\n                    end      : prev()\r\n                });\r\n            }\r\n            croak(\"Invalid assignment\");\r\n        }\r\n        return left;\r\n    };\r\n\r\n    var expression = function(commas, no_in) {\r\n        var start = S.token;\r\n        var expr = maybe_assign(no_in);\r\n        if (commas && is(\"punc\", \",\")) {\r\n            next();\r\n            return new AST_Seq({\r\n                start  : start,\r\n                car    : expr,\r\n                cdr    : expression(true, no_in),\r\n                end    : peek()\r\n            });\r\n        }\r\n        return expr;\r\n    };\r\n\r\n    function in_loop(cont) {\r\n        ++S.in_loop;\r\n        var ret = cont();\r\n        --S.in_loop;\r\n        return ret;\r\n    };\r\n\r\n    if (options.expression) {\r\n        return expression(true);\r\n    }\r\n\r\n    return (function(){\r\n        var start = S.token;\r\n        var body = [];\r\n        while (!is(\"eof\"))\r\n            body.push(statement());\r\n        var end = prev();\r\n        var toplevel = options.toplevel;\r\n        if (toplevel) {\r\n            toplevel.body = toplevel.body.concat(body);\r\n            toplevel.end = end;\r\n        } else {\r\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\r\n        }\r\n        return toplevel;\r\n    })();\r\n\r\n};\r\n\n/***********************************************************************\r\n\r\n  A JavaScript tokenizer / parser / beautifier / compressor.\r\n  https://github.com/mishoo/UglifyJS2\r\n\r\n  -------------------------------- (C) ---------------------------------\r\n\r\n                           Author: Mihai Bazon\r\n                         <mihai.bazon@gmail.com>\r\n                       http://mihai.bazon.net/blog\r\n\r\n  Distributed under the BSD license:\r\n\r\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions\r\n    are met:\r\n\r\n        * Redistributions of source code must retain the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer.\r\n\r\n        * Redistributions in binary form must reproduce the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer in the documentation and/or other materials\r\n          provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n    SUCH DAMAGE.\r\n\r\n ***********************************************************************/\r\n\r\n\"use strict\";\r\n\r\nfunction array_to_hash(a) {\r\n    var ret = Object.create(null);\r\n    for (var i = 0; i < a.length; ++i)\r\n        ret[a[i]] = true;\r\n    return ret;\r\n};\r\n\r\nfunction slice(a, start) {\r\n    return Array.prototype.slice.call(a, start || 0);\r\n};\r\n\r\nfunction characters(str) {\r\n    return str.split(\"\");\r\n};\r\n\r\nfunction member(name, array) {\r\n    for (var i = array.length; --i >= 0;)\r\n        if (array[i] == name)\r\n            return true;\r\n    return false;\r\n};\r\n\r\nfunction find_if(func, array) {\r\n    for (var i = 0, n = array.length; i < n; ++i) {\r\n        if (func(array[i]))\r\n            return array[i];\r\n    }\r\n};\r\n\r\nfunction repeat_string(str, i) {\r\n    if (i <= 0) return \"\";\r\n    if (i == 1) return str;\r\n    var d = repeat_string(str, i >> 1);\r\n    d += d;\r\n    if (i & 1) d += str;\r\n    return d;\r\n};\r\n\r\nfunction DefaultsError(msg, defs) {\r\n    Error.call(this, msg);\r\n    this.msg = msg;\r\n    this.defs = defs;\r\n};\r\nDefaultsError.prototype = Object.create(Error.prototype);\r\nDefaultsError.prototype.constructor = DefaultsError;\r\n\r\nDefaultsError.croak = function(msg, defs) {\r\n    throw new DefaultsError(msg, defs);\r\n};\r\n\r\nfunction defaults(args, defs, croak) {\r\n    if (args === true)\r\n        args = {};\r\n    var ret = args || {};\r\n    if (croak) for (var i in ret) if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))\r\n        DefaultsError.croak(\"`\" + i + \"` is not a supported option\", defs);\r\n    for (var i in defs) if (defs.hasOwnProperty(i)) {\r\n        ret[i] = (args && args.hasOwnProperty(i)) ? args[i] : defs[i];\r\n    }\r\n    return ret;\r\n};\r\n\r\nfunction merge(obj, ext) {\r\n    var count = 0;\r\n    for (var i in ext) if (ext.hasOwnProperty(i)) {\r\n        obj[i] = ext[i];\r\n        count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nfunction noop() {};\r\n\r\nvar MAP = (function(){\r\n    function MAP(a, f, backwards) {\r\n        var ret = [], top = [], i;\r\n        function doit() {\r\n            var val = f(a[i], i);\r\n            var is_last = val instanceof Last;\r\n            if (is_last) val = val.v;\r\n            if (val instanceof AtTop) {\r\n                val = val.v;\r\n                if (val instanceof Splice) {\r\n                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);\r\n                } else {\r\n                    top.push(val);\r\n                }\r\n            }\r\n            else if (val !== skip) {\r\n                if (val instanceof Splice) {\r\n                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);\r\n                } else {\r\n                    ret.push(val);\r\n                }\r\n            }\r\n            return is_last;\r\n        };\r\n        if (a instanceof Array) {\r\n            if (backwards) {\r\n                for (i = a.length; --i >= 0;) if (doit()) break;\r\n                ret.reverse();\r\n                top.reverse();\r\n            } else {\r\n                for (i = 0; i < a.length; ++i) if (doit()) break;\r\n            }\r\n        }\r\n        else {\r\n            for (i in a) if (a.hasOwnProperty(i)) if (doit()) break;\r\n        }\r\n        return top.concat(ret);\r\n    };\r\n    MAP.at_top = function(val) { return new AtTop(val) };\r\n    MAP.splice = function(val) { return new Splice(val) };\r\n    MAP.last = function(val) { return new Last(val) };\r\n    var skip = MAP.skip = {};\r\n    function AtTop(val) { this.v = val };\r\n    function Splice(val) { this.v = val };\r\n    function Last(val) { this.v = val };\r\n    return MAP;\r\n})();\r\n\r\nfunction push_uniq(array, el) {\r\n    if (array.indexOf(el) < 0)\r\n        array.push(el);\r\n};\r\n\r\nfunction string_template(text, props) {\r\n    return text.replace(/\\{(.+?)\\}/g, function(str, p){\r\n        return props[p];\r\n    });\r\n};\r\n\r\nfunction remove(array, el) {\r\n    for (var i = array.length; --i >= 0;) {\r\n        if (array[i] === el) array.splice(i, 1);\r\n    }\r\n};\r\n\r\nfunction mergeSort(array, cmp) {\r\n    if (array.length < 2) return array.slice();\r\n    function merge(a, b) {\r\n        var r = [], ai = 0, bi = 0, i = 0;\r\n        while (ai < a.length && bi < b.length) {\r\n            cmp(a[ai], b[bi]) <= 0\r\n                ? r[i++] = a[ai++]\r\n                : r[i++] = b[bi++];\r\n        }\r\n        if (ai < a.length) r.push.apply(r, a.slice(ai));\r\n        if (bi < b.length) r.push.apply(r, b.slice(bi));\r\n        return r;\r\n    };\r\n    function _ms(a) {\r\n        if (a.length <= 1)\r\n            return a;\r\n        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);\r\n        left = _ms(left);\r\n        right = _ms(right);\r\n        return merge(left, right);\r\n    };\r\n    return _ms(array);\r\n};\r\n\r\nfunction set_difference(a, b) {\r\n    return a.filter(function(el){\r\n        return b.indexOf(el) < 0;\r\n    });\r\n};\r\n\r\nfunction set_intersection(a, b) {\r\n    return a.filter(function(el){\r\n        return b.indexOf(el) >= 0;\r\n    });\r\n};\r\n\r\n// this function is taken from Acorn [1], written by Marijn Haverbeke\r\n// [1] https://github.com/marijnh/acorn\r\nfunction makePredicate(words) {\r\n    if (!(words instanceof Array)) words = words.split(\" \");\r\n    var f = \"\", cats = [];\r\n    out: for (var i = 0; i < words.length; ++i) {\r\n        for (var j = 0; j < cats.length; ++j)\r\n            if (cats[j][0].length == words[i].length) {\r\n                cats[j].push(words[i]);\r\n                continue out;\r\n            }\r\n        cats.push([words[i]]);\r\n    }\r\n    function compareTo(arr) {\r\n        if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\r\n        f += \"switch(str){\";\r\n        for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\r\n        f += \"return true}return false;\";\r\n    }\r\n    // When there are more than three length categories, an outer\r\n    // switch first dispatches on the lengths, to save on comparisons.\r\n    if (cats.length > 3) {\r\n        cats.sort(function(a, b) {return b.length - a.length;});\r\n        f += \"switch(str.length){\";\r\n        for (var i = 0; i < cats.length; ++i) {\r\n            var cat = cats[i];\r\n            f += \"case \" + cat[0].length + \":\";\r\n            compareTo(cat);\r\n        }\r\n        f += \"}\";\r\n        // Otherwise, simply generate a flat `switch` statement.\r\n    } else {\r\n        compareTo(words);\r\n    }\r\n    return new Function(\"str\", f);\r\n};\r\n\r\nfunction all(array, predicate) {\r\n    for (var i = array.length; --i >= 0;)\r\n        if (!predicate(array[i]))\r\n            return false;\r\n    return true;\r\n};\r\n\r\nfunction Dictionary() {\r\n    this._values = Object.create(null);\r\n    this._size = 0;\r\n};\r\nDictionary.prototype = {\r\n    set: function(key, val) {\r\n        if (!this.has(key)) ++this._size;\r\n        this._values[\"$\" + key] = val;\r\n        return this;\r\n    },\r\n    add: function(key, val) {\r\n        if (this.has(key)) {\r\n            this.get(key).push(val);\r\n        } else {\r\n            this.set(key, [ val ]);\r\n        }\r\n        return this;\r\n    },\r\n    get: function(key) { return this._values[\"$\" + key] },\r\n    del: function(key) {\r\n        if (this.has(key)) {\r\n            --this._size;\r\n            delete this._values[\"$\" + key];\r\n        }\r\n        return this;\r\n    },\r\n    has: function(key) { return (\"$\" + key) in this._values },\r\n    each: function(f) {\r\n        for (var i in this._values)\r\n            f(this._values[i], i.substr(1));\r\n    },\r\n    size: function() {\r\n        return this._size;\r\n    },\r\n    map: function(f) {\r\n        var ret = [];\r\n        for (var i in this._values)\r\n            ret.push(f(this._values[i], i.substr(1)));\r\n        return ret;\r\n    },\r\n    toObject: function() { return this._values }\r\n};\r\nDictionary.fromObject = function(obj) {\r\n    var dict = new Dictionary();\r\n    dict._size = merge(dict._values, obj);\r\n    return dict;\r\n};\r\n\n/* @license\r\n\r\n  Copyright (c) 2010 Mihai Bazon <mihai.bazon@gmail.com>\r\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\r\n  Based on parse-js (http://marijn.haverbeke.nl/parse-js/).\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions\r\n  are met:\r\n\r\n      * Redistributions of source code must retain the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer.\r\n\r\n      * Redistributions in binary form must reproduce the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer in the documentation and/or other materials\r\n        provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n  SUCH DAMAGE.\r\n*/\r\n\r\n\r\n/*\r\n * QML parser and parsetree'er.\r\n *\r\n * Based on Javascript parser written by Mihai Bazon for UglifyJS project.\r\n * That, again, is a port of Javascript parser by Marijn Haverbeke.\r\n * Big thanks to both of you (and others involved)!\r\n * UglifyJS: https://github.com/mishoo/UglifyJS\r\n * Marijn's parser: http://marijn.haverbeke.nl/parse-js/\r\n *\r\n * The primary goal of this file is to offer QML parsing *on top of UglifyJS\r\n * parser* and to change Javascript parts as little as possible. If you find\r\n * bugs/improvements to Javascript parsing parts, check if those are fixed to\r\n * UglifyJS parser first. If not, fix them there. After UglifyJS has been fixed,\r\n * backport the changes to this file. Less changes to Javascript, more easy it\r\n * will be to keep up with UglifyJS.\r\n * Ultimately it would be great to keep the original parser and QML additions in\r\n * different files but the structure of code does not support that.\r\n *\r\n * Exports:\r\n *\r\n * - QMLBinding(src, tree) to pass qml bindings along.\r\n *\r\n * - parseQML(src) -- parses QML source and returns it as output tree expected\r\n *   by the QML engine\r\n *\r\n * - qmlparse(src) -- parses QML source and returns tree a la uglifyjs parser.\r\n *   Currently used for debugging purposes.\r\n */\r\n\r\n// Object cloning for debug prints.\r\nfunction clone(obj){\r\n    if(obj == null || typeof(obj) != 'object')\r\n        return obj;\r\n\r\n    var temp = {}; // changed\r\n\r\n    for(var key in obj)\r\n        temp[key] = clone(obj[key]);\r\n    return temp;\r\n}\r\n\r\n/* -----[ Tokenizer (constants) ]----- */\r\n\r\nvar KEYWORDS = array_to_hash([\r\n        \"break\",\r\n        \"case\",\r\n        \"catch\",\r\n        \"const\",\r\n        \"continue\",\r\n        \"default\",\r\n        \"delete\",\r\n        \"do\",\r\n        \"else\",\r\n        \"finally\",\r\n        \"for\",\r\n        \"function\",\r\n        \"if\",\r\n        \"in\",\r\n        \"instanceof\",\r\n        \"new\",\r\n        \"return\",\r\n        \"switch\",\r\n        \"throw\",\r\n        \"try\",\r\n        \"typeof\",\r\n        \"var\",\r\n        \"void\",\r\n        \"while\",\r\n        \"with\"\r\n]);\r\n\r\nvar RESERVED_WORDS = array_to_hash([\r\n        \"abstract\",\r\n        \"boolean\",\r\n        \"byte\",\r\n        \"char\",\r\n        \"class\",\r\n        \"debugger\",\r\n        \"double\",\r\n        \"enum\",\r\n        \"export\",\r\n        \"extends\",\r\n        \"final\",\r\n        \"float\",\r\n        \"goto\",\r\n        \"implements\",\r\n        \"import\",\r\n        \"int\",\r\n        \"interface\",\r\n        \"long\",\r\n        \"native\",\r\n        \"package\",\r\n        \"private\",\r\n        \"protected\",\r\n        \"public\",\r\n        \"short\",\r\n        \"static\",\r\n        \"super\",\r\n        \"synchronized\",\r\n        \"throws\",\r\n        \"transient\",\r\n        \"volatile\"\r\n]);\r\n\r\nvar KEYWORDS_BEFORE_EXPRESSION = array_to_hash([\r\n        \"return\",\r\n        \"new\",\r\n        \"delete\",\r\n        \"throw\",\r\n        \"else\",\r\n        \"case\"\r\n]);\r\n\r\nvar KEYWORDS_ATOM = array_to_hash([\r\n        \"false\",\r\n        \"null\",\r\n        \"true\",\r\n        \"undefined\"\r\n]);\r\n\r\nvar OPERATOR_CHARS = array_to_hash(characters(\"+-*&%=<>!?|~^\"));\r\n\r\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\r\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\r\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\r\n\r\nvar OPERATORS = array_to_hash([\r\n        \"in\",\r\n        \"instanceof\",\r\n        \"typeof\",\r\n        \"new\",\r\n        \"void\",\r\n        \"delete\",\r\n        \"++\",\r\n        \"--\",\r\n        \"+\",\r\n        \"-\",\r\n        \"!\",\r\n        \"~\",\r\n        \"&\",\r\n        \"|\",\r\n        \"^\",\r\n        \"*\",\r\n        \"/\",\r\n        \"%\",\r\n        \">>\",\r\n        \"<<\",\r\n        \">>>\",\r\n        \"<\",\r\n        \">\",\r\n        \"<=\",\r\n        \">=\",\r\n        \"==\",\r\n        \"===\",\r\n        \"!=\",\r\n        \"!==\",\r\n        \"?\",\r\n        \"=\",\r\n        \"+=\",\r\n        \"-=\",\r\n        \"/=\",\r\n        \"*=\",\r\n        \"%=\",\r\n        \">>=\",\r\n        \"<<=\",\r\n        \">>>=\",\r\n        \"|=\",\r\n        \"^=\",\r\n        \"&=\",\r\n        \"&&\",\r\n        \"||\"\r\n]);\r\n\r\nvar WHITESPACE_CHARS = array_to_hash(characters(\" \\n\\r\\t\\u200b\"));\r\n\r\nvar PUNC_BEFORE_EXPRESSION = array_to_hash(characters(\"[{}(,.;:\"));\r\n\r\nvar PUNC_CHARS = array_to_hash(characters(\"[]{}(),;:\"));\r\n\r\nvar REGEXP_MODIFIERS = array_to_hash(characters(\"gmsiy\"));\r\n\r\n/* -----[ Tokenizer ]----- */\r\n\r\n// regexps adapted from http://xregexp.com/plugins/#unicode\r\nvar UNICODE = {\r\n        letter: new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\"),\r\n        non_spacing_mark: new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\"),\r\n        space_combining_mark: new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\"),\r\n        connector_punctuation: new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\")\r\n};\r\n\r\nfunction is_letter(ch) {\r\n        return UNICODE.letter.test(ch);\r\n};\r\n\r\nfunction is_digit(ch) {\r\n        ch = ch.charCodeAt(0);\r\n        return ch >= 48 && ch <= 57; //XXX: find out if \"UnicodeDigit\" means something else than 0..9\r\n};\r\n\r\nfunction is_alphanumeric_char(ch) {\r\n        return is_digit(ch) || is_letter(ch);\r\n};\r\n\r\nfunction is_unicode_combining_mark(ch) {\r\n        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\r\n};\r\n\r\nfunction is_unicode_connector_punctuation(ch) {\r\n        return UNICODE.connector_punctuation.test(ch);\r\n};\r\n\r\nfunction is_identifier_start(ch) {\r\n        return ch == \"$\" || ch == \"_\" || is_letter(ch);\r\n};\r\n\r\nfunction is_identifier_char(ch) {\r\n        return is_identifier_start(ch)\r\n                || is_unicode_combining_mark(ch)\r\n                || is_digit(ch)\r\n                || is_unicode_connector_punctuation(ch)\r\n                || ch == \"\\u200c\" // zero-width non-joiner <ZWNJ>\r\n                || ch == \"\\u200d\" // zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\r\n        ;\r\n};\r\n\r\nfunction parse_js_number(num) {\r\n        if (RE_HEX_NUMBER.test(num)) {\r\n                return parseInt(num.substr(2), 16);\r\n        } else if (RE_OCT_NUMBER.test(num)) {\r\n                return parseInt(num.substr(1), 8);\r\n        } else if (RE_DEC_NUMBER.test(num)) {\r\n                return parseFloat(num);\r\n        }\r\n};\r\n\r\nfunction JS_Parse_Error(message, line, col, pos, comment) {\r\n        this.message = message;\r\n        this.line = line + 1;\r\n        this.col = col;\r\n        this.pos = pos;\r\n        this.comment = comment ? comment : \"\";\r\n        try {\r\n                ({})();\r\n        } catch(ex) {\r\n                this.stack = ex.stack;\r\n        };\r\n};\r\n\r\nJS_Parse_Error.prototype.toString = function() {\r\n        return this.message + \" (line: \" + this.line + \", col: \" + this.col + \", pos: \" + this.pos + \")\" + \"\\n\" + this.comment + \"\\n\" + this.stack;\r\n};\r\n\r\nfunction js_error(message, line, col, pos, comment) {\r\n        throw new JS_Parse_Error(message, line, col, pos, comment);\r\n};\r\n\r\nfunction is_token(token, type, val) {\r\n        return token.type == type && (val == null || token.value == val);\r\n};\r\n\r\nfunction extractLinesForErrorDiag(text, line)\r\n{\r\n  var r = \"\";\r\n  var lines = text.split(\"\\n\");\r\n\r\n  for (var i = line - 3; i <= line + 3; i++)\r\n  if (i >= 0 && i < lines.length ) {\r\n      var mark = ( i == line ) ? \">>\" : \"  \";\r\n      r += mark + i + \"  \" + lines[i] + \"\\n\";\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\nvar EX_EOF = {};\r\n\r\nfunction tokenizer($TEXT) {\r\n\r\n        var S = {\r\n                text            : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\r\n                pos             : 0,\r\n                tokpos          : 0,\r\n                line            : 0,\r\n                tokline         : 0,\r\n                col             : 0,\r\n                tokcol          : 0,\r\n                newline_before  : false,\r\n                regex_allowed   : false,\r\n                comments_before : []\r\n        };\r\n\r\n        function peek() { return S.text.charAt(S.pos); };\r\n\r\n        function next(signal_eof) {\r\n                var ch = S.text.charAt(S.pos++);\r\n                if (signal_eof && !ch)\r\n                        throw EX_EOF;\r\n                if (ch == \"\\n\") {\r\n                        S.newline_before = true;\r\n                        ++S.line;\r\n                        S.col = 0;\r\n                } else {\r\n                        ++S.col;\r\n                }\r\n                return ch;\r\n        };\r\n\r\n        function eof() {\r\n                return !S.peek();\r\n        };\r\n\r\n        function find(what, signal_eof) {\r\n                var pos = S.text.indexOf(what, S.pos);\r\n                if (signal_eof && pos == -1) throw EX_EOF;\r\n                return pos;\r\n        };\r\n\r\n        function start_token() {\r\n                S.tokline = S.line;\r\n                S.tokcol = S.col;\r\n                S.tokpos = S.pos;\r\n        };\r\n\r\n        function token(type, value, is_comment) {\r\n                S.regex_allowed = ((type == \"operator\" && !HOP(UNARY_POSTFIX, value)) ||\r\n                                   (type == \"keyword\" && HOP(KEYWORDS_BEFORE_EXPRESSION, value)) ||\r\n                                   (type == \"punc\" && HOP(PUNC_BEFORE_EXPRESSION, value)));\r\n                var ret = {\r\n                        type  : type,\r\n                        value : value,\r\n                        line  : S.tokline,\r\n                        col   : S.tokcol,\r\n                        pos   : S.tokpos,\r\n                        nlb   : S.newline_before\r\n                };\r\n                if (!is_comment) {\r\n                        ret.comments_before = S.comments_before;\r\n                        S.comments_before = [];\r\n                }\r\n                S.newline_before = false;\r\n                return ret;\r\n        };\r\n\r\n        function skip_whitespace() {\r\n                while (HOP(WHITESPACE_CHARS, peek()))\r\n                        next();\r\n        };\r\n\r\n        function read_while(pred) {\r\n                var ret = \"\", ch = peek(), i = 0;\r\n                while (ch && pred(ch, i++)) {\r\n                        ret += next();\r\n                        ch = peek();\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        function parse_error(err) {\r\n                js_error(err, S.tokline, S.tokcol, S.tokpos, extractLinesForErrorDiag( S.text, S.tokline ) );\r\n        };\r\n\r\n        function read_num(prefix) {\r\n                var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\r\n                var num = read_while(function(ch, i){\r\n                        if (ch == \"x\" || ch == \"X\") {\r\n                                if (has_x) return false;\r\n                                return has_x = true;\r\n                        }\r\n                        if (!has_x && (ch == \"E\" || ch == \"e\")) {\r\n                                if (has_e) return false;\r\n                                return has_e = after_e = true;\r\n                        }\r\n                        if (ch == \"-\") {\r\n                                if (after_e || (i == 0 && !prefix)) return true;\r\n                                return false;\r\n                        }\r\n                        if (ch == \"+\") return after_e;\r\n                        after_e = false;\r\n                        if (ch == \".\") {\r\n                                if (!has_dot && !has_x)\r\n                                        return has_dot = true;\r\n                                return false;\r\n                        }\r\n                        return is_alphanumeric_char(ch);\r\n                });\r\n                if (prefix)\r\n                        num = prefix + num;\r\n                var valid = parse_js_number(num);\r\n                if (!isNaN(valid)) {\r\n                        return token(\"num\", valid);\r\n                } else {\r\n                        parse_error(\"Invalid syntax: \" + num);\r\n                }\r\n        };\r\n\r\n        function read_escaped_char() {\r\n                var ch = next(true);\r\n                switch (ch) {\r\n                    case \"n\" : return \"\\n\";\r\n                    case \"r\" : return \"\\r\";\r\n                    case \"t\" : return \"\\t\";\r\n                    case \"b\" : return \"\\b\";\r\n                    case \"v\" : return \"\\v\";\r\n                    case \"f\" : return \"\\f\";\r\n                    case \"0\" : return \"\\0\";\r\n                    case \"x\" : return String.fromCharCode(hex_bytes(2));\r\n                    case \"u\" : return String.fromCharCode(hex_bytes(4));\r\n                    case \"\\n\": return \"\";\r\n                    default  : return ch;\r\n                }\r\n        };\r\n\r\n        function hex_bytes(n) {\r\n                var num = 0;\r\n                for (; n > 0; --n) {\r\n                        var digit = parseInt(next(true), 16);\r\n                        if (isNaN(digit))\r\n                                parse_error(\"Invalid hex-character pattern in string\");\r\n                        num = (num << 4) | digit;\r\n                }\r\n                return num;\r\n        };\r\n\r\n        function read_string() {\r\n                return with_eof_error(\"Unterminated string constant\", function(){\r\n                        var quote = next(), ret = \"\";\r\n                        for (;;) {\r\n                                var ch = next(true);\r\n                                if (ch == \"\\\\\") ch = read_escaped_char();\r\n                                else if (ch == quote) break;\r\n                                ret += ch;\r\n                        }\r\n                        return token(\"string\", ret);\r\n                });\r\n        };\r\n\r\n        function read_line_comment() {\r\n                next();\r\n                var i = find(\"\\n\"), ret;\r\n                if (i == -1) {\r\n                        ret = S.text.substr(S.pos);\r\n                        S.pos = S.text.length;\r\n                } else {\r\n                        ret = S.text.substring(S.pos, i);\r\n                        S.pos = i;\r\n                }\r\n                return token(\"comment1\", ret, true);\r\n        };\r\n\r\n        function read_multiline_comment() {\r\n                next();\r\n                return with_eof_error(\"Unterminated multiline comment\", function(){\r\n                        var i = find(\"*/\", true),\r\n                            text = S.text.substring(S.pos, i),\r\n                            tok = token(\"comment2\", text, true);\r\n                        S.pos = i + 2;\r\n                        S.line += text.split(\"\\n\").length - 1;\r\n                        S.newline_before = text.indexOf(\"\\n\") >= 0;\r\n\r\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/100\r\n                        if (/^@cc_on/i.test(text)) {\r\n                                warn(\"WARNING: at line \" + S.line);\r\n                                warn(\"*** Found \\\"conditional comment\\\": \" + text);\r\n                                warn(\"*** UglifyJS DISCARDS ALL COMMENTS.  This means your code might no longer work properly in Internet Explorer.\");\r\n                        }\r\n\r\n                        return tok;\r\n                });\r\n        };\r\n\r\n        function read_name() {\r\n                var backslash = false, name = \"\", ch;\r\n                while ((ch = peek()) != null) {\r\n                        if (!backslash) {\r\n                                if (ch == \"\\\\\") backslash = true, next();\r\n                                else if (is_identifier_char(ch)) name += next();\r\n                                else break;\r\n                        }\r\n                        else {\r\n                                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\r\n                                ch = read_escaped_char();\r\n                                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\r\n                                name += ch;\r\n                                backslash = false;\r\n                        }\r\n                }\r\n                return name;\r\n        };\r\n\r\n        function read_regexp() {\r\n                return with_eof_error(\"Unterminated regular expression\", function(){\r\n                        var prev_backslash = false, regexp = \"\", ch, in_class = false;\r\n                        while ((ch = next(true))) if (prev_backslash) {\r\n                                regexp += \"\\\\\" + ch;\r\n                                prev_backslash = false;\r\n                        } else if (ch == \"[\") {\r\n                                in_class = true;\r\n                                regexp += ch;\r\n                        } else if (ch == \"]\" && in_class) {\r\n                                in_class = false;\r\n                                regexp += ch;\r\n                        } else if (ch == \"/\" && !in_class) {\r\n                                break;\r\n                        } else if (ch == \"\\\\\") {\r\n                                prev_backslash = true;\r\n                        } else {\r\n                                regexp += ch;\r\n                        }\r\n                        var mods = read_name();\r\n                        return token(\"regexp\", [ regexp, mods ]);\r\n                });\r\n        };\r\n\r\n        function read_operator(prefix) {\r\n                function grow(op) {\r\n                        if (!peek()) return op;\r\n                        var bigger = op + peek();\r\n                        if (HOP(OPERATORS, bigger)) {\r\n                                next();\r\n                                return grow(bigger);\r\n                        } else {\r\n                                return op;\r\n                        }\r\n                };\r\n                return token(\"operator\", grow(prefix || next()));\r\n        };\r\n\r\n        function handle_slash() {\r\n                next();\r\n                var regex_allowed = S.regex_allowed;\r\n                switch (peek()) {\r\n                    case \"/\":\r\n                        S.comments_before.push(read_line_comment());\r\n                        S.regex_allowed = regex_allowed;\r\n                        return next_token();\r\n                    case \"*\":\r\n                        S.comments_before.push(read_multiline_comment());\r\n                        S.regex_allowed = regex_allowed;\r\n                        return next_token();\r\n                }\r\n                return S.regex_allowed ? read_regexp() : read_operator(\"/\");\r\n        };\r\n\r\n        function handle_dot() {\r\n                next();\r\n                return is_digit(peek())\r\n                        ? read_num(\".\")\r\n                        : token(\"punc\", \".\");\r\n        };\r\n\r\n        function read_word() {\r\n                var word = read_name();\r\n                return !HOP(KEYWORDS, word)\r\n                        ? token(\"name\", word)\r\n                        : HOP(OPERATORS, word)\r\n                        ? token(\"operator\", word)\r\n                        : HOP(KEYWORDS_ATOM, word)\r\n                        ? token(\"atom\", word)\r\n                        : token(\"keyword\", word);\r\n        };\r\n\r\n        function with_eof_error(eof_error, cont) {\r\n                try {\r\n                        return cont();\r\n                } catch(ex) {\r\n                        if (ex === EX_EOF) parse_error(eof_error);\r\n                        else throw ex;\r\n                }\r\n        };\r\n\r\n        function next_token(force_regexp) {\r\n                if (force_regexp)\r\n                        return read_regexp();\r\n                skip_whitespace();\r\n                start_token();\r\n                var ch = peek();\r\n                if (!ch) return token(\"eof\");\r\n                if (is_digit(ch)) return read_num();\r\n                if (ch == '\"' || ch == \"'\") return read_string();\r\n                if (HOP(PUNC_CHARS, ch)) return token(\"punc\", next());\r\n                if (ch == \".\") return handle_dot();\r\n                if (ch == \"/\") return handle_slash();\r\n                if (HOP(OPERATOR_CHARS, ch)) return read_operator();\r\n                if (ch == \"\\\\\" || is_identifier_start(ch)) return read_word();\r\n                parse_error(\"Unexpected character '\" + ch + \"'\");\r\n        };\r\n\r\n        next_token.context = function(nc) {\r\n                if (nc) S = nc;\r\n                return S;\r\n        };\r\n\r\n        return next_token;\r\n\r\n};\r\n\r\n/* -----[ Parser (constants) ]----- */\r\n\r\nvar UNARY_PREFIX = array_to_hash([\r\n        \"typeof\",\r\n        \"void\",\r\n        \"delete\",\r\n        \"--\",\r\n        \"++\",\r\n        \"!\",\r\n        \"~\",\r\n        \"-\",\r\n        \"+\"\r\n]);\r\n\r\nvar UNARY_POSTFIX = array_to_hash([ \"--\", \"++\" ]);\r\n\r\nvar ASSIGNMENT = (function(a, ret, i){\r\n        while (i < a.length) {\r\n                ret[a[i]] = a[i].substr(0, a[i].length - 1);\r\n                i++;\r\n        }\r\n        return ret;\r\n})(\r\n        [\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\"],\r\n        { \"=\": true },\r\n        0\r\n);\r\n\r\nvar PRECEDENCE = (function(a, ret){\r\n        for (var i = 0, n = 1; i < a.length; ++i, ++n) {\r\n                var b = a[i];\r\n                for (var j = 0; j < b.length; ++j) {\r\n                        ret[b[j]] = n;\r\n                }\r\n        }\r\n        return ret;\r\n})(\r\n        [\r\n                [\"||\"],\r\n                [\"&&\"],\r\n                [\"|\"],\r\n                [\"^\"],\r\n                [\"&\"],\r\n                [\"==\", \"===\", \"!=\", \"!==\"],\r\n                [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\r\n                [\">>\", \"<<\", \">>>\"],\r\n                [\"+\", \"-\"],\r\n                [\"*\", \"/\", \"%\"]\r\n        ],\r\n        {}\r\n);\r\n\r\nvar STATEMENTS_WITH_LABELS = array_to_hash([ \"for\", \"do\", \"while\", \"switch\" ]);\r\n\r\nvar ATOMIC_START_TOKEN = array_to_hash([ \"atom\", \"num\", \"string\", \"regexp\", \"name\" ]);\r\n\r\n/* -----[ Parser ]----- */\r\n\r\nfunction NodeWithToken(str, start, end) {\r\n        this.name = str;\r\n        this.start = start;\r\n        this.end = end;\r\n};\r\n\r\nNodeWithToken.prototype.toString = function() { return this.name; };\r\n\r\nfunction qmlparse($TEXT, exigent_mode, embed_tokens) {\r\n\r\n        var S = {\r\n                text        : $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/^\\uFEFF/, ''),\r\n                input       : typeof $TEXT == \"string\" ? tokenizer($TEXT, true) : $TEXT,\r\n                token       : null,\r\n                prev        : null,\r\n                peeked      : null,\r\n                in_function : 0,\r\n                in_loop     : 0,\r\n                labels      : []\r\n        };\r\n\r\n        S.token = next();\r\n\r\n        function is(type, value) {\r\n                return is_token(S.token, type, value);\r\n        };\r\n\r\n        function peek() { return S.peeked || (S.peeked = S.input()); };\r\n\r\n        function next() {\r\n                S.prev = S.token;\r\n                if (S.peeked) {\r\n                        S.token = S.peeked;\r\n                        S.peeked = null;\r\n                } else {\r\n                        S.token = S.input();\r\n                }\r\n                return S.token;\r\n        };\r\n\r\n        function prev() {\r\n                return S.prev;\r\n        };\r\n\r\n        function croak(msg, line, col, pos) {\r\n                var ctx = S.input.context();\r\n                var eLine = (line != null ? line : ctx.tokline);\r\n                js_error(msg,\r\n                         eLine,\r\n                         col != null ? col : ctx.tokcol,\r\n                         pos != null ? pos : ctx.tokpos,\r\n                         extractLinesForErrorDiag( S.text, eLine ) );\r\n        };\r\n\r\n        function token_error(token, msg) {\r\n                croak(msg, token.line, token.col);\r\n        };\r\n\r\n        function unexpected(token) {\r\n                if (token == null)\r\n                        token = S.token;\r\n                token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\r\n        };\r\n\r\n        function expect_token(type, val) {\r\n                if (is(type, val)) {\r\n                        return next();\r\n                }\r\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" \" + S.token.val + \", expected \" + type + \" \" + val);\r\n        };\r\n\r\n        function expect(punc) { return expect_token(\"punc\", punc); };\r\n\r\n        function can_insert_semicolon() {\r\n                return !exigent_mode && (\r\n                        S.token.nlb || is(\"eof\") || is(\"punc\", \"}\")\r\n                );\r\n        };\r\n\r\n        function semicolon() {\r\n                if (is(\"punc\", \";\")) next();\r\n                else if (!can_insert_semicolon()) unexpected();\r\n        };\r\n\r\n        function as() {\r\n                return slice(arguments);\r\n        };\r\n\r\n        function parenthesised() {\r\n                expect(\"(\");\r\n                var ex = expression();\r\n                expect(\")\");\r\n                return ex;\r\n        };\r\n\r\n        function add_tokens(str, start, end) {\r\n                return str instanceof NodeWithToken ? str : new NodeWithToken(str, start, end);\r\n        };\r\n\r\n        function maybe_embed_tokens(parser) {\r\n                if (embed_tokens) return function() {\r\n                        var start = S.token;\r\n                        var ast = parser.apply(this, arguments);\r\n                        ast[0] = add_tokens(ast[0], start, prev());\r\n                        return ast;\r\n                };\r\n                else return parser;\r\n        };\r\n\r\n        var statement = maybe_embed_tokens(function() {\r\n                if (is(\"operator\", \"/\")) {\r\n                        S.peeked = null;\r\n                        S.token = S.input(true); // force regexp\r\n                }\r\n                switch (S.token.type) {\r\n                    case \"num\":\r\n                    case \"string\":\r\n                    case \"regexp\":\r\n                    case \"operator\":\r\n                    case \"atom\":\r\n                        return simple_statement();\r\n\r\n                    case \"name\":\r\n                        return is_token(peek(), \"punc\", \":\")\r\n                                ? labeled_statement(prog1(S.token.value, next, next))\r\n                                : simple_statement();\r\n\r\n                    case \"punc\":\r\n                        switch (S.token.value) {\r\n                            case \"{\":\r\n                                return as(\"block\", block_());\r\n                            case \"[\":\r\n                            case \"(\":\r\n                                return simple_statement();\r\n                            case \";\":\r\n                                next();\r\n                                return as(\"block\");\r\n                            default:\r\n                                unexpected();\r\n                        }\r\n\r\n                    case \"keyword\":\r\n                        switch (prog1(S.token.value, next)) {\r\n                            case \"break\":\r\n                                return break_cont(\"break\");\r\n\r\n                            case \"continue\":\r\n                                return break_cont(\"continue\");\r\n\r\n                            case \"debugger\":\r\n                                semicolon();\r\n                                return as(\"debugger\");\r\n\r\n                            case \"do\":\r\n                                return (function(body){\r\n                                        expect_token(\"keyword\", \"while\");\r\n                                        return as(\"do\", prog1(parenthesised, semicolon), body);\r\n                                })(in_loop(statement));\r\n\r\n                            case \"for\":\r\n                                return for_();\r\n\r\n                            case \"function\":\r\n                                return function_(true);\r\n\r\n                            case \"if\":\r\n                                return if_();\r\n\r\n                            case \"return\":\r\n                                if (S.in_function == 0)\r\n                                        croak(\"'return' outside of function\");\r\n                                return as(\"return\",\r\n                                          is(\"punc\", \";\")\r\n                                          ? (next(), null)\r\n                                          : can_insert_semicolon()\r\n                                          ? null\r\n                                          : prog1(expression, semicolon));\r\n\r\n                            case \"switch\":\r\n                                return as(\"switch\", parenthesised(), switch_block_());\r\n\r\n                            case \"throw\":\r\n                                return as(\"throw\", prog1(expression, semicolon));\r\n\r\n                            case \"try\":\r\n                                return try_();\r\n\r\n                            case \"var\":\r\n                                return prog1(var_, semicolon);\r\n\r\n                            case \"const\":\r\n                                return prog1(const_, semicolon);\r\n\r\n                            case \"while\":\r\n                                return as(\"while\", parenthesised(), in_loop(statement));\r\n\r\n                            case \"with\":\r\n                                return as(\"with\", parenthesised(), statement());\r\n\r\n                            default:\r\n                                unexpected();\r\n                        }\r\n                }\r\n        });\r\n\r\n        function labeled_statement(label) {\r\n                S.labels.push(label);\r\n                var start = S.token, stat = statement();\r\n                if (exigent_mode && !HOP(STATEMENTS_WITH_LABELS, stat[0]))\r\n                        unexpected(start);\r\n                S.labels.pop();\r\n                return as(\"label\", label, stat);\r\n        };\r\n\r\n        function simple_statement() {\r\n                return as(\"stat\", prog1(expression, semicolon));\r\n        };\r\n\r\n        function break_cont(type) {\r\n                var name = is(\"name\") ? S.token.value : null;\r\n                if (name != null) {\r\n                        next();\r\n                        if (!member(name, S.labels))\r\n                                croak(\"Label \" + name + \" without matching loop or statement\");\r\n                }\r\n                else if (S.in_loop == 0)\r\n                        croak(type + \" not inside a loop or switch\");\r\n                semicolon();\r\n                return as(type, name);\r\n        };\r\n\r\n        function for_() {\r\n                expect(\"(\");\r\n                var init = null;\r\n                if (!is(\"punc\", \";\")) {\r\n                        init = is(\"keyword\", \"var\")\r\n                                ? (next(), var_(true))\r\n                                : expression(true, true);\r\n                        if (is(\"operator\", \"in\"))\r\n                                return for_in(init);\r\n                }\r\n                return regular_for(init);\r\n        };\r\n\r\n        function regular_for(init) {\r\n                expect(\";\");\r\n                var test = is(\"punc\", \";\") ? null : expression();\r\n                expect(\";\");\r\n                var step = is(\"punc\", \")\") ? null : expression();\r\n                expect(\")\");\r\n                return as(\"for\", init, test, step, in_loop(statement));\r\n        };\r\n\r\n        function for_in(init) {\r\n                var lhs = init[0] == \"var\" ? as(\"name\", init[1][0]) : init;\r\n                next();\r\n                var obj = expression();\r\n                expect(\")\");\r\n                return as(\"for-in\", init, lhs, obj, in_loop(statement));\r\n        };\r\n\r\n        var function_ = maybe_embed_tokens(function(in_statement) {\r\n                var name = is(\"name\") ? prog1(S.token.value, next) : null;\r\n                if (in_statement && !name)\r\n                        unexpected();\r\n                expect(\"(\");\r\n                return as(in_statement ? \"defun\" : \"function\",\r\n                          name,\r\n                          // arguments\r\n                          (function(first, a){\r\n                                  while (!is(\"punc\", \")\")) {\r\n                                          if (first) first = false; else expect(\",\");\r\n                                          if (!is(\"name\")) unexpected();\r\n                                          a.push(S.token.value);\r\n                                          next();\r\n                                  }\r\n                                  next();\r\n                                  return a;\r\n                          })(true, []),\r\n                          // body\r\n                          (function(){\r\n                                  ++S.in_function;\r\n                                  var loop = S.in_loop;\r\n                                  S.in_loop = 0;\r\n                                  var a = block_();\r\n                                  --S.in_function;\r\n                                  S.in_loop = loop;\r\n                                  return a;\r\n                          })());\r\n        });\r\n\r\n        function if_() {\r\n                var cond = parenthesised(), body = statement(), belse;\r\n                if (is(\"keyword\", \"else\")) {\r\n                        next();\r\n                        belse = statement();\r\n                }\r\n                return as(\"if\", cond, body, belse);\r\n        };\r\n\r\n        function block_() {\r\n                expect(\"{\");\r\n                var a = [];\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (is(\"eof\")) unexpected();\r\n                        a.push(statement());\r\n                }\r\n                next();\r\n                return a;\r\n        };\r\n\r\n        var switch_block_ = curry(in_loop, function(){\r\n                expect(\"{\");\r\n                var a = [], cur = null;\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (is(\"eof\")) unexpected();\r\n                        if (is(\"keyword\", \"case\")) {\r\n                                next();\r\n                                cur = [];\r\n                                a.push([ expression(), cur ]);\r\n                                expect(\":\");\r\n                        }\r\n                        else if (is(\"keyword\", \"default\")) {\r\n                                next();\r\n                                expect(\":\");\r\n                                cur = [];\r\n                                a.push([ null, cur ]);\r\n                        }\r\n                        else {\r\n                                if (!cur) unexpected();\r\n                                cur.push(statement());\r\n                        }\r\n                }\r\n                next();\r\n                return a;\r\n        });\r\n\r\n        function try_() {\r\n                var body = block_(), bcatch, bfinally;\r\n                if (is(\"keyword\", \"catch\")) {\r\n                        next();\r\n                        expect(\"(\");\r\n                        if (!is(\"name\"))\r\n                                croak(\"Name expected\");\r\n                        var name = S.token.value;\r\n                        next();\r\n                        expect(\")\");\r\n                        bcatch = [ name, block_() ];\r\n                }\r\n                if (is(\"keyword\", \"finally\")) {\r\n                        next();\r\n                        bfinally = block_();\r\n                }\r\n                if (!bcatch && !bfinally)\r\n                        croak(\"Missing catch/finally blocks\");\r\n                return as(\"try\", body, bcatch, bfinally);\r\n        };\r\n\r\n        function vardefs(no_in) {\r\n                var a = [];\r\n                for (;;) {\r\n                        if (!is(\"name\"))\r\n                                unexpected();\r\n                        var name = S.token.value;\r\n                        next();\r\n                        if (is(\"operator\", \"=\")) {\r\n                                next();\r\n                                a.push([ name, expression(false, no_in) ]);\r\n                        } else {\r\n                                a.push([ name ]);\r\n                        }\r\n                        if (!is(\"punc\", \",\"))\r\n                                break;\r\n                        next();\r\n                }\r\n                return a;\r\n        };\r\n\r\n        function var_(no_in) {\r\n                return as(\"var\", vardefs(no_in));\r\n        };\r\n\r\n        function const_() {\r\n                return as(\"const\", vardefs());\r\n        };\r\n\r\n        function new_() {\r\n                var newexp = expr_atom(false), args;\r\n                if (is(\"punc\", \"(\")) {\r\n                        next();\r\n                        args = expr_list(\")\");\r\n                } else {\r\n                        args = [];\r\n                }\r\n                return subscripts(as(\"new\", newexp, args), true);\r\n        };\r\n\r\n        var expr_atom = maybe_embed_tokens(function(allow_calls) {\r\n                if (is(\"operator\", \"new\")) {\r\n                        next();\r\n                        return new_();\r\n                }\r\n                if (is(\"operator\") && HOP(UNARY_PREFIX, S.token.value)) {\r\n                        return make_unary(\"unary-prefix\",\r\n                                          prog1(S.token.value, next),\r\n                                          expr_atom(allow_calls));\r\n                }\r\n                if (is(\"punc\")) {\r\n                        switch (S.token.value) {\r\n                            case \"(\":\r\n                                next();\r\n                                return subscripts(prog1(expression, curry(expect, \")\")), allow_calls);\r\n                            case \"[\":\r\n                                next();\r\n                                return subscripts(array_(), allow_calls);\r\n                            case \"{\":\r\n                                next();\r\n                                return subscripts(object_(), allow_calls);\r\n                        }\r\n                        unexpected();\r\n                }\r\n                if (is(\"keyword\", \"function\")) {\r\n                        next();\r\n                        return subscripts(function_(false), allow_calls);\r\n                }\r\n                if (HOP(ATOMIC_START_TOKEN, S.token.type)) {\r\n                        var atom = S.token.type == \"regexp\"\r\n                                ? as(\"regexp\", S.token.value[0], S.token.value[1])\r\n                                : as(S.token.type, S.token.value);\r\n                        return subscripts(prog1(atom, next), allow_calls);\r\n                }\r\n                unexpected();\r\n        });\r\n\r\n        function expr_list(closing, allow_trailing_comma, allow_empty) {\r\n                var first = true, a = [];\r\n                while (!is(\"punc\", closing)) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (allow_trailing_comma && is(\"punc\", closing)) break;\r\n                        if (is(\"punc\", \",\") && allow_empty) {\r\n                                a.push([ \"atom\", \"undefined\" ]);\r\n                        } else {\r\n                                a.push(expression(false));\r\n                        }\r\n                }\r\n                next();\r\n                return a;\r\n        };\r\n\r\n        function array_() {\r\n                var from = S.token.pos,\r\n                    stat = expr_list(\"]\", !exigent_mode, true),\r\n                    to = S.token.pos;\r\n                return as(\"array\", stat, \"[\" + S.text.substr(from, to - from));\r\n        };\r\n\r\n        function object_() {\r\n                var first = true, a = [];\r\n                while (!is(\"punc\", \"}\")) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (!exigent_mode && is(\"punc\", \"}\"))\r\n                                // allow trailing comma\r\n                                break;\r\n                        var type = S.token.type;\r\n                        var name = as_property_name();\r\n                        if (type == \"name\" && (name == \"get\" || name == \"set\") && !is(\"punc\", \":\")) {\r\n                                a.push([ as_name(), function_(false), name ]);\r\n                        } else {\r\n                                expect(\":\");\r\n                                a.push([ name, expression(false) ]);\r\n                        }\r\n                }\r\n                next();\r\n                return as(\"object\", a);\r\n        };\r\n\r\n        function as_property_name() {\r\n                switch (S.token.type) {\r\n                    case \"num\":\r\n                    case \"string\":\r\n                        return prog1(S.token.value, next);\r\n                }\r\n                return as_name();\r\n        };\r\n\r\n        function as_name() {\r\n                switch (S.token.type) {\r\n                    case \"name\":\r\n                    case \"operator\":\r\n                    case \"keyword\":\r\n                    case \"atom\":\r\n                        return prog1(S.token.value, next);\r\n                    default:\r\n                        unexpected();\r\n                }\r\n        };\r\n\r\n        function subscripts(expr, allow_calls) {\r\n                if (is(\"punc\", \".\")) {\r\n                        next();\r\n                        return subscripts(as(\"dot\", expr, as_name()), allow_calls);\r\n                }\r\n                if (is(\"punc\", \"[\")) {\r\n                        next();\r\n                        return subscripts(as(\"sub\", expr, prog1(expression, curry(expect, \"]\"))), allow_calls);\r\n                }\r\n                if (allow_calls && is(\"punc\", \"(\")) {\r\n                        next();\r\n                        return subscripts(as(\"call\", expr, expr_list(\")\")), true);\r\n                }\r\n                if (allow_calls && is(\"operator\") && HOP(UNARY_POSTFIX, S.token.value)) {\r\n                        return prog1(curry(make_unary, \"unary-postfix\", S.token.value, expr),\r\n                                     next);\r\n                }\r\n                return expr;\r\n        };\r\n\r\n        function make_unary(tag, op, expr) {\r\n                if ((op == \"++\" || op == \"--\") && !is_assignable(expr))\r\n                        croak(\"Invalid use of \" + op + \" operator\");\r\n                return as(tag, op, expr);\r\n        };\r\n\r\n        function expr_op(left, min_prec, no_in) {\r\n                var op = is(\"operator\") ? S.token.value : null;\r\n                if (op && op == \"in\" && no_in) op = null;\r\n                var prec = op != null ? PRECEDENCE[op] : null;\r\n                if (prec != null && prec > min_prec) {\r\n                        next();\r\n                        var right = expr_op(expr_atom(true), prec, no_in);\r\n                        return expr_op(as(\"binary\", op, left, right), min_prec, no_in);\r\n                }\r\n                return left;\r\n        };\r\n\r\n        function expr_ops(no_in) {\r\n                return expr_op(expr_atom(true), 0, no_in);\r\n        };\r\n\r\n        function maybe_conditional(no_in) {\r\n                var expr = expr_ops(no_in);\r\n                if (is(\"operator\", \"?\")) {\r\n                        next();\r\n                        var yes = expression(false);\r\n                        expect(\":\");\r\n                        return as(\"conditional\", expr, yes, expression(false, no_in));\r\n                }\r\n                return expr;\r\n        };\r\n\r\n        function is_assignable(expr) {\r\n                if (!exigent_mode) return true;\r\n                switch (expr[0]) {\r\n                    case \"dot\":\r\n                    case \"sub\":\r\n                    case \"new\":\r\n                    case \"call\":\r\n                        return true;\r\n                    case \"name\":\r\n                        return expr[1] != \"this\";\r\n                }\r\n        };\r\n\r\n        function maybe_assign(no_in) {\r\n                var left = maybe_conditional(no_in), val = S.token.value;\r\n                if (is(\"operator\") && HOP(ASSIGNMENT, val)) {\r\n                        if (is_assignable(left)) {\r\n                                next();\r\n                                return as(\"assign\", ASSIGNMENT[val], left, maybe_assign(no_in));\r\n                        }\r\n                        croak(\"Invalid assignment\");\r\n                }\r\n                return left;\r\n        };\r\n\r\n        function maybe_qmlelem(no_in) {\r\n                var expr = maybe_assign(no_in);\r\n                if (is(\"punc\", \"{\"))\r\n                    return as(\"qmlelem\", expr[1], undefined, qmlblock());\r\n                return expr;\r\n        };\r\n\r\n        var expression = maybe_embed_tokens(function(commas, no_in) {\r\n                if (arguments.length == 0)\r\n                        commas = true;\r\n                var expr = maybe_qmlelem(no_in);\r\n                if (commas && is(\"punc\", \",\")) {\r\n                        next();\r\n                        return as(\"seq\", expr, expression(true, no_in));\r\n                }\r\n                return expr;\r\n        });\r\n\r\n        function in_loop(cont) {\r\n                try {\r\n                        ++S.in_loop;\r\n                        return cont();\r\n                } finally {\r\n                        --S.in_loop;\r\n                }\r\n        };\r\n\r\n        function qml_is_element(str) {\r\n            return str[0].toUpperCase() == str[0];\r\n        }\r\n\r\n        function qmlblock() {\r\n            expect(\"{\");\r\n            var a = [];\r\n            while (!is(\"punc\", \"}\")) {\r\n                if (is(\"eof\")) unexpected();\r\n                a.push(qmlstatement());\r\n            }\r\n            expect(\"}\");\r\n            return a;\r\n        }\r\n\r\n        function qmlproperty() {\r\n            switch (S.token.type) {\r\n                case \"name\":\r\n                    return as(\"qmlbinding\", statement());\r\n                case \"num\":\r\n                case \"string\":\r\n                    return as(\"qmlvalue\", prog1(S.token.value, next,\r\n                        semicolon));\r\n                default:\r\n                    todo();\r\n            }\r\n        }\r\n\r\n        function qmlpropdef() {\r\n            var type = S.token.value;\r\n            next();\r\n            var name = S.token.value;\r\n            next();\r\n            if (type == \"alias\") {\r\n                expect(\":\");\r\n                if (!is(\"name\")) unexpected();\r\n                var objName = S.token.value;\r\n                next();\r\n                if (is(\"punc\", \".\")) {\r\n                    next();\r\n                    if (!is(\"name\")) unexpected();\r\n                    var propName = S.token.value;\r\n                    next();\r\n                }\r\n                return as(\"qmlaliasdef\", name, objName, propName);\r\n            }\r\n            if (is(\"punc\", \":\")) {\r\n                next();\r\n                S.in_function++;\r\n                var from = S.token.pos,\r\n                    stat = statement(),\r\n                    to = S.token.pos;\r\n                S.in_function--;\r\n                return as(\"qmlpropdef\", name, type, stat,\r\n                        S.text.substr(from, to - from));\r\n            } else if (is(\"punc\", \";\"))\r\n                next();\r\n            return as(\"qmlpropdef\", name, type);\r\n\r\n        }\r\n\r\n        function qmldefaultprop() {\r\n            next();\r\n            expect_token(\"name\", \"property\");\r\n\r\n            return as(\"qmldefaultprop\", qmlpropdef());\r\n        }\r\n\r\n        function qmlsignaldef() {\r\n            var name = S.token.value;\r\n            next();\r\n            var args = [];\r\n            if (is(\"punc\", \"(\")) {\r\n                next();\r\n                var first = true;\r\n                while (!is(\"punc\", \")\")) {\r\n                        if (first) first = false; else expect(\",\");\r\n                        if (!is(\"name\")) unexpected();\r\n                        var type = S.token.value;\r\n                        next();\r\n                        if (!is(\"name\")) unexpected();\r\n                        args.push({type: type, name: S.token.value});\r\n                        next();\r\n                }\r\n                next();\r\n            }\r\n            if (is(\"punc\", \";\"))\r\n                next();\r\n            return as(\"qmlsignaldef\", name, args);\r\n\r\n        }\r\n\r\n        function qmlstatement() {\r\n            if (is(\"keyword\", \"function\")) {\r\n                var from = S.token.pos;\r\n                next();\r\n                var stat = function_(true);\r\n                var to = S.token.pos;\r\n                var name = stat[1];\r\n                return as(\"qmlmethod\", name, stat,\r\n                    S.text.substr(from, to - from));\r\n            } else if (is(\"name\", \"signal\")) {\r\n                next();\r\n                if (is(\"punc\", \":\")) {\r\n                    next();\r\n                    S.in_function++;\r\n                    var from = S.token.pos,\r\n                        stat = statement(),\r\n                        to = S.token.pos;\r\n                    S.in_function--;\r\n                    return as(\"qmlprop\", propname, stat,\r\n                        S.text.substr(from, to - from));\r\n                } else {\r\n                    return qmlsignaldef();\r\n                }\r\n            } else if (S.token.type == \"name\") {\r\n                var propname = S.token.value;\r\n                next();\r\n                if (propname == \"property\" && (S.token.type == \"name\" || S.token.value == \"var\")) {\r\n                    return qmlpropdef();\r\n                } else if (qml_is_element(propname) && !is(\"punc\", \".\")) {\r\n                    // Element\r\n                    var onProp;\r\n                    if (is(\"name\", \"on\")) {\r\n                        next();\r\n                        onProp = S.token.value;\r\n                        next();\r\n                    }\r\n                    return as(\"qmlelem\", propname, onProp, qmlblock());\r\n                } else {\r\n                    // property statement\r\n                    if (is(\"punc\", \".\")) {\r\n                        // anchors, fonts etc, a.b: statement;\r\n                        // Can also be Component.onCompleted: ...\r\n                        // Assume only one subproperty\r\n                        next();\r\n                        var subname = S.token.value;\r\n                        next();\r\n                        expect(\":\");\r\n                        S.in_function++;\r\n                        var from = S.token.pos,\r\n                            stat = statement(),\r\n                            to = S.token.pos;\r\n                        S.in_function--;\r\n                        return as(\"qmlobjdef\", propname, subname, stat,\r\n                            S.text.substr(from, to - from));\r\n                    } else if (is(\"punc\", \"{\")) {\r\n                        return as(\"qmlobj\", propname, qmlblock());\r\n                    } else {\r\n                        // Evaluatable item\r\n                        expect(\":\");\r\n                        S.in_function++;\r\n                        var from = S.token.pos,\r\n                            stat = statement(),\r\n                            to = S.token.pos;\r\n                        S.in_function--;\r\n                        return as(\"qmlprop\", propname, stat,\r\n                            S.text.substr(from, to - from));\r\n                    }\r\n                }\r\n            } else if (is(\"keyword\", \"default\")) {\r\n                return qmldefaultprop();\r\n            } else {\r\n                todo();\r\n            }\r\n        }\r\n\r\n        function qmlimport() {\r\n            // todo\r\n            next();\r\n            var moduleName = S.token.value;\r\n            var isDottedNotation = (S.token.type == \"name\");\r\n            next();\r\n            \r\n            while (is(\"punc\", \".\")) {\r\n                next();\r\n                moduleName += \".\" + S.token.value;\r\n                next();\r\n            }\r\n            if (is(\"num\")) {\r\n                var version = S.token.value\r\n                next();\r\n            }\r\n            var namespace = \"\";\r\n            if (is(\"name\", \"as\")) {\r\n                next();\r\n                namespace = S.token.value;\r\n                next();\r\n            }\r\n            return as(\"qmlimport\", moduleName, version, namespace, isDottedNotation);\r\n        }\r\n\r\n        function qmldocument() {\r\n            var imports = [];\r\n            while (is(\"name\", \"import\")) {\r\n                imports.push(qmlimport());\r\n            }\r\n            var root = qmlstatement();\r\n            if (!is(\"eof\"))\r\n                unexpected();\r\n\r\n            return as(\"toplevel\", imports, root);\r\n        }\r\n\r\n        function amIn(s) {\r\n            console && console.log(s, clone(S), S.token.type, S.token.value);\r\n        }\r\n        function todo() {\r\n            amIn(\"todo parse:\");\r\n            next();\r\n        }\r\n\r\n        return qmldocument();\r\n\r\n};\r\n\r\n/* -----[ Utilities ]----- */\r\n\r\nfunction curry(f) {\r\n        var args = slice(arguments, 1);\r\n        return function() { return f.apply(this, args.concat(slice(arguments))); };\r\n};\r\n\r\nfunction prog1(ret) {\r\n        if (ret instanceof Function)\r\n                ret = ret();\r\n        for (var i = 1, n = arguments.length; --n > 0; ++i)\r\n                arguments[i]();\r\n        return ret;\r\n};\r\n\r\nfunction array_to_hash(a) {\r\n        var ret = {};\r\n        for (var i = 0; i < a.length; ++i)\r\n                ret[a[i]] = true;\r\n        return ret;\r\n};\r\n\r\nfunction slice(a, start) {\r\n        return Array.prototype.slice.call(a, start == null ? 0 : start);\r\n};\r\n\r\nfunction characters(str) {\r\n        return str.split(\"\");\r\n};\r\n\r\nfunction member(name, array) {\r\n        for (var i = array.length; --i >= 0;)\r\n                if (array[i] === name)\r\n                        return true;\r\n        return false;\r\n};\r\n\r\nfunction HOP(obj, prop) {\r\n        return Object.prototype.hasOwnProperty.call(obj, prop);\r\n};\r\n\r\nvar warn = function() {};\r\n\r\nQMLMethod.prototype = new QMLBinding();\r\nfunction QMLMethod(src) {\r\n    this.src = src;\r\n}\r\n\r\n/**\r\n * Create an object representing a QML property definition.\r\n * @param {String} type The type of the property\r\n * @param {Array} value The default value of the property\r\n * @return {Object} Object representing the defintion\r\n */\r\nfunction QMLPropertyDefinition(type, value) {\r\n    this.type = type;\r\n    this.value = value;\r\n}\r\n\r\nfunction QMLAliasDefinition(objName, propName) {\r\n    this.objectName = objName;\r\n    this.propertyName = propName;\r\n}\r\n\r\n/**\r\n * Create an object representing a QML signal definition.\r\n * @param {Array} params The parameters the signal ships\r\n * @return {Object} Object representing the defintion\r\n */\r\nfunction QMLSignalDefinition(params) {\r\n    this.parameters = params;\r\n}\r\n\r\n/**\r\n * Create an object representing a group of QML properties (like anchors).\r\n * @return {Object} Object representing the group\r\n */\r\nfunction QMLMetaPropertyGroup() {}\r\n\r\n/**\r\n * Create an object representing a QML element.\r\n * @param {String} type The type of the element\r\n * @param {String} onProp The name of the property specified with the \"on\" keyword\r\n */\r\nfunction QMLMetaElement(type, onProp) {\r\n    this.$class = type;\r\n    this.$children = [];\r\n    this.$on = onProp;\r\n}\r\n\r\n// Convert parser tree to the format understood by engine\r\nfunction convertToEngine(tree) {\r\n\r\n    // Help logger\r\n    function amIn(str, tree) {\r\n        console.log(str);\r\n        if (tree) console.log(JSON.stringify(tree, null, \"  \"));\r\n    }\r\n\r\n    var walkers = {\r\n        \"toplevel\": function(imports, statement) {\r\n            var item = { $class: \"QMLDocument\" };\r\n            item.$imports = imports;\r\n            item.$children = [ walk(statement) ];\r\n            return item;\r\n        },\r\n        \"qmlelem\": function(elem, onProp, statements) {\r\n            var item = new QMLMetaElement(elem, onProp);\r\n\r\n            for (var i in statements) {\r\n                var statement = statements[i],\r\n                    name = statement[1],\r\n                    val = walk(statement);\r\n                switch (statement[0]) {\r\n                    case \"qmldefaultprop\":\r\n                        item.$defaultProperty = name;\r\n                    case \"qmlprop\":\r\n                    case \"qmlpropdef\":\r\n                    case \"qmlaliasdef\":\r\n                    case \"qmlmethod\":\r\n                    case \"qmlsignaldef\":\r\n                        item[name] = val;\r\n                        break;\r\n                    case \"qmlelem\":\r\n                        item.$children.push(val);\r\n                        break;\r\n                    case \"qmlobjdef\":\r\n                        // Create object to item\r\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\r\n                        item[name][statement[2]] = val;\r\n                        break;\r\n                    case \"qmlobj\":\r\n                        // Create object to item\r\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\r\n                        for (var i in val)\r\n                            item[name][i] = val[i];\r\n                        break;\r\n                    default:\r\n                        console.log(\"Unknown statement\", statement);\r\n\r\n                }\r\n            }\r\n            // Make $children be either a single item or an array, if it's more than one\r\n            if (item.$children.length === 1)\r\n                item.$children = item.$children[0];\r\n\r\n            return item;\r\n        },\r\n        \"qmlprop\": function(name, tree, src) {\r\n            if (name == \"id\") {\r\n                // id property\r\n                return tree[1][1];\r\n            }\r\n            return bindout(tree, src);\r\n        },\r\n        \"qmlobjdef\": function(name, property, tree, src) {\r\n            return bindout(tree, src);\r\n        },\r\n        \"qmlobj\": function(elem, statements) {\r\n            var item = {};\r\n\r\n            for (var i in statements) {\r\n                var statement = statements[i],\r\n                    name = statement[1],\r\n                    val = walk(statement);\r\n                if (statement[0] == \"qmlprop\")\r\n                    item[name] = val;\r\n            }\r\n\r\n            return item;\r\n        },\r\n        \"qmlmethod\": function(name, tree, src) {\r\n            return new QMLMethod(src);\r\n        },\r\n        \"qmlpropdef\": function(name, type, tree, src) {\r\n            return new QMLPropertyDefinition(type, tree ? bindout(tree, src) : \"\");\r\n        },\r\n        \"qmlaliasdef\": function(name, objName, propName) {\r\n            return new QMLAliasDefinition(objName, propName);\r\n        },\r\n        \"qmlsignaldef\": function(name, params) {\r\n            return new QMLSignalDefinition(params);\r\n        },\r\n        \"qmldefaultprop\": function(tree) {\r\n            return walk(tree);\r\n        },\r\n        \"name\": function(src) {\r\n            if (src == \"true\" || src == \"false\")\r\n                return src == \"true\";\r\n            return new QMLBinding(src, [\"name\", src]);\r\n        },\r\n        \"num\": function(src) {\r\n            return +src;\r\n        },\r\n        \"string\": function(src) {\r\n            return String(src);\r\n        },\r\n        \"array\": function(tree, src) {\r\n            var a = [];\r\n            var isList = false;\r\n            var hasBinding = false;\r\n            for (var i in tree) {\r\n                var val = bindout(tree[i]);\r\n                a.push(val);\r\n\r\n                if (val instanceof QMLMetaElement)\r\n                    isList = true;\r\n                else if (val instanceof QMLBinding)\r\n                    hasBinding = true;\r\n            }\r\n\r\n            if (hasBinding) {\r\n                if (isList)\r\n                    throw new TypeError(\"An array may either contain bindings or Element definitions.\");\r\n                return new QMLBinding(src, tree);\r\n            }\r\n\r\n            return a;\r\n        }\r\n    };\r\n\r\n    function walk(tree) {\r\n        var type = tree[0];\r\n        var walker = walkers[type];\r\n        if (!walker) {\r\n            console.log(\"No walker for \" + type);\r\n            return;\r\n        } else {\r\n            return walker.apply(type, tree.slice(1));\r\n        }\r\n    }\r\n\r\n    return walk(tree);\r\n\r\n    // Try to bind out tree and return static variable instead of binding\r\n    function bindout(tree, binding) {\r\n        if (tree[0] === \"stat\") // We want to process the content of the statement\r\n            tree = tree[1];     // (but still handle the case, we get the content directly)\r\n        var type = tree[0];\r\n        var walker = walkers[type];\r\n        if (walker) {\r\n            return walker.apply(type, tree.slice(1));\r\n        } else {\r\n            return new QMLBinding(binding, tree);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Function to parse qml and output tree expected by engine\r\nfunction parseQML(src) {\r\n    var parsetree = qmlparse(src);\r\n    return convertToEngine(parsetree);\r\n}\r\n\r\nif (typeof global != \"undefined\") {\r\n  global.qmlparse = qmlparse;\r\n}\r\n\n/***********************************************************************\r\n\r\n  A JavaScript tokenizer / parser / beautifier / compressor.\r\n\r\n  This version is suitable for Node.js.  With minimal changes (the\r\n  exports stuff) it should work on any JS platform.\r\n\r\n  This file implements some AST processors.  They work on data built\r\n  by parse-js.\r\n\r\n  Exported functions:\r\n\r\n    - ast_mangle(ast, options) -- mangles the variable/function names\r\n      in the AST.  Returns an AST.\r\n\r\n    - ast_squeeze(ast) -- employs various optimizations to make the\r\n      final generated code even smaller.  Returns an AST.\r\n\r\n    - gen_code(ast, options) -- generates JS code from the AST.  Pass\r\n      true (or an object, see the code for some options) as second\r\n      argument to get \"pretty\" (indented) code.\r\n\r\n  -------------------------------- (C) ---------------------------------\r\n\r\n                           Author: Mihai Bazon\r\n                         <mihai.bazon@gmail.com>\r\n                       http://mihai.bazon.net/blog\r\n\r\n  Distributed under the BSD license:\r\n\r\n    Copyright 2011 (c) Lauri Paimen <lauri@paimen.info>\r\n    Copyright 2010 (c) Mihai Bazon <mihai.bazon@gmail.com>\r\n\r\n    Redistribution and use in source and binary forms, with or without\r\n    modification, are permitted provided that the following conditions\r\n    are met:\r\n\r\n        * Redistributions of source code must retain the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer.\r\n\r\n        * Redistributions in binary form must reproduce the above\r\n          copyright notice, this list of conditions and the following\r\n          disclaimer in the documentation and/or other materials\r\n          provided with the distribution.\r\n\r\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n    SUCH DAMAGE.\r\n\r\n ***********************************************************************/\r\n\r\n/*\r\n * Based on Javascript parser written by Mihai Bazon for UglifyJS project.\r\n * That, again, is a port of Javascript parser by Marijn Haverbeke.\r\n * Big thanks to both of you (and others involved)!\r\n * UglifyJS: https://github.com/mishoo/UglifyJS\r\n * Marijn's parser: http://marijn.haverbeke.nl/parse-js/\r\n *\r\n * The primary goal of this file is to offer QML parsing *on top of UglifyJS\r\n * parser* and to change Javascript parts as little as possible. If you find\r\n * bugs/improvements to Javascript parsing parts, check if those are fixed to\r\n * UglifyJS parser first. If not, fix them there. After UglifyJS has been fixed,\r\n * backport the changes to this file. Less changes to Javascript, more easy it\r\n * will be to keep up with UglifyJS.\r\n * Ultimately it would be great to keep the original parser and QML additions in\r\n * different files but the structure of code does not support that.\r\n */\r\n\r\n/*\r\nvar jsp = require(\"./parse-js\"),\r\n    slice = jsp.slice,\r\n    member = jsp.member,\r\n    PRECEDENCE = jsp.PRECEDENCE,\r\n    OPERATORS = jsp.OPERATORS;\r\n*/\r\n\r\n/* -----[ helper for AST traversal ]----- */\r\n\r\nfunction ast_walker(ast) {\r\n        function _vardefs(defs) {\r\n                return [ this[0], MAP(defs, function(def){\r\n                        var a = [ def[0] ];\r\n                        if (def.length > 1)\r\n                                a[1] = walk(def[1]);\r\n                        return a;\r\n                }) ];\r\n        };\r\n        function _block(statements) {\r\n                var out = [ this[0] ];\r\n                if (statements != null)\r\n                        out.push(MAP(statements, walk));\r\n                return out;\r\n        };\r\n        var walkers = {\r\n                \"string\": function(str) {\r\n                        return [ this[0], str ];\r\n                },\r\n                \"num\": function(num) {\r\n                        return [ this[0], num ];\r\n                },\r\n                \"name\": function(name) {\r\n                        return [ this[0], name ];\r\n                },\r\n                \"toplevel\": function(statements) {\r\n                        return [ this[0], MAP(statements, walk) ];\r\n                },\r\n                \"block\": _block,\r\n                \"splice\": _block,\r\n                \"var\": _vardefs,\r\n                \"const\": _vardefs,\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                this[0],\r\n                                MAP(t, walk),\r\n                                c != null ? [ c[0], MAP(c[1], walk) ] : null,\r\n                                f != null ? MAP(f, walk) : null\r\n                        ];\r\n                },\r\n                \"throw\": function(expr) {\r\n                        return [ this[0], walk(expr) ];\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        return [ this[0], walk(ctor), MAP(args, walk) ];\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        return [ this[0], walk(expr), MAP(body, function(branch){\r\n                                return [ branch[0] ? walk(branch[0]) : null,\r\n                                         MAP(branch[1], walk) ];\r\n                        }) ];\r\n                },\r\n                \"break\": function(label) {\r\n                        return [ this[0], label ];\r\n                },\r\n                \"continue\": function(label) {\r\n                        return [ this[0], label ];\r\n                },\r\n                \"conditional\": function(cond, t, e) {\r\n                        return [ this[0], walk(cond), walk(t), walk(e) ];\r\n                },\r\n                \"assign\": function(op, lvalue, rvalue) {\r\n                        return [ this[0], op, walk(lvalue), walk(rvalue) ];\r\n                },\r\n                \"dot\": function(expr) {\r\n                        return [ this[0], walk(expr) ].concat(slice(arguments, 1));\r\n                },\r\n                \"call\": function(expr, args) {\r\n                        return [ this[0], walk(expr), MAP(args, walk) ];\r\n                },\r\n                \"function\": function(name, args, body) {\r\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\r\n                },\r\n                \"defun\": function(name, args, body) {\r\n                        return [ this[0], name, args.slice(), MAP(body, walk) ];\r\n                },\r\n                \"if\": function(conditional, t, e) {\r\n                        return [ this[0], walk(conditional), walk(t), walk(e) ];\r\n                },\r\n                \"for\": function(init, cond, step, block) {\r\n                        return [ this[0], walk(init), walk(cond), walk(step), walk(block) ];\r\n                },\r\n                \"for-in\": function(vvar, key, hash, block) {\r\n                        return [ this[0], walk(vvar), walk(key), walk(hash), walk(block) ];\r\n                },\r\n                \"while\": function(cond, block) {\r\n                        return [ this[0], walk(cond), walk(block) ];\r\n                },\r\n                \"do\": function(cond, block) {\r\n                        return [ this[0], walk(cond), walk(block) ];\r\n                },\r\n                \"return\": function(expr) {\r\n                        return [ this[0], walk(expr) ];\r\n                },\r\n                \"binary\": function(op, left, right) {\r\n                        return [ this[0], op, walk(left), walk(right) ];\r\n                },\r\n                \"unary-prefix\": function(op, expr) {\r\n                        return [ this[0], op, walk(expr) ];\r\n                },\r\n                \"unary-postfix\": function(op, expr) {\r\n                        return [ this[0], op, walk(expr) ];\r\n                },\r\n                \"sub\": function(expr, subscript) {\r\n                        return [ this[0], walk(expr), walk(subscript) ];\r\n                },\r\n                \"object\": function(props) {\r\n                        return [ this[0], MAP(props, function(p){\r\n                                return p.length == 2\r\n                                        ? [ p[0], walk(p[1]) ]\r\n                                        : [ p[0], walk(p[1]), p[2] ]; // get/set-ter\r\n                        }) ];\r\n                },\r\n                \"regexp\": function(rx, mods) {\r\n                        return [ this[0], rx, mods ];\r\n                },\r\n                \"array\": function(elements) {\r\n                        return [ this[0], MAP(elements, walk) ];\r\n                },\r\n                \"stat\": function(stat) {\r\n                        return [ this[0], walk(stat) ];\r\n                },\r\n                \"seq\": function() {\r\n                        return [ this[0] ].concat(MAP(slice(arguments), walk));\r\n                },\r\n                \"label\": function(name, block) {\r\n                        return [ this[0], name, walk(block) ];\r\n                },\r\n                \"with\": function(expr, block) {\r\n                        return [ this[0], walk(expr), walk(block) ];\r\n                },\r\n                \"atom\": function(name) {\r\n                        return [ this[0], name ];\r\n                }\r\n        };\r\n\r\n        var user = {};\r\n        var stack = [];\r\n        function walk(ast) {\r\n                if (ast == null)\r\n                        return null;\r\n                try {\r\n                        stack.push(ast);\r\n                        var type = ast[0];\r\n                        var gen = user[type];\r\n                        if (gen) {\r\n                                var ret = gen.apply(ast, ast.slice(1));\r\n                                if (ret != null)\r\n                                        return ret;\r\n                        }\r\n                        gen = walkers[type];\r\n                        return gen.apply(ast, ast.slice(1));\r\n                } finally {\r\n                        stack.pop();\r\n                }\r\n        };\r\n\r\n        function with_walkers(walkers, cont){\r\n                var save = {}, i;\r\n                for (i in walkers) if (HOP(walkers, i)) {\r\n                        save[i] = user[i];\r\n                        user[i] = walkers[i];\r\n                }\r\n                var ret = cont();\r\n                for (i in save) if (HOP(save, i)) {\r\n                        if (!save[i]) delete user[i];\r\n                        else user[i] = save[i];\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        return {\r\n                walk: walk,\r\n                with_walkers: with_walkers,\r\n                parent: function() {\r\n                        return stack[stack.length - 2]; // last one is current node\r\n                },\r\n                stack: function() {\r\n                        return stack;\r\n                }\r\n        };\r\n};\r\n\r\n/* -----[ Scope and mangling ]----- */\r\n\r\nfunction Scope(parent) {\r\n        this.names = {};        // names defined in this scope\r\n        this.mangled = {};      // mangled names (orig.name => mangled)\r\n        this.rev_mangled = {};  // reverse lookup (mangled => orig.name)\r\n        this.cname = -1;        // current mangled name\r\n        this.refs = {};         // names referenced from this scope\r\n        this.uses_with = false; // will become TRUE if with() is detected in this or any subscopes\r\n        this.uses_eval = false; // will become TRUE if eval() is detected in this or any subscopes\r\n        this.parent = parent;   // parent scope\r\n        this.children = [];     // sub-scopes\r\n        if (parent) {\r\n                this.level = parent.level + 1;\r\n                parent.children.push(this);\r\n        } else {\r\n                this.level = 0;\r\n        }\r\n};\r\n\r\nvar base54 = (function(){\r\n        var DIGITS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\";\r\n        return function(num) {\r\n                var ret = \"\";\r\n                do {\r\n                        ret = DIGITS.charAt(num % 54) + ret;\r\n                        num = Math.floor(num / 54);\r\n                } while (num > 0);\r\n                return ret;\r\n        };\r\n})();\r\n\r\nScope.prototype = {\r\n        has: function(name) {\r\n                for (var s = this; s; s = s.parent)\r\n                        if (HOP(s.names, name))\r\n                                return s;\r\n        },\r\n        has_mangled: function(mname) {\r\n                for (var s = this; s; s = s.parent)\r\n                        if (HOP(s.rev_mangled, mname))\r\n                                return s;\r\n        },\r\n        toJSON: function() {\r\n                return {\r\n                        names: this.names,\r\n                        uses_eval: this.uses_eval,\r\n                        uses_with: this.uses_with\r\n                };\r\n        },\r\n\r\n        next_mangled: function() {\r\n                // we must be careful that the new mangled name:\r\n                //\r\n                // 1. doesn't shadow a mangled name from a parent\r\n                //    scope, unless we don't reference the original\r\n                //    name from this scope OR from any sub-scopes!\r\n                //    This will get slow.\r\n                //\r\n                // 2. doesn't shadow an original name from a parent\r\n                //    scope, in the event that the name is not mangled\r\n                //    in the parent scope and we reference that name\r\n                //    here OR IN ANY SUBSCOPES!\r\n                //\r\n                // 3. doesn't shadow a name that is referenced but not\r\n                //    defined (possibly global defined elsewhere).\r\n                for (;;) {\r\n                        var m = base54(++this.cname), prior;\r\n\r\n                        // case 1.\r\n                        prior = this.has_mangled(m);\r\n                        if (prior && this.refs[prior.rev_mangled[m]] === prior)\r\n                                continue;\r\n\r\n                        // case 2.\r\n                        prior = this.has(m);\r\n                        if (prior && prior !== this && this.refs[m] === prior && !prior.has_mangled(m))\r\n                                continue;\r\n\r\n                        // case 3.\r\n                        if (HOP(this.refs, m) && this.refs[m] == null)\r\n                                continue;\r\n\r\n                        // I got \"do\" once. :-/\r\n                        if (!is_identifier(m))\r\n                                continue;\r\n\r\n                        return m;\r\n                }\r\n        },\r\n        set_mangle: function(name, m) {\r\n                this.rev_mangled[m] = name;\r\n                return this.mangled[name] = m;\r\n        },\r\n        get_mangled: function(name, newMangle) {\r\n                if (this.uses_eval || this.uses_with) return name; // no mangle if eval or with is in use\r\n                var s = this.has(name);\r\n                if (!s) return name; // not in visible scope, no mangle\r\n                if (HOP(s.mangled, name)) return s.mangled[name]; // already mangled in this scope\r\n                if (!newMangle) return name;                      // not found and no mangling requested\r\n                return s.set_mangle(name, s.next_mangled());\r\n        },\r\n        references: function(name) {\r\n                return name && !this.parent || this.uses_with || this.uses_eval || this.refs[name];\r\n        },\r\n        define: function(name, type) {\r\n                if (name != null) {\r\n                        if (type == \"var\" || !HOP(this.names, name))\r\n                                this.names[name] = type || \"var\";\r\n                        return name;\r\n                }\r\n        }\r\n};\r\n\r\nfunction ast_add_scope(ast) {\r\n\r\n        var current_scope = null;\r\n        var w = ast_walker(), walk = w.walk;\r\n        var having_eval = [];\r\n\r\n        function with_new_scope(cont) {\r\n                current_scope = new Scope(current_scope);\r\n                var ret = current_scope.body = cont();\r\n                ret.scope = current_scope;\r\n                current_scope = current_scope.parent;\r\n                return ret;\r\n        };\r\n\r\n        function define(name, type) {\r\n                return current_scope.define(name, type);\r\n        };\r\n\r\n        function reference(name) {\r\n                current_scope.refs[name] = true;\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\";\r\n                return [ this[0], is_defun ? define(name, \"defun\") : name, args, with_new_scope(function(){\r\n                        if (!is_defun) define(name, \"lambda\");\r\n                        MAP(args, function(name){ define(name, \"arg\") });\r\n                        return MAP(body, walk);\r\n                })];\r\n        };\r\n\r\n        function _vardefs(type) {\r\n                return function(defs) {\r\n                        MAP(defs, function(d){\r\n                                define(d[0], type);\r\n                                if (d[1]) reference(d[0]);\r\n                        });\r\n                };\r\n        };\r\n\r\n        return with_new_scope(function(){\r\n                // process AST\r\n                var ret = w.with_walkers({\r\n                        \"function\": _lambda,\r\n                        \"defun\": _lambda,\r\n                        \"label\": function(name, stat) { define(name, \"label\") },\r\n                        \"break\": function(label) { if (label) reference(label) },\r\n                        \"continue\": function(label) { if (label) reference(label) },\r\n                        \"with\": function(expr, block) {\r\n                                for (var s = current_scope; s; s = s.parent)\r\n                                        s.uses_with = true;\r\n                        },\r\n                        \"var\": _vardefs(\"var\"),\r\n                        \"const\": _vardefs(\"const\"),\r\n                        \"try\": function(t, c, f) {\r\n                                if (c != null) return [\r\n                                        this[0],\r\n                                        MAP(t, walk),\r\n                                        [ define(c[0], \"catch\"), MAP(c[1], walk) ],\r\n                                        f != null ? MAP(f, walk) : null\r\n                                ];\r\n                        },\r\n                        \"name\": function(name) {\r\n                                if (name == \"eval\")\r\n                                        having_eval.push(current_scope);\r\n                                reference(name);\r\n                        }\r\n                }, function(){\r\n                        return walk(ast);\r\n                });\r\n\r\n                // the reason why we need an additional pass here is\r\n                // that names can be used prior to their definition.\r\n\r\n                // scopes where eval was detected and their parents\r\n                // are marked with uses_eval, unless they define the\r\n                // \"eval\" name.\r\n                MAP(having_eval, function(scope){\r\n                        if (!scope.has(\"eval\")) while (scope) {\r\n                                scope.uses_eval = true;\r\n                                scope = scope.parent;\r\n                        }\r\n                });\r\n\r\n                // for referenced names it might be useful to know\r\n                // their origin scope.  current_scope here is the\r\n                // toplevel one.\r\n                function fixrefs(scope, i) {\r\n                        // do children first; order shouldn't matter\r\n                        for (i = scope.children.length; --i >= 0;)\r\n                                fixrefs(scope.children[i]);\r\n                        for (i in scope.refs) if (HOP(scope.refs, i)) {\r\n                                // find origin scope and propagate the reference to origin\r\n                                for (var origin = scope.has(i), s = scope; s; s = s.parent) {\r\n                                        s.refs[i] = origin;\r\n                                        if (s === origin) break;\r\n                                }\r\n                        }\r\n                };\r\n                fixrefs(current_scope);\r\n\r\n                return ret;\r\n        });\r\n\r\n};\r\n\r\n/* -----[ mangle names ]----- */\r\n\r\nfunction ast_mangle(ast, options) {\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n        options = options || {};\r\n\r\n        function get_mangled(name, newMangle) {\r\n                if (!options.toplevel && !scope.parent) return name; // don't mangle toplevel\r\n                if (options.except && member(name, options.except))\r\n                        return name;\r\n                return scope.get_mangled(name, newMangle);\r\n        };\r\n\r\n        function get_define(name) {\r\n                if (options.defines) {\r\n                        // we always lookup a defined symbol for the current scope FIRST, so declared\r\n                        // vars trump a DEFINE symbol, but if no such var is found, then match a DEFINE value\r\n                        if (!scope.has(name)) {\r\n                                if (HOP(options.defines, name)) {\r\n                                        return options.defines[name];\r\n                                }\r\n                        }\r\n                        return null;\r\n                }\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\", extra;\r\n                if (name) {\r\n                        if (is_defun) name = get_mangled(name);\r\n                        else {\r\n                                extra = {};\r\n                                if (!(scope.uses_eval || scope.uses_with))\r\n                                        name = extra[name] = scope.next_mangled();\r\n                                else\r\n                                        extra[name] = name;\r\n                        }\r\n                }\r\n                body = with_scope(body.scope, function(){\r\n                        args = MAP(args, function(name){ return get_mangled(name) });\r\n                        return MAP(body, walk);\r\n                }, extra);\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        function with_scope(s, cont, extra) {\r\n                var _scope = scope;\r\n                scope = s;\r\n                if (extra) for (var i in extra) if (HOP(extra, i)) {\r\n                        s.set_mangle(i, extra[i]);\r\n                }\r\n                for (var i in s.names) if (HOP(s.names, i)) {\r\n                        get_mangled(i, true);\r\n                }\r\n                var ret = cont();\r\n                ret.scope = s;\r\n                scope = _scope;\r\n                return ret;\r\n        };\r\n\r\n        function _vardefs(defs) {\r\n                return [ this[0], MAP(defs, function(d){\r\n                        return [ get_mangled(d[0]), walk(d[1]) ];\r\n                }) ];\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"function\": _lambda,\r\n                \"defun\": function() {\r\n                        // move function declarations to the top when\r\n                        // they are not in some block.\r\n                        var ast = _lambda.apply(this, arguments);\r\n                        switch (w.parent()[0]) {\r\n                            case \"toplevel\":\r\n                            case \"function\":\r\n                            case \"defun\":\r\n                                return MAP.at_top(ast);\r\n                        }\r\n                        return ast;\r\n                },\r\n                \"label\": function(label, stat) { return [ this[0], get_mangled(label), walk(stat) ] },\r\n                \"break\": function(label) { if (label) return [ this[0], get_mangled(label) ] },\r\n                \"continue\": function(label) { if (label) return [ this[0], get_mangled(label) ] },\r\n                \"var\": _vardefs,\r\n                \"const\": _vardefs,\r\n                \"name\": function(name) {\r\n                        return get_define(name) || [ this[0], get_mangled(name) ];\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [ this[0],\r\n                                 MAP(t, walk),\r\n                                 c != null ? [ get_mangled(c[0]), MAP(c[1], walk) ] : null,\r\n                                 f != null ? MAP(f, walk) : null ];\r\n                },\r\n                \"toplevel\": function(body) {\r\n                        var self = this;\r\n                        return with_scope(self.scope, function(){\r\n                                return [ self[0], MAP(body, walk) ];\r\n                        });\r\n                }\r\n        }, function() {\r\n                return walk(ast_add_scope(ast));\r\n        });\r\n};\r\n\r\n/* -----[\r\n   - compress foo[\"bar\"] into foo.bar,\r\n   - remove block brackets {} where possible\r\n   - join consecutive var declarations\r\n   - various optimizations for IFs:\r\n     - if (cond) foo(); else bar();  ==>  cond?foo():bar();\r\n     - if (cond) foo();  ==>  cond&&foo();\r\n     - if (foo) return bar(); else return baz();  ==> return foo?bar():baz(); // also for throw\r\n     - if (foo) return bar(); else something();  ==> {if(foo)return bar();something()}\r\n   ]----- */\r\n\r\nvar warn = function(){};\r\n\r\nfunction best_of(ast1, ast2) {\r\n        return gen_code(ast1).length > gen_code(ast2[0] == \"stat\" ? ast2[1] : ast2).length ? ast2 : ast1;\r\n};\r\n\r\nfunction last_stat(b) {\r\n        if (b[0] == \"block\" && b[1] && b[1].length > 0)\r\n                return b[1][b[1].length - 1];\r\n        return b;\r\n}\r\n\r\nfunction aborts(t) {\r\n        if (t) switch (last_stat(t)[0]) {\r\n            case \"return\":\r\n            case \"break\":\r\n            case \"continue\":\r\n            case \"throw\":\r\n                return true;\r\n        }\r\n};\r\n\r\nfunction boolean_expr(expr) {\r\n        return ( (expr[0] == \"unary-prefix\"\r\n                  && member(expr[1], [ \"!\", \"delete\" ])) ||\r\n\r\n                 (expr[0] == \"binary\"\r\n                  && member(expr[1], [ \"in\", \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">=\", \">\" ])) ||\r\n\r\n                 (expr[0] == \"binary\"\r\n                  && member(expr[1], [ \"&&\", \"||\" ])\r\n                  && boolean_expr(expr[2])\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"conditional\"\r\n                  && boolean_expr(expr[2])\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"assign\"\r\n                  && expr[1] === true\r\n                  && boolean_expr(expr[3])) ||\r\n\r\n                 (expr[0] == \"seq\"\r\n                  && boolean_expr(expr[expr.length - 1]))\r\n               );\r\n};\r\n\r\nfunction make_conditional(c, t, e) {\r\n    var make_real_conditional = function() {\r\n        if (c[0] == \"unary-prefix\" && c[1] == \"!\") {\r\n            return e ? [ \"conditional\", c[2], e, t ] : [ \"binary\", \"||\", c[2], t ];\r\n        } else {\r\n            return e ? [ \"conditional\", c, t, e ] : [ \"binary\", \"&&\", c, t ];\r\n        }\r\n    };\r\n    // shortcut the conditional if the expression has a constant value\r\n    return when_constant(c, function(ast, val){\r\n        warn_unreachable(val ? e : t);\r\n        return          (val ? t : e);\r\n    }, make_real_conditional);\r\n};\r\n\r\nfunction empty(b) {\r\n        return !b || (b[0] == \"block\" && (!b[1] || b[1].length == 0));\r\n};\r\n\r\nfunction is_string(node) {\r\n        return (node[0] == \"string\" ||\r\n                node[0] == \"unary-prefix\" && node[1] == \"typeof\" ||\r\n                node[0] == \"binary\" && node[1] == \"+\" &&\r\n                (is_string(node[2]) || is_string(node[3])));\r\n};\r\n\r\nvar when_constant = (function(){\r\n\r\n        var $NOT_CONSTANT = {};\r\n\r\n        // this can only evaluate constant expressions.  If it finds anything\r\n        // not constant, it throws $NOT_CONSTANT.\r\n        function evaluate(expr) {\r\n                switch (expr[0]) {\r\n                    case \"string\":\r\n                    case \"num\":\r\n                        return expr[1];\r\n                    case \"name\":\r\n                    case \"atom\":\r\n                        switch (expr[1]) {\r\n                            case \"true\": return true;\r\n                            case \"false\": return false;\r\n                        }\r\n                        break;\r\n                    case \"unary-prefix\":\r\n                        switch (expr[1]) {\r\n                            case \"!\": return !evaluate(expr[2]);\r\n                            case \"typeof\": return typeof evaluate(expr[2]);\r\n                            case \"~\": return ~evaluate(expr[2]);\r\n                            case \"-\": return -evaluate(expr[2]);\r\n                            case \"+\": return +evaluate(expr[2]);\r\n                        }\r\n                        break;\r\n                    case \"binary\":\r\n                        var left = expr[2], right = expr[3];\r\n                        switch (expr[1]) {\r\n                            case \"&&\"         : return evaluate(left) &&         evaluate(right);\r\n                            case \"||\"         : return evaluate(left) ||         evaluate(right);\r\n                            case \"|\"          : return evaluate(left) |          evaluate(right);\r\n                            case \"&\"          : return evaluate(left) &          evaluate(right);\r\n                            case \"^\"          : return evaluate(left) ^          evaluate(right);\r\n                            case \"+\"          : return evaluate(left) +          evaluate(right);\r\n                            case \"*\"          : return evaluate(left) *          evaluate(right);\r\n                            case \"/\"          : return evaluate(left) /          evaluate(right);\r\n                            case \"-\"          : return evaluate(left) -          evaluate(right);\r\n                            case \"<<\"         : return evaluate(left) <<         evaluate(right);\r\n                            case \">>\"         : return evaluate(left) >>         evaluate(right);\r\n                            case \">>>\"        : return evaluate(left) >>>        evaluate(right);\r\n                            case \"==\"         : return evaluate(left) ==         evaluate(right);\r\n                            case \"===\"        : return evaluate(left) ===        evaluate(right);\r\n                            case \"!=\"         : return evaluate(left) !=         evaluate(right);\r\n                            case \"!==\"        : return evaluate(left) !==        evaluate(right);\r\n                            case \"<\"          : return evaluate(left) <          evaluate(right);\r\n                            case \"<=\"         : return evaluate(left) <=         evaluate(right);\r\n                            case \">\"          : return evaluate(left) >          evaluate(right);\r\n                            case \">=\"         : return evaluate(left) >=         evaluate(right);\r\n                            case \"in\"         : return evaluate(left) in         evaluate(right);\r\n                            case \"instanceof\" : return evaluate(left) instanceof evaluate(right);\r\n                        }\r\n                }\r\n                throw $NOT_CONSTANT;\r\n        };\r\n\r\n        return function(expr, yes, no) {\r\n                try {\r\n                        var val = evaluate(expr), ast;\r\n                        switch (typeof val) {\r\n                            case \"string\": ast =  [ \"string\", val ]; break;\r\n                            case \"number\": ast =  [ \"num\", val ]; break;\r\n                            case \"boolean\": ast =  [ \"name\", String(val) ]; break;\r\n                            default: throw new Error(\"Can't handle constant of type: \" + (typeof val));\r\n                        }\r\n                        return yes.call(expr, ast, val);\r\n                } catch(ex) {\r\n                        if (ex === $NOT_CONSTANT) {\r\n                                if (expr[0] == \"binary\"\r\n                                    && (expr[1] == \"===\" || expr[1] == \"!==\")\r\n                                    && ((is_string(expr[2]) && is_string(expr[3]))\r\n                                        || (boolean_expr(expr[2]) && boolean_expr(expr[3])))) {\r\n                                        expr[1] = expr[1].substr(0, 2);\r\n                                }\r\n                                else if (no && expr[0] == \"binary\"\r\n                                         && (expr[1] == \"||\" || expr[1] == \"&&\")) {\r\n                                    // the whole expression is not constant but the lval may be...\r\n                                    try {\r\n                                        var lval = evaluate(expr[2]);\r\n                                        expr = ((expr[1] == \"&&\" && (lval ? expr[3] : lval))    ||\r\n                                                (expr[1] == \"||\" && (lval ? lval    : expr[3])) ||\r\n                                                expr);\r\n                                    } catch(ex2) {\r\n                                        // IGNORE... lval is not constant\r\n                                    }\r\n                                }\r\n                                return no ? no.call(expr, expr) : null;\r\n                        }\r\n                        else throw ex;\r\n                }\r\n        };\r\n\r\n})();\r\n\r\nfunction warn_unreachable(ast) {\r\n        if (!empty(ast))\r\n                warn(\"Dropping unreachable code: \" + gen_code(ast, true));\r\n};\r\n\r\nfunction prepare_ifs(ast) {\r\n        var w = ast_walker(), walk = w.walk;\r\n        // In this first pass, we rewrite ifs which abort with no else with an\r\n        // if-else.  For example:\r\n        //\r\n        // if (x) {\r\n        //     blah();\r\n        //     return y;\r\n        // }\r\n        // foobar();\r\n        //\r\n        // is rewritten into:\r\n        //\r\n        // if (x) {\r\n        //     blah();\r\n        //     return y;\r\n        // } else {\r\n        //     foobar();\r\n        // }\r\n        function redo_if(statements) {\r\n                statements = MAP(statements, walk);\r\n\r\n                for (var i = 0; i < statements.length; ++i) {\r\n                        var fi = statements[i];\r\n                        if (fi[0] != \"if\") continue;\r\n\r\n                        if (fi[3] && walk(fi[3])) continue;\r\n\r\n                        var t = walk(fi[2]);\r\n                        if (!aborts(t)) continue;\r\n\r\n                        var conditional = walk(fi[1]);\r\n\r\n                        var e_body = statements.slice(i + 1);\r\n                        var e = e_body.length == 1 ? e_body[0] : [ \"block\", e_body ];\r\n\r\n                        var ret = statements.slice(0, i).concat([ [\r\n                                fi[0],          // \"if\"\r\n                                conditional,    // conditional\r\n                                t,              // then\r\n                                e               // else\r\n                        ] ]);\r\n\r\n                        return redo_if(ret);\r\n                }\r\n\r\n                return statements;\r\n        };\r\n\r\n        function redo_if_lambda(name, args, body) {\r\n                body = redo_if(body);\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        function redo_if_block(statements) {\r\n                return [ this[0], statements != null ? redo_if(statements) : null ];\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"defun\": redo_if_lambda,\r\n                \"function\": redo_if_lambda,\r\n                \"block\": redo_if_block,\r\n                \"splice\": redo_if_block,\r\n                \"toplevel\": function(statements) {\r\n                        return [ this[0], redo_if(statements) ];\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                this[0],\r\n                                redo_if(t),\r\n                                c != null ? [ c[0], redo_if(c[1]) ] : null,\r\n                                f != null ? redo_if(f) : null\r\n                        ];\r\n                }\r\n        }, function() {\r\n                return walk(ast);\r\n        });\r\n};\r\n\r\nfunction for_side_effects(ast, handler) {\r\n        var w = ast_walker(), walk = w.walk;\r\n        var $stop = {}, $restart = {};\r\n        function stop() { throw $stop };\r\n        function restart() { throw $restart };\r\n        function found(){ return handler.call(this, this, w, stop, restart) };\r\n        function unary(op) {\r\n                if (op == \"++\" || op == \"--\")\r\n                        return found.apply(this, arguments);\r\n        };\r\n        return w.with_walkers({\r\n                \"try\": found,\r\n                \"throw\": found,\r\n                \"return\": found,\r\n                \"new\": found,\r\n                \"switch\": found,\r\n                \"break\": found,\r\n                \"continue\": found,\r\n                \"assign\": found,\r\n                \"call\": found,\r\n                \"if\": found,\r\n                \"for\": found,\r\n                \"for-in\": found,\r\n                \"while\": found,\r\n                \"do\": found,\r\n                \"return\": found,\r\n                \"unary-prefix\": unary,\r\n                \"unary-postfix\": unary,\r\n                \"defun\": found\r\n        }, function(){\r\n                while (true) try {\r\n                        walk(ast);\r\n                        break;\r\n                } catch(ex) {\r\n                        if (ex === $stop) break;\r\n                        if (ex === $restart) continue;\r\n                        throw ex;\r\n                }\r\n        });\r\n};\r\n\r\nfunction ast_lift_variables(ast) {\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n        function do_body(body, env) {\r\n                var _scope = scope;\r\n                scope = env;\r\n                body = MAP(body, walk);\r\n                var hash = {}, names = MAP(env.names, function(type, name){\r\n                        if (type != \"var\") return MAP.skip;\r\n                        if (!env.references(name)) return MAP.skip;\r\n                        hash[name] = true;\r\n                        return [ name ];\r\n                });\r\n                if (names.length > 0) {\r\n                        // looking for assignments to any of these variables.\r\n                        // we can save considerable space by moving the definitions\r\n                        // in the var declaration.\r\n                        for_side_effects([ \"block\", body ], function(ast, walker, stop, restart) {\r\n                                if (ast[0] == \"assign\"\r\n                                    && ast[1] === true\r\n                                    && ast[2][0] == \"name\"\r\n                                    && HOP(hash, ast[2][1])) {\r\n                                        // insert the definition into the var declaration\r\n                                        for (var i = names.length; --i >= 0;) {\r\n                                                if (names[i][0] == ast[2][1]) {\r\n                                                        if (names[i][1]) // this name already defined, we must stop\r\n                                                                stop();\r\n                                                        names[i][1] = ast[3]; // definition\r\n                                                        names.push(names.splice(i, 1)[0]);\r\n                                                        break;\r\n                                                }\r\n                                        }\r\n                                        // remove this assignment from the AST.\r\n                                        var p = walker.parent();\r\n                                        if (p[0] == \"seq\") {\r\n                                                var a = p[2];\r\n                                                a.unshift(0, p.length);\r\n                                                p.splice.apply(p, a);\r\n                                        }\r\n                                        else if (p[0] == \"stat\") {\r\n                                                p.splice(0, p.length, \"block\"); // empty statement\r\n                                        }\r\n                                        else {\r\n                                                stop();\r\n                                        }\r\n                                        restart();\r\n                                }\r\n                                stop();\r\n                        });\r\n                        body.unshift([ \"var\", names ]);\r\n                }\r\n                scope = _scope;\r\n                return body;\r\n        };\r\n        function _vardefs(defs) {\r\n                var ret = null;\r\n                for (var i = defs.length; --i >= 0;) {\r\n                        var d = defs[i];\r\n                        if (!d[1]) continue;\r\n                        d = [ \"assign\", true, [ \"name\", d[0] ], d[1] ];\r\n                        if (ret == null) ret = d;\r\n                        else ret = [ \"seq\", d, ret ];\r\n                }\r\n                if (ret == null) {\r\n                        if (w.parent()[0] == \"for-in\")\r\n                                return [ \"name\", defs[0][0] ];\r\n                        return MAP.skip;\r\n                }\r\n                return [ \"stat\", ret ];\r\n        };\r\n        function _toplevel(body) {\r\n                return [ this[0], do_body(body, this.scope) ];\r\n        };\r\n        return w.with_walkers({\r\n                \"function\": function(name, args, body){\r\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\r\n                                args.pop();\r\n                        if (!body.scope.references(name)) name = null;\r\n                        return [ this[0], name, args, do_body(body, body.scope) ];\r\n                },\r\n                \"defun\": function(name, args, body){\r\n                        if (!scope.references(name)) return MAP.skip;\r\n                        for (var i = args.length; --i >= 0 && !body.scope.references(args[i]);)\r\n                                args.pop();\r\n                        return [ this[0], name, args, do_body(body, body.scope) ];\r\n                },\r\n                \"var\": _vardefs,\r\n                \"toplevel\": _toplevel\r\n        }, function(){\r\n                return walk(ast_add_scope(ast));\r\n        });\r\n};\r\n\r\nfunction ast_squeeze(ast, options) {\r\n        options = defaults(options, {\r\n                make_seqs   : true,\r\n                dead_code   : true,\r\n                keep_comps  : true,\r\n                no_warnings : false\r\n        });\r\n\r\n        var w = ast_walker(), walk = w.walk, scope;\r\n\r\n        function negate(c) {\r\n                var not_c = [ \"unary-prefix\", \"!\", c ];\r\n                switch (c[0]) {\r\n                    case \"unary-prefix\":\r\n                        return c[1] == \"!\" && boolean_expr(c[2]) ? c[2] : not_c;\r\n                    case \"seq\":\r\n                        c = slice(c);\r\n                        c[c.length - 1] = negate(c[c.length - 1]);\r\n                        return c;\r\n                    case \"conditional\":\r\n                        return best_of(not_c, [ \"conditional\", c[1], negate(c[2]), negate(c[3]) ]);\r\n                    case \"binary\":\r\n                        var op = c[1], left = c[2], right = c[3];\r\n                        if (!options.keep_comps) switch (op) {\r\n                            case \"<=\"  : return [ \"binary\", \">\", left, right ];\r\n                            case \"<\"   : return [ \"binary\", \">=\", left, right ];\r\n                            case \">=\"  : return [ \"binary\", \"<\", left, right ];\r\n                            case \">\"   : return [ \"binary\", \"<=\", left, right ];\r\n                        }\r\n                        switch (op) {\r\n                            case \"==\"  : return [ \"binary\", \"!=\", left, right ];\r\n                            case \"!=\"  : return [ \"binary\", \"==\", left, right ];\r\n                            case \"===\" : return [ \"binary\", \"!==\", left, right ];\r\n                            case \"!==\" : return [ \"binary\", \"===\", left, right ];\r\n                            case \"&&\"  : return best_of(not_c, [ \"binary\", \"||\", negate(left), negate(right) ]);\r\n                            case \"||\"  : return best_of(not_c, [ \"binary\", \"&&\", negate(left), negate(right) ]);\r\n                        }\r\n                        break;\r\n                }\r\n                return not_c;\r\n        };\r\n\r\n        function with_scope(s, cont) {\r\n                var _scope = scope;\r\n                scope = s;\r\n                var ret = cont();\r\n                ret.scope = s;\r\n                scope = _scope;\r\n                return ret;\r\n        };\r\n\r\n        function rmblock(block) {\r\n                if (block != null && block[0] == \"block\" && block[1]) {\r\n                        if (block[1].length == 1)\r\n                                block = block[1][0];\r\n                        else if (block[1].length == 0)\r\n                                block = [ \"block\" ];\r\n                }\r\n                return block;\r\n        };\r\n\r\n        function _lambda(name, args, body) {\r\n                var is_defun = this[0] == \"defun\";\r\n                body = with_scope(body.scope, function(){\r\n                        var ret = tighten(body, \"lambda\");\r\n                        if (!is_defun && name && !scope.references(name))\r\n                                name = null;\r\n                        return ret;\r\n                });\r\n                return [ this[0], name, args, body ];\r\n        };\r\n\r\n        // this function does a few things:\r\n        // 1. discard useless blocks\r\n        // 2. join consecutive var declarations\r\n        // 3. remove obviously dead code\r\n        // 4. transform consecutive statements using the comma operator\r\n        // 5. if block_type == \"lambda\" and it detects constructs like if(foo) return ... - rewrite like if (!foo) { ... }\r\n        function tighten(statements, block_type) {\r\n                statements = MAP(statements, walk);\r\n\r\n                statements = statements.reduce(function(a, stat){\r\n                        if (stat[0] == \"block\") {\r\n                                if (stat[1]) {\r\n                                        a.push.apply(a, stat[1]);\r\n                                }\r\n                        } else {\r\n                                a.push(stat);\r\n                        }\r\n                        return a;\r\n                }, []);\r\n\r\n                statements = (function(a, prev){\r\n                        statements.forEach(function(cur){\r\n                                if (prev && ((cur[0] == \"var\" && prev[0] == \"var\") ||\r\n                                             (cur[0] == \"const\" && prev[0] == \"const\"))) {\r\n                                        prev[1] = prev[1].concat(cur[1]);\r\n                                } else {\r\n                                        a.push(cur);\r\n                                        prev = cur;\r\n                                }\r\n                        });\r\n                        return a;\r\n                })([]);\r\n\r\n                if (options.dead_code) statements = (function(a, has_quit){\r\n                        statements.forEach(function(st){\r\n                                if (has_quit) {\r\n                                        if (st[0] == \"function\" || st[0] == \"defun\") {\r\n                                                a.push(st);\r\n                                        }\r\n                                        else if (st[0] == \"var\" || st[0] == \"const\") {\r\n                                                if (!options.no_warnings)\r\n                                                        warn(\"Variables declared in unreachable code\");\r\n                                                st[1] = MAP(st[1], function(def){\r\n                                                        if (def[1] && !options.no_warnings)\r\n                                                                warn_unreachable([ \"assign\", true, [ \"name\", def[0] ], def[1] ]);\r\n                                                        return [ def[0] ];\r\n                                                });\r\n                                                a.push(st);\r\n                                        }\r\n                                        else if (!options.no_warnings)\r\n                                                warn_unreachable(st);\r\n                                }\r\n                                else {\r\n                                        a.push(st);\r\n                                        if (member(st[0], [ \"return\", \"throw\", \"break\", \"continue\" ]))\r\n                                                has_quit = true;\r\n                                }\r\n                        });\r\n                        return a;\r\n                })([]);\r\n\r\n                if (options.make_seqs) statements = (function(a, prev) {\r\n                        statements.forEach(function(cur){\r\n                                if (prev && prev[0] == \"stat\" && cur[0] == \"stat\") {\r\n                                        prev[1] = [ \"seq\", prev[1], cur[1] ];\r\n                                } else {\r\n                                        a.push(cur);\r\n                                        prev = cur;\r\n                                }\r\n                        });\r\n                        if (a.length >= 2\r\n                            && a[a.length-2][0] == \"stat\"\r\n                            && (a[a.length-1][0] == \"return\" || a[a.length-1][0] == \"throw\")\r\n                            && a[a.length-1][1])\r\n                        {\r\n                                a.splice(a.length - 2, 2,\r\n                                         [ a[a.length-1][0],\r\n                                           [ \"seq\", a[a.length-2][1], a[a.length-1][1] ]]);\r\n                        }\r\n                        return a;\r\n                })([]);\r\n\r\n                // this increases jQuery by 1K.  Probably not such a good idea after all..\r\n                // part of this is done in prepare_ifs anyway.\r\n                // if (block_type == \"lambda\") statements = (function(i, a, stat){\r\n                //         while (i < statements.length) {\r\n                //                 stat = statements[i++];\r\n                //                 if (stat[0] == \"if\" && !stat[3]) {\r\n                //                         if (stat[2][0] == \"return\" && stat[2][1] == null) {\r\n                //                                 a.push(make_if(negate(stat[1]), [ \"block\", statements.slice(i) ]));\r\n                //                                 break;\r\n                //                         }\r\n                //                         var last = last_stat(stat[2]);\r\n                //                         if (last[0] == \"return\" && last[1] == null) {\r\n                //                                 a.push(make_if(stat[1], [ \"block\", stat[2][1].slice(0, -1) ], [ \"block\", statements.slice(i) ]));\r\n                //                                 break;\r\n                //                         }\r\n                //                 }\r\n                //                 a.push(stat);\r\n                //         }\r\n                //         return a;\r\n                // })(0, []);\r\n\r\n                return statements;\r\n        };\r\n\r\n        function make_if(c, t, e) {\r\n                return when_constant(c, function(ast, val){\r\n                        if (val) {\r\n                                warn_unreachable(e);\r\n                                return t;\r\n                        } else {\r\n                                warn_unreachable(t);\r\n                                return e;\r\n                        }\r\n                }, function() {\r\n                        return make_real_if(c, t, e);\r\n                });\r\n        };\r\n\r\n        function make_real_if(c, t, e) {\r\n                c = walk(c);\r\n                t = walk(t);\r\n                e = walk(e);\r\n\r\n                if (empty(t)) {\r\n                        c = negate(c);\r\n                        t = e;\r\n                        e = null;\r\n                } else if (empty(e)) {\r\n                        e = null;\r\n                } else {\r\n                        // if we have both else and then, maybe it makes sense to switch them?\r\n                        (function(){\r\n                                var a = gen_code(c);\r\n                                var n = negate(c);\r\n                                var b = gen_code(n);\r\n                                if (b.length < a.length) {\r\n                                        var tmp = t;\r\n                                        t = e;\r\n                                        e = tmp;\r\n                                        c = n;\r\n                                }\r\n                        })();\r\n                }\r\n                if (empty(e) && empty(t))\r\n                        return [ \"stat\", c ];\r\n                var ret = [ \"if\", c, t, e ];\r\n                if (t[0] == \"if\" && empty(t[3]) && empty(e)) {\r\n                        ret = best_of(ret, walk([ \"if\", [ \"binary\", \"&&\", c, t[1] ], t[2] ]));\r\n                }\r\n                else if (t[0] == \"stat\") {\r\n                        if (e) {\r\n                                if (e[0] == \"stat\") {\r\n                                        ret = best_of(ret, [ \"stat\", make_conditional(c, t[1], e[1]) ]);\r\n                                }\r\n                        }\r\n                        else {\r\n                                ret = best_of(ret, [ \"stat\", make_conditional(c, t[1]) ]);\r\n                        }\r\n                }\r\n                else if (e && t[0] == e[0] && (t[0] == \"return\" || t[0] == \"throw\") && t[1] && e[1]) {\r\n                        ret = best_of(ret, [ t[0], make_conditional(c, t[1], e[1] ) ]);\r\n                }\r\n                else if (e && aborts(t)) {\r\n                        ret = [ [ \"if\", c, t ] ];\r\n                        if (e[0] == \"block\") {\r\n                                if (e[1]) ret = ret.concat(e[1]);\r\n                        }\r\n                        else {\r\n                                ret.push(e);\r\n                        }\r\n                        ret = walk([ \"block\", ret ]);\r\n                }\r\n                else if (t && aborts(e)) {\r\n                        ret = [ [ \"if\", negate(c), e ] ];\r\n                        if (t[0] == \"block\") {\r\n                                if (t[1]) ret = ret.concat(t[1]);\r\n                        } else {\r\n                                ret.push(t);\r\n                        }\r\n                        ret = walk([ \"block\", ret ]);\r\n                }\r\n                return ret;\r\n        };\r\n\r\n        function _do_while(cond, body) {\r\n                return when_constant(cond, function(cond, val){\r\n                        if (!val) {\r\n                                warn_unreachable(body);\r\n                                return [ \"block\" ];\r\n                        } else {\r\n                                return [ \"for\", null, null, null, walk(body) ];\r\n                        }\r\n                });\r\n        };\r\n\r\n        return w.with_walkers({\r\n                \"sub\": function(expr, subscript) {\r\n                        if (subscript[0] == \"string\") {\r\n                                var name = subscript[1];\r\n                                if (is_identifier(name))\r\n                                        return [ \"dot\", walk(expr), name ];\r\n                                else if (/^[1-9][0-9]*$/.test(name) || name === \"0\")\r\n                                        return [ \"sub\", walk(expr), [ \"num\", parseInt(name, 10) ] ];\r\n                        }\r\n                },\r\n                \"if\": make_if,\r\n                \"toplevel\": function(body) {\r\n                        return [ \"toplevel\", with_scope(this.scope, function(){\r\n                                return tighten(body);\r\n                        }) ];\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        var last = body.length - 1;\r\n                        return [ \"switch\", walk(expr), MAP(body, function(branch, i){\r\n                                var block = tighten(branch[1]);\r\n                                if (i == last && block.length > 0) {\r\n                                        var node = block[block.length - 1];\r\n                                        if (node[0] == \"break\" && !node[1])\r\n                                                block.pop();\r\n                                }\r\n                                return [ branch[0] ? walk(branch[0]) : null, block ];\r\n                        }) ];\r\n                },\r\n                \"function\": _lambda,\r\n                \"defun\": _lambda,\r\n                \"block\": function(body) {\r\n                        if (body) return rmblock([ \"block\", tighten(body) ]);\r\n                },\r\n                \"binary\": function(op, left, right) {\r\n                        return when_constant([ \"binary\", op, walk(left), walk(right) ], function yes(c){\r\n                                return best_of(walk(c), this);\r\n                        }, function no() {\r\n                                return this;\r\n                        });\r\n                },\r\n                \"conditional\": function(c, t, e) {\r\n                        return make_conditional(walk(c), walk(t), walk(e));\r\n                },\r\n                \"try\": function(t, c, f) {\r\n                        return [\r\n                                \"try\",\r\n                                tighten(t),\r\n                                c != null ? [ c[0], tighten(c[1]) ] : null,\r\n                                f != null ? tighten(f) : null\r\n                        ];\r\n                },\r\n                \"unary-prefix\": function(op, expr) {\r\n                        expr = walk(expr);\r\n                        var ret = [ \"unary-prefix\", op, expr ];\r\n                        if (op == \"!\")\r\n                                ret = best_of(ret, negate(expr));\r\n                        return when_constant(ret, function(ast, val){\r\n                                return walk(ast); // it's either true or false, so minifies to !0 or !1\r\n                        }, function() { return ret });\r\n                },\r\n                \"name\": function(name) {\r\n                        switch (name) {\r\n                            case \"true\": return [ \"unary-prefix\", \"!\", [ \"num\", 0 ]];\r\n                            case \"false\": return [ \"unary-prefix\", \"!\", [ \"num\", 1 ]];\r\n                        }\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        if (ctor[0] == \"name\" && ctor[1] == \"Array\" && !scope.has(\"Array\")) {\r\n                                if (args.length != 1) {\r\n                                        return [ \"array\", args ];\r\n                                } else {\r\n                                        return [ \"call\", [ \"name\", \"Array\" ], args ];\r\n                                }\r\n                        }\r\n                },\r\n                \"call\": function(expr, args) {\r\n                        if (expr[0] == \"name\" && expr[1] == \"Array\" && args.length != 1 && !scope.has(\"Array\")) {\r\n                                return [ \"array\", args ];\r\n                        }\r\n                },\r\n                \"while\": _do_while\r\n        }, function() {\r\n                for (var i = 0; i < 2; ++i) {\r\n                        ast = prepare_ifs(ast);\r\n                        ast = ast_add_scope(ast);\r\n                        ast = walk(ast);\r\n                }\r\n                return ast;\r\n        });\r\n};\r\n\r\n/* -----[ re-generate code from the AST ]----- */\r\n\r\nvar DOT_CALL_NO_PARENS = /*jsp.*/array_to_hash([\r\n        \"name\",\r\n        \"array\",\r\n        \"object\",\r\n        \"string\",\r\n        \"dot\",\r\n        \"sub\",\r\n        \"call\",\r\n        \"regexp\"\r\n]);\r\n\r\nfunction make_string(str, ascii_only) {\r\n        var dq = 0, sq = 0;\r\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27\\u2028\\u2029]/g, function(s){\r\n                switch (s) {\r\n                    case \"\\\\\": return \"\\\\\\\\\";\r\n                    case \"\\b\": return \"\\\\b\";\r\n                    case \"\\f\": return \"\\\\f\";\r\n                    case \"\\n\": return \"\\\\n\";\r\n                    case \"\\r\": return \"\\\\r\";\r\n                    case \"\\t\": return \"\\\\t\";\r\n                    case \"\\u2028\": return \"\\\\u2028\";\r\n                    case \"\\u2029\": return \"\\\\u2029\";\r\n                    case '\"': ++dq; return '\"';\r\n                    case \"'\": ++sq; return \"'\";\r\n                }\r\n                return s;\r\n        });\r\n        if (ascii_only) str = to_ascii(str);\r\n        if (dq > sq) return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\r\n        else return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\r\n};\r\n\r\nfunction to_ascii(str) {\r\n        return str.replace(/[\\u0080-\\uffff]/g, function(ch) {\r\n                var code = ch.charCodeAt(0).toString(16);\r\n                while (code.length < 4) code = \"0\" + code;\r\n                return \"\\\\u\" + code;\r\n        });\r\n};\r\n\r\nvar SPLICE_NEEDS_BRACKETS = /*jsp.*/array_to_hash([ \"if\", \"while\", \"do\", \"for\", \"for-in\", \"with\" ]);\r\n\r\nfunction gen_code(ast, options) {\r\n        options = defaults(options, {\r\n                indent_start : 0,\r\n                indent_level : 4,\r\n                quote_keys   : false,\r\n                space_colon  : false,\r\n                beautify     : false,\r\n                ascii_only   : false,\r\n                inline_script: false\r\n        });\r\n        var beautify = !!options.beautify;\r\n        var indentation = 0,\r\n            newline = beautify ? \"\\n\" : \"\",\r\n            space = beautify ? \" \" : \"\";\r\n\r\n        function encode_string(str) {\r\n                var ret = make_string(str, options.ascii_only);\r\n                if (options.inline_script)\r\n                        ret = ret.replace(/<\\x2fscript([>/\\t\\n\\f\\r ])/gi, \"<\\\\/script$1\");\r\n                return ret;\r\n        };\r\n\r\n        function make_name(name) {\r\n                name = name.toString();\r\n                if (options.ascii_only)\r\n                        name = to_ascii(name);\r\n                return name;\r\n        };\r\n\r\n        function indent(line) {\r\n                if (line == null)\r\n                        line = \"\";\r\n                if (beautify)\r\n                        line = repeat_string(\" \", options.indent_start + indentation * options.indent_level) + line;\r\n                return line;\r\n        };\r\n\r\n        function with_indent(cont, incr) {\r\n                if (incr == null) incr = 1;\r\n                indentation += incr;\r\n                try { return cont.apply(null, slice(arguments, 1)); }\r\n                finally { indentation -= incr; }\r\n        };\r\n\r\n        function add_spaces(a) {\r\n                if (beautify)\r\n                        return a.join(\" \");\r\n                var b = [];\r\n                for (var i = 0; i < a.length; ++i) {\r\n                        var next = a[i + 1];\r\n                        b.push(a[i]);\r\n                        if (next &&\r\n                            ((/[a-z0-9_\\x24]$/i.test(a[i].toString()) && /^[a-z0-9_\\x24]/i.test(next.toString())) ||\r\n                             (/[\\+\\-]$/.test(a[i].toString()) && /^[\\+\\-]/.test(next.toString())))) {\r\n                                b.push(\" \");\r\n                        }\r\n                }\r\n                return b.join(\"\");\r\n        };\r\n\r\n        function add_commas(a) {\r\n                return a.join(\",\" + space);\r\n        };\r\n\r\n        function parenthesize(expr) {\r\n                var gen = make(expr);\r\n                for (var i = 1; i < arguments.length; ++i) {\r\n                        var el = arguments[i];\r\n                        if ((el instanceof Function && el(expr)) || expr[0] == el)\r\n                                return \"(\" + gen + \")\";\r\n                }\r\n                return gen;\r\n        };\r\n\r\n        function best_of(a) {\r\n                if (a.length == 1) {\r\n                        return a[0];\r\n                }\r\n                if (a.length == 2) {\r\n                        var b = a[1];\r\n                        a = a[0];\r\n                        return a.length <= b.length ? a : b;\r\n                }\r\n                return best_of([ a[0], best_of(a.slice(1)) ]);\r\n        };\r\n\r\n        function needs_parens(expr) {\r\n                if (expr[0] == \"function\" || expr[0] == \"object\") {\r\n                        // dot/call on a literal function requires the\r\n                        // function literal itself to be parenthesized\r\n                        // only if it's the first \"thing\" in a\r\n                        // statement.  This means that the parent is\r\n                        // \"stat\", but it could also be a \"seq\" and\r\n                        // we're the first in this \"seq\" and the\r\n                        // parent is \"stat\", and so on.  Messy stuff,\r\n                        // but it worths the trouble.\r\n                        var a = slice(w.stack()), self = a.pop(), p = a.pop();\r\n                        while (p) {\r\n                                if (p[0] == \"stat\") return true;\r\n                                if (((p[0] == \"seq\" || p[0] == \"call\" || p[0] == \"dot\" || p[0] == \"sub\" || p[0] == \"conditional\") && p[1] === self) ||\r\n                                    ((p[0] == \"binary\" || p[0] == \"assign\" || p[0] == \"unary-postfix\") && p[2] === self)) {\r\n                                        self = p;\r\n                                        p = a.pop();\r\n                                } else {\r\n                                        return false;\r\n                                }\r\n                        }\r\n                }\r\n                return !HOP(DOT_CALL_NO_PARENS, expr[0]);\r\n        };\r\n\r\n        function make_num(num) {\r\n                var str = num.toString(10), a = [ str.replace(/^0\\./, \".\") ], m;\r\n                if (Math.floor(num) === num) {\r\n                        a.push(\"0x\" + num.toString(16).toLowerCase(), // probably pointless\r\n                               \"0\" + num.toString(8)); // same.\r\n                        if ((m = /^(.*?)(0+)$/.exec(num))) {\r\n                                a.push(m[1] + \"e\" + m[2].length);\r\n                        }\r\n                } else if ((m = /^0?\\.(0+)(.*)$/.exec(num))) {\r\n                        a.push(m[2] + \"e-\" + (m[1].length + m[2].length),\r\n                               str.substr(str.indexOf(\".\")));\r\n                }\r\n                return best_of(a);\r\n        };\r\n\r\n        var w = ast_walker();\r\n        var make = w.walk;\r\n        return w.with_walkers({\r\n                \"string\": encode_string,\r\n                \"num\": make_num,\r\n                \"name\": make_name,\r\n                \"toplevel\": function(statements) {\r\n                        return make_block_statements(statements)\r\n                                .join(newline + newline);\r\n                },\r\n                \"splice\": function(statements) {\r\n                        var parent = w.parent();\r\n                        if (HOP(SPLICE_NEEDS_BRACKETS, parent)) {\r\n                                // we need block brackets in this case\r\n                                return make_block.apply(this, arguments);\r\n                        } else {\r\n                                return MAP(make_block_statements(statements, true),\r\n                                           function(line, i) {\r\n                                                   // the first line is already indented\r\n                                                   return i > 0 ? indent(line) : line;\r\n                                           }).join(newline);\r\n                        }\r\n                },\r\n                \"block\": make_block,\r\n                \"var\": function(defs) {\r\n                        return \"var \" + add_commas(MAP(defs, make_1vardef)) + \";\";\r\n                },\r\n                \"const\": function(defs) {\r\n                        return \"const \" + add_commas(MAP(defs, make_1vardef)) + \";\";\r\n                },\r\n                \"try\": function(tr, ca, fi) {\r\n                        var out = [ \"try\", make_block(tr) ];\r\n                        if (ca) out.push(\"catch\", \"(\" + ca[0] + \")\", make_block(ca[1]));\r\n                        if (fi) out.push(\"finally\", make_block(fi));\r\n                        return add_spaces(out);\r\n                },\r\n                \"throw\": function(expr) {\r\n                        return add_spaces([ \"throw\", make(expr) ]) + \";\";\r\n                },\r\n                \"new\": function(ctor, args) {\r\n                        args = args.length > 0 ? \"(\" + add_commas(MAP(args, make)) + \")\" : \"\";\r\n                        return add_spaces([ \"new\", parenthesize(ctor, \"seq\", \"binary\", \"conditional\", \"assign\", function(expr){\r\n                                var w = ast_walker(), has_call = {};\r\n                                try {\r\n                                        w.with_walkers({\r\n                                                \"call\": function() { throw has_call },\r\n                                                \"function\": function() { return this }\r\n                                        }, function(){\r\n                                                w.walk(expr);\r\n                                        });\r\n                                } catch(ex) {\r\n                                        if (ex === has_call)\r\n                                                return true;\r\n                                        throw ex;\r\n                                }\r\n                        }) + args ]);\r\n                },\r\n                \"switch\": function(expr, body) {\r\n                        return add_spaces([ \"switch\", \"(\" + make(expr) + \")\", make_switch_block(body) ]);\r\n                },\r\n                \"break\": function(label) {\r\n                        var out = \"break\";\r\n                        if (label != null)\r\n                                out += \" \" + make_name(label);\r\n                        return out + \";\";\r\n                },\r\n                \"continue\": function(label) {\r\n                        var out = \"continue\";\r\n                        if (label != null)\r\n                                out += \" \" + make_name(label);\r\n                        return out + \";\";\r\n                },\r\n                \"conditional\": function(co, th, el) {\r\n                        return add_spaces([ parenthesize(co, \"assign\", \"seq\", \"conditional\"), \"?\",\r\n                                            parenthesize(th, \"seq\"), \":\",\r\n                                            parenthesize(el, \"seq\") ]);\r\n                },\r\n                \"assign\": function(op, lvalue, rvalue) {\r\n                        if (op && op !== true) op += \"=\";\r\n                        else op = \"=\";\r\n                        return add_spaces([ make(lvalue), op, parenthesize(rvalue, \"seq\") ]);\r\n                },\r\n                \"dot\": function(expr) {\r\n                        var out = make(expr), i = 1;\r\n                        if (expr[0] == \"num\") {\r\n                                if (!/\\./.test(expr[1]))\r\n                                        out += \".\";\r\n                        } else if (needs_parens(expr))\r\n                                out = \"(\" + out + \")\";\r\n                        while (i < arguments.length)\r\n                                out += \".\" + make_name(arguments[i++]);\r\n                        return out;\r\n                },\r\n                \"call\": function(func, args) {\r\n                        var f = make(func);\r\n                        if (needs_parens(func))\r\n                                f = \"(\" + f + \")\";\r\n                        return f + \"(\" + add_commas(MAP(args, function(expr){\r\n                                return parenthesize(expr, \"seq\");\r\n                        })) + \")\";\r\n                },\r\n                \"function\": make_function,\r\n                \"defun\": make_function,\r\n                \"if\": function(co, th, el) {\r\n                        var out = [ \"if\", \"(\" + make(co) + \")\", el ? make_then(th) : make(th) ];\r\n                        if (el) {\r\n                                out.push(\"else\", make(el));\r\n                        }\r\n                        return add_spaces(out);\r\n                },\r\n                \"for\": function(init, cond, step, block) {\r\n                        var out = [ \"for\" ];\r\n                        init = (init != null ? make(init) : \"\").replace(/;*\\s*$/, \";\" + space);\r\n                        cond = (cond != null ? make(cond) : \"\").replace(/;*\\s*$/, \";\" + space);\r\n                        step = (step != null ? make(step) : \"\").replace(/;*\\s*$/, \"\");\r\n                        var args = init + cond + step;\r\n                        if (args == \"; ; \") args = \";;\";\r\n                        out.push(\"(\" + args + \")\", make(block));\r\n                        return add_spaces(out);\r\n                },\r\n                \"for-in\": function(vvar, key, hash, block) {\r\n                        return add_spaces([ \"for\", \"(\" +\r\n                                            (vvar ? make(vvar).replace(/;+$/, \"\") : make(key)),\r\n                                            \"in\",\r\n                                            make(hash) + \")\", make(block) ]);\r\n                },\r\n                \"while\": function(condition, block) {\r\n                        return add_spaces([ \"while\", \"(\" + make(condition) + \")\", make(block) ]);\r\n                },\r\n                \"do\": function(condition, block) {\r\n                        return add_spaces([ \"do\", make(block), \"while\", \"(\" + make(condition) + \")\" ]) + \";\";\r\n                },\r\n                \"return\": function(expr) {\r\n                        var out = [ \"return\" ];\r\n                        if (expr != null) out.push(make(expr));\r\n                        return add_spaces(out) + \";\";\r\n                },\r\n                \"binary\": function(operator, lvalue, rvalue) {\r\n                        var left = make(lvalue), right = make(rvalue);\r\n                        // XXX: I'm pretty sure other cases will bite here.\r\n                        //      we need to be smarter.\r\n                        //      adding parens all the time is the safest bet.\r\n                        if (member(lvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\r\n                            lvalue[0] == \"binary\" && PRECEDENCE[operator] > PRECEDENCE[lvalue[1]]) {\r\n                                left = \"(\" + left + \")\";\r\n                        }\r\n                        if (member(rvalue[0], [ \"assign\", \"conditional\", \"seq\" ]) ||\r\n                            rvalue[0] == \"binary\" && PRECEDENCE[operator] >= PRECEDENCE[rvalue[1]] &&\r\n                            !(rvalue[1] == operator && member(operator, [ \"&&\", \"||\", \"*\" ]))) {\r\n                                right = \"(\" + right + \")\";\r\n                        }\r\n                        else if (!beautify && options.inline_script && (operator == \"<\" || operator == \"<<\")\r\n                                 && rvalue[0] == \"regexp\" && /^script/i.test(rvalue[1])) {\r\n                                right = \" \" + right;\r\n                        }\r\n                        return add_spaces([ left, operator, right ]);\r\n                },\r\n                \"unary-prefix\": function(operator, expr) {\r\n                        var val = make(expr);\r\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-prefix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\r\n                                val = \"(\" + val + \")\";\r\n                        return operator + (jsp.is_alphanumeric_char(operator.charAt(0)) ? \" \" : \"\") + val;\r\n                },\r\n                \"unary-postfix\": function(operator, expr) {\r\n                        var val = make(expr);\r\n                        if (!(expr[0] == \"num\" || (expr[0] == \"unary-postfix\" && !HOP(OPERATORS, operator + expr[1])) || !needs_parens(expr)))\r\n                                val = \"(\" + val + \")\";\r\n                        return val + operator;\r\n                },\r\n                \"sub\": function(expr, subscript) {\r\n                        var hash = make(expr);\r\n                        if (needs_parens(expr))\r\n                                hash = \"(\" + hash + \")\";\r\n                        return hash + \"[\" + make(subscript) + \"]\";\r\n                },\r\n                \"object\": function(props) {\r\n                        if (props.length == 0)\r\n                                return \"{}\";\r\n                        return \"{\" + newline + with_indent(function(){\r\n                                return MAP(props, function(p){\r\n                                        if (p.length == 3) {\r\n                                                // getter/setter.  The name is in p[0], the arg.list in p[1][2], the\r\n                                                // body in p[1][3] and type (\"get\" / \"set\") in p[2].\r\n                                                return indent(make_function(p[0], p[1][2], p[1][3], p[2]));\r\n                                        }\r\n                                        var key = p[0], val = parenthesize(p[1], \"seq\");\r\n                                        if (options.quote_keys) {\r\n                                                key = encode_string(key);\r\n                                        } else if ((typeof key == \"number\" || !beautify && +key + \"\" == key)\r\n                                                   && parseFloat(key) >= 0) {\r\n                                                key = make_num(+key);\r\n                                        } else if (!is_identifier(key)) {\r\n                                                key = encode_string(key);\r\n                                        }\r\n                                        return indent(add_spaces(beautify && options.space_colon\r\n                                                                 ? [ key, \":\", val ]\r\n                                                                 : [ key + \":\", val ]));\r\n                                }).join(\",\" + newline);\r\n                        }) + newline + indent(\"}\");\r\n                },\r\n                \"regexp\": function(rx, mods) {\r\n                        return \"/\" + rx + \"/\" + mods;\r\n                },\r\n                \"array\": function(elements) {\r\n                        if (elements.length == 0) return \"[]\";\r\n                        return add_spaces([ \"[\", add_commas(MAP(elements, function(el){\r\n                                if (!beautify && el[0] == \"atom\" && el[1] == \"undefined\") return \"\";\r\n                                return parenthesize(el, \"seq\");\r\n                        })), \"]\" ]);\r\n                },\r\n                \"stat\": function(stmt) {\r\n                        return make(stmt).replace(/;*\\s*$/, \";\");\r\n                },\r\n                \"seq\": function() {\r\n                        return add_commas(MAP(slice(arguments), make));\r\n                },\r\n                \"label\": function(name, block) {\r\n                        return add_spaces([ make_name(name), \":\", make(block) ]);\r\n                },\r\n                \"with\": function(expr, block) {\r\n                        return add_spaces([ \"with\", \"(\" + make(expr) + \")\", make(block) ]);\r\n                },\r\n                \"atom\": function(name) {\r\n                        return make_name(name);\r\n                }\r\n        }, function(){ return make(ast) });\r\n\r\n        // The squeezer replaces \"block\"-s that contain only a single\r\n        // statement with the statement itself; technically, the AST\r\n        // is correct, but this can create problems when we output an\r\n        // IF having an ELSE clause where the THEN clause ends in an\r\n        // IF *without* an ELSE block (then the outer ELSE would refer\r\n        // to the inner IF).  This function checks for this case and\r\n        // adds the block brackets if needed.\r\n        function make_then(th) {\r\n                if (th[0] == \"do\") {\r\n                        // https://github.com/mishoo/UglifyJS/issues/#issue/57\r\n                        // IE croaks with \"syntax error\" on code like this:\r\n                        //     if (foo) do ... while(cond); else ...\r\n                        // we need block brackets around do/while\r\n                        return make_block([ th ]);\r\n                }\r\n                var b = th;\r\n                while (true) {\r\n                        var type = b[0];\r\n                        if (type == \"if\") {\r\n                                if (!b[3])\r\n                                        // no else, we must add the block\r\n                                        return make([ \"block\", [ th ]]);\r\n                                b = b[3];\r\n                        }\r\n                        else if (type == \"while\" || type == \"do\") b = b[2];\r\n                        else if (type == \"for\" || type == \"for-in\") b = b[4];\r\n                        else break;\r\n                }\r\n                return make(th);\r\n        };\r\n\r\n        function make_function(name, args, body, keyword) {\r\n                var out = keyword || \"function\";\r\n                if (name) {\r\n                        out += \" \" + make_name(name);\r\n                }\r\n                out += \"(\" + add_commas(MAP(args, make_name)) + \")\";\r\n                return add_spaces([ out, make_block(body) ]);\r\n        };\r\n\r\n        function must_has_semicolon(node) {\r\n                switch (node[0]) {\r\n                    case \"with\":\r\n                    case \"while\":\r\n                        return empty(node[2]); // `with' or `while' with empty body?\r\n                    case \"for\":\r\n                    case \"for-in\":\r\n                        return empty(node[4]); // `for' with empty body?\r\n                    case \"if\":\r\n                        if (empty(node[2]) && !node[3]) return true; // `if' with empty `then' and no `else'\r\n                        if (node[3]) {\r\n                                if (empty(node[3])) return true; // `else' present but empty\r\n                                return must_has_semicolon(node[3]); // dive into the `else' branch\r\n                        }\r\n                        return must_has_semicolon(node[2]); // dive into the `then' branch\r\n                }\r\n        };\r\n\r\n        function make_block_statements(statements, noindent) {\r\n                for (var a = [], last = statements.length - 1, i = 0; i <= last; ++i) {\r\n                        var stat = statements[i];\r\n                        var code = make(stat);\r\n                        if (code != \";\") {\r\n                                if (!beautify && i == last && !must_has_semicolon(stat)) {\r\n                                        code = code.replace(/;+\\s*$/, \"\");\r\n                                }\r\n                                a.push(code);\r\n                        }\r\n                }\r\n                return noindent ? a : MAP(a, indent);\r\n        };\r\n\r\n        function make_switch_block(body) {\r\n                var n = body.length;\r\n                if (n == 0) return \"{}\";\r\n                return \"{\" + newline + MAP(body, function(branch, i){\r\n                        var has_body = branch[1].length > 0, code = with_indent(function(){\r\n                                return indent(branch[0]\r\n                                              ? add_spaces([ \"case\", make(branch[0]) + \":\" ])\r\n                                              : \"default:\");\r\n                        }, 0.5) + (has_body ? newline + with_indent(function(){\r\n                                return make_block_statements(branch[1]).join(newline);\r\n                        }) : \"\");\r\n                        if (!beautify && has_body && i < n - 1)\r\n                                code += \";\";\r\n                        return code;\r\n                }).join(newline) + newline + indent(\"}\");\r\n        };\r\n\r\n        function make_block(statements) {\r\n                if (!statements) return \";\";\r\n                if (statements.length == 0) return \"{}\";\r\n                return \"{\" + newline + with_indent(function(){\r\n                        return make_block_statements(statements).join(newline);\r\n                }) + newline + indent(\"}\");\r\n        };\r\n\r\n        function make_1vardef(def) {\r\n                var name = def[0], val = def[1];\r\n                if (val != null)\r\n                        name = add_spaces([ make_name(name), \"=\", parenthesize(val, \"seq\") ]);\r\n                return name;\r\n        };\r\n\r\n};\r\n\r\nfunction split_lines(code, max_line_length) {\r\n        var splits = [ 0 ];\r\n        jsp.parse(function(){\r\n                var next_token = jsp.tokenizer(code);\r\n                var last_split = 0;\r\n                var prev_token;\r\n                function current_length(tok) {\r\n                        return tok.pos - last_split;\r\n                };\r\n                function split_here(tok) {\r\n                        last_split = tok.pos;\r\n                        splits.push(last_split);\r\n                };\r\n                function custom(){\r\n                        var tok = next_token.apply(this, arguments);\r\n                        out: {\r\n                                if (prev_token) {\r\n                                        if (prev_token.type == \"keyword\") break out;\r\n                                }\r\n                                if (current_length(tok) > max_line_length) {\r\n                                        switch (tok.type) {\r\n                                            case \"keyword\":\r\n                                            case \"atom\":\r\n                                            case \"name\":\r\n                                            case \"punc\":\r\n                                                split_here(tok);\r\n                                                break out;\r\n                                        }\r\n                                }\r\n                        }\r\n                        prev_token = tok;\r\n                        return tok;\r\n                };\r\n                custom.context = function() {\r\n                        return next_token.context.apply(this, arguments);\r\n                };\r\n                return custom;\r\n        }());\r\n        return splits.map(function(pos, i){\r\n                return code.substring(pos, splits[i + 1] || code.length);\r\n        }).join(\"\\n\");\r\n};\r\n\r\n/* -----[ Utilities ]----- */\r\n\r\nfunction repeat_string(str, i) {\r\n        if (i <= 0) return \"\";\r\n        if (i == 1) return str;\r\n        var d = repeat_string(str, i >> 1);\r\n        d += d;\r\n        if (i & 1) d += str;\r\n        return d;\r\n};\r\n\r\nfunction defaults(args, defs) {\r\n        var ret = {};\r\n        if (args === true)\r\n                args = {};\r\n        for (var i in defs) if (HOP(defs, i)) {\r\n                ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\r\n        }\r\n        return ret;\r\n};\r\n\r\nfunction is_identifier(name) {\r\n        return /^[a-z_$][a-z0-9_$]*$/i.test(name)\r\n                && name != \"this\"\r\n                && !HOP(jsp.KEYWORDS_ATOM, name)\r\n                && !HOP(jsp.RESERVED_WORDS, name)\r\n                && !HOP(jsp.KEYWORDS, name);\r\n};\r\n\r\nfunction HOP(obj, prop) {\r\n        return Object.prototype.hasOwnProperty.call(obj, prop);\r\n};\r\n\r\n// some utilities\r\n\r\nvar MAP;\r\n\r\n(function(){\r\n        MAP = function(a, f, o) {\r\n                var ret = [], top = [], i;\r\n                function doit() {\r\n                        var val = f.call(o, a[i], i);\r\n                        if (val instanceof AtTop) {\r\n                                val = val.v;\r\n                                if (val instanceof Splice) {\r\n                                        top.push.apply(top, val.v);\r\n                                } else {\r\n                                        top.push(val);\r\n                                }\r\n                        }\r\n                        else if (val != skip) {\r\n                                if (val instanceof Splice) {\r\n                                        ret.push.apply(ret, val.v);\r\n                                } else {\r\n                                        ret.push(val);\r\n                                }\r\n                        }\r\n                };\r\n                if (a instanceof Array) for (i = 0; i < a.length; ++i) doit();\r\n                else for (i in a) if (HOP(a, i)) doit();\r\n                return top.concat(ret);\r\n        };\r\n        MAP.at_top = function(val) { return new AtTop(val) };\r\n        MAP.splice = function(val) { return new Splice(val) };\r\n        var skip = MAP.skip = {};\r\n        function AtTop(val) { this.v = val };\r\n        function Splice(val) { this.v = val };\r\n})();\r\n\r\n/* -----[ Exports ]----- */\r\n/*\r\nexports.ast_walker = ast_walker;\r\nexports.ast_mangle = ast_mangle;\r\nexports.ast_squeeze = ast_squeeze;\r\nexports.ast_lift_variables = ast_lift_variables;\r\nexports.gen_code = gen_code;\r\nexports.ast_add_scope = ast_add_scope;\r\nexports.set_logger = function(logger) { warn = logger };\r\nexports.make_string = make_string;\r\nexports.split_lines = split_lines;\r\nexports.MAP = MAP;\r\n\r\n// keep this last!\r\nexports.ast_squeeze_more = require(\"./squeeze-more\").ast_squeeze_more;\r\n*/\r\n\n/* @license\r\n\r\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\n  Copyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial\r\n                     and working import implementation.\r\n\r\n  Redistribution and use in source and binary forms, with or without\r\n  modification, are permitted provided that the following conditions\r\n  are met:\r\n\r\n      * Redistributions of source code must retain the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer.\r\n\r\n      * Redistributions in binary form must reproduce the above\r\n        copyright notice, this list of conditions and the following\r\n        disclaimer in the documentation and/or other materials\r\n        provided with the distribution.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\r\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\r\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\r\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\r\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\r\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\r\n  SUCH DAMAGE.\r\n*/\r\n\r\n\r\n/*\r\n * Misc classes for importing files.\r\n *\r\n * Currently the file contains a lot of unused code for future\r\n * purposes. Most of it can be rewritten as there is now Javascript parser\r\n * available.\r\n *\r\n * Exports:\r\n *\r\n * - getUrlContents(url) -- get URL contents. Returns contents or false in\r\n *   error.\r\n *\r\n * - Some other stuff not currently used/needed.\r\n *\r\n *\r\n */\r\n(function() {\r\n\r\nfunction parseQML(file) {\r\n    var contents = getUrlContents(file + \".js\");\r\n    if (contents) {\r\n        console.log(\"Using pre-processed content for \" + file);\r\n        return new Function(\"return \" + contents)();\r\n    } else {\r\n        contents = getUrlContents(file);\r\n        if (contents) {\r\n            // todo: use parser/compiler here\r\n            console.log(\"todo: add parser to import.js \" + file);\r\n        } else {\r\n            console.log(\"warn: Fetch failed for \" + file);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Get URL contents. EXPORTED.\r\n * @param url {String} Url to fetch.\r\n * @param skipExceptions {bool} when turned on, ignore exeptions and return false. This feature is used by readQmlDir.\r\n * @private\r\n * @return {mixed} String of contents or false in errors.\r\n *\r\n * Q1: can someone provide use-case when we need caching here?\r\n * A1:\r\n * Q2: should errors be cached? (now they aren't)\r\n * A2:\r\n \r\n * Q3: split getUrlContents into: getUrlContents, getUrlContentsWithCaching, getUrlContentsWithoutErrors..\r\n */\r\ngetUrlContents = function (url, skipExceptions) {\r\n    if (typeof urlContentCache[url] == 'undefined') {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", url, false);\r\n\r\n      if (skipExceptions)\r\n        { try { xhr.send(null); } catch (e) { return false; } } /* it is OK to not have logging here, because DeveloperTools already will have red log record */\r\n      else\r\n        xhr.send(null);\r\n\r\n      if (xhr.status != 200 && xhr.status != 0) { // 0 if accessing with file://\r\n          console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\r\n          return false;\r\n      }\r\n      urlContentCache[url] = xhr.responseText;\r\n    }\r\n    return urlContentCache[url];\r\n}\r\nif (typeof global.urlContentCache == 'undefined')\r\n  global.urlContentCache = {};\r\n\r\n/**\r\n * Read qmldir spec file at directory. EXPORTED.\r\n * @param url Url of the directory\r\n * @return {Object} Object, where .internals lists qmldir internal references\r\n *                          and .externals lists qmldir external references.\r\n */\r\n\r\n/*  Note on how importing works.\r\n\r\n   * parseQML gives us `tree.$imports` variable, which contains information from `import` statements.\r\n\r\n   * After each call to parseQML, we call engine.loadImports(tree.$imports).\r\n     It in turn invokes readQmlDir() calls for each import, with respect to current component base path and engine.importPathList().\r\n\r\n   * We keep all component names from all qmldir files in global variable `engine.qmldir`.\r\n   \r\n   * In construct() function, we use `engine.qmldir` for component url lookup.\r\n\r\n   Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html \r\n   Also please look at notes and TODO's in qtcore.js::loadImports() and qtcore.js::construct() methods.\r\n*/\r\n \r\nreadQmlDir = function (url) {\r\n    // in case 'url' is empty, do not attach \"/\"\r\n    // Q1: when this happen?\r\n    var qmldirFileUrl = url.length > 0 ? (url + \"/qmldir\") : \"qmldir\";\r\n\r\n    var qmldir = getUrlContents( qmldirFileUrl, true), // loading url contents with skipping errors\r\n        lines,\r\n        line,\r\n        internals = {},\r\n        externals = {},\r\n        match,\r\n        i;\r\n\r\n    if (qmldir === false) {\r\n        return false;\r\n    }\r\n\r\n    // we have to check for \"://\" \r\n    // In that case, item path is meant to be absolute, and we have no need to prefix it with base url\r\n    function makeurl( path ) {\r\n       if (path.indexOf(\"://\") > 0) return path;\r\n       return url + \"/\" + path;\r\n    }\r\n\r\n    lines = qmldir.split(/\\r?\\n/);\r\n    for (i = 0; i < lines.length; i++) {\r\n        // trim\r\n        line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\r\n        if (!line.length || line[0] == \"#\") {\r\n            // Empty line or comment\r\n            continue;\r\n        }\r\n        match = line.split(/\\s+/);\r\n        if (match.length == 2 || match.length == 3) {\r\n            if (match[0] == \"plugin\") {\r\n                console.log(url + \": qmldir plugins are not supported!\");\r\n            } else if (match[0] == \"internal\") {\r\n                internals[match[1]] = { url: makeurl( match[2] ) };\r\n            } else {\r\n                if (match.length == 2) {\r\n                    externals[match[0]] = { url: makeurl( match[1] ) };\r\n                } else {\r\n                    externals[match[0]] = { url: makeurl( match[2] ), version: match[1] };\r\n                }\r\n            }\r\n        } else {\r\n            console.log(url + \": unmatched: \" + line);\r\n        }\r\n    }\r\n    return {internals: internals, externals: externals};\r\n}\r\n\r\n\r\n/**\r\n * Import and parse javascript file. EXPORTED.\r\n * @return {object} Object which has \"var\"s and functions from file as keys, or\r\n *         undefined if operation fails\r\n */\r\nimportJs = function (filename) {\r\n\r\n    // todo: .pragma support\r\n\r\n    // Exports as follow:\r\n    // function a() { function b() {} } exports only a.\r\n    // var a = function b(){} exports a and b. Not sure if b should be exported.\r\n    //                        rare case, however.\r\n    // var a = function(){} exports only a.\r\n\r\n    var i,\r\n        src = getUrlContents(filename),\r\n        exports = [];\r\n\r\n    if (src === false) {\r\n        return;\r\n    }\r\n\r\n    // Analyse source\r\n    exports = readExports(src);\r\n    console.log(filename + \" exports:\", exports);\r\n\r\n    // Wrap source to function to retain private scope of the variables.\r\n    // Make that function return an object.\r\n    // That object contains getters and setters for exported stuff.\r\n    // Add () to execute the function.\r\n    src += \";return {\";\r\n    for (i = 0; i < exports.length; i++) {\r\n        // create getters and setters for properties\r\n        // keeps variables synced better\r\n        src += \"get \" + exports[i] + \"(){return \" + exports[i] + \"},\";\r\n        src += \"set \" + exports[i] + \"(){\" + exports[i] + \" = arguments[0]},\";\r\n        // without getters and setters:\r\n        // src += exports[i] + \":\" + exports[i] + \",\";\r\n    }\r\n    src += \"}\";\r\n\r\n    // evaluate source to get the object.\r\n    return new Function(src)();\r\n}\r\n\r\n/**\r\n * Read code for variables and functions which are exported to qml\r\n * @private\r\n * @param src source code\r\n * @return Array Array of local variable names to export\r\n */\r\nfunction readExports(src) {\r\n\r\n    // Eat src until str is found. Recurse if recursive set.\r\n    function eatUntil(src, str, recursive) {\r\n        var i;\r\n        if (!recursive) {\r\n            i = src.indexOf(str);\r\n            if (i == -1) {\r\n                console.log(\"eof encountered, \" + str + \" expected.\");\r\n                return \"\";\r\n            }\r\n        } else {\r\n            i = 0;\r\n            while (i < src.length) {\r\n                if (src.substr(i, str.length) == str) {\r\n                    break;\r\n                }\r\n                switch(src[i]) {\r\n                 case \"{\": // inner block\r\n                    src = eatUntil(src.substr(i + 1), \"}\", true );\r\n                    i = 0;\r\n                    break;\r\n                 case \"(\": // Parentheses\r\n                    src = eatUntil(src.substr(i + 1), \")\", true );\r\n                    i = 0;\r\n                    break;\r\n                 case \"/\": // Possible beginning of comment\r\n                    if (src[i + 1] == \"/\") {\r\n                        src = eatUntil(src.substr(i + 1), \"\\n\");\r\n                        i = 0;\r\n                    } else if (src[i + 1] == \"*\") {\r\n                        src = eatUntil(src.substr(i + 1), \"*/\");\r\n                        i = 0;\r\n                    } else {\r\n                        i++;\r\n                    }\r\n                    break;\r\n                 default:\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return src.substr(i + str.length);\r\n    }\r\n\r\n    // Strip comments and code blocks from the input source\r\n    // This is quite similar with eatCodeBlock but still a bit different.\r\n    // If either section has bugs, check the other section, too!\r\n    var i = 0,\r\n        // Code without blocks and comments\r\n        semi = \"\",\r\n        // todo: these doesn't match with exports containing \"$\"\r\n        matcher = /var\\s+\\w+|function\\s+\\w+/g,\r\n        matches,\r\n        tmp,\r\n        exports = [];\r\n\r\n    while (i < src.length) {\r\n        switch (src[i]) {\r\n         case \"{\": // code block\r\n            src = eatUntil(src.substr(i + 1), \"}\", true);\r\n            i = 0;\r\n            break;\r\n         case \"(\": // parentheses\r\n            src = eatUntil(src.substr(i + 1), \")\", true);\r\n            i = 0;\r\n            break;\r\n         case \"/\": // comment\r\n            if (src[i + 1] == \"/\") {\r\n                src = eatUntil(src.substr(i + 1), \"\\n\");\r\n                i = 0;\r\n            } else if (src[i + 1] == \"*\") {\r\n                src = eatUntil(src.substr(i + 1), \"*/\");\r\n                i = 0;\r\n            } else {\r\n                semi += src[i];\r\n                i++;\r\n            }\r\n            break;\r\n        default:\r\n            semi += src[i];\r\n            i++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Search exports from semi\r\n    matches = semi.match(matcher);\r\n\r\n    // matches now contain strings defined in matcher. Re-match these to get\r\n    // exports. Matching can be done in one step, but I couldn't get it working\r\n    // so bear this extra step.\r\n    for (i = 0; i < matches.length; i++) {\r\n        tmp = /\\w+\\s+(\\w+)/.exec(matches[i]);\r\n        if (tmp) {\r\n            exports.push(tmp[1]);\r\n        }\r\n    }\r\n    return exports;\r\n}\r\n\r\n})();\r\n\nglobal.qrc = {\r\n  includesFile: function(path) {\r\n    return typeof qrc[path] != 'undefined';\r\n  }\r\n};\r\n\nglobal.Qt = {\r\n  rgba: function(r,g,b,a) {\r\n    return \"rgba(\"\r\n      + Math.round(r * 255) + \",\"\r\n      + Math.round(g * 255) + \",\"\r\n      + Math.round(b * 255) + \",\"\r\n      + a + \")\";\r\n  },\r\n  openUrlExternally: function(url) {\r\n    page = window.open(url, '_blank');\r\n    page.focus();\r\n  },\r\n  // Load file, parse and construct as Component (.qml)\r\n  //FIXME: remove the parameter executionContext and get it autonomously.\r\n  createComponent: function(name, executionContext) {\r\n    if (name in engine.components)\r\n        return engine.components[name];\r\n\r\n    var nameIsUrl = name.indexOf(\"//\") >= 0 || name.indexOf(\":/\") >= 0; // e.g. // in protocol, or :/ in disk urls (D:/)\r\n\r\n    // Do not perform path lookups if name starts with @ sign.\r\n    // This is used when we load components from qmldir files\r\n    // because in that case we do not need any lookups.\r\n    if (name.length > 0 && name[0] == \"@\") {\r\n      nameIsUrl = true;\r\n      name = name.substr( 1,name.length-1 );\r\n    }\r\n\r\n    var file = nameIsUrl ? name : engine.$basePath + name;\r\n\r\n    var src = getUrlContents(file, true);\r\n    // if failed to load, and provided name is not direct url, try to load from dirs in importPathList()\r\n    if (src==false && !nameIsUrl) {\r\n      var moredirs = engine.importPathList();\r\n\r\n      for (var i=0; i<moredirs.length; i++) {\r\n        file = moredirs[i] + name;\r\n        src = getUrlContents(file, true);\r\n        if (src !== false) break;\r\n      }\r\n    }\r\n\r\n    // When createComponent failed to load content from all probable sources, it should return undefined.\r\n    if (src === false)\r\n      return undefined;\r\n\r\n    var tree = parseQML(src);\r\n\r\n    if (tree.$children.length !== 1)\r\n        console.error(\"A QML component must only contain one root element!\");\r\n\r\n    var component = new QMLComponent({ object: tree, context: executionContext });\r\n    component.$basePath = engine.extractBasePath( file );\r\n    component.$imports = tree.$imports;\r\n    component.$file = file; // just for debugging\r\n\r\n    engine.loadImports( tree.$imports,component.$basePath );\r\n\r\n    engine.components[name] = component;\r\n    return component;\r\n  },\r\n\r\n    // Returns url resolved relative to the URL of the caller.\r\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\r\n  resolvedUrl: function(url)\r\n  {\r\n    if (!url || !url.substr) // url is not a string object\r\n      return url;\r\n\r\n    // Must check for cases: D:/, file://, http://, or slash at the beginning. \r\n    // This means the url is absolute => we have to skip processing (except removing dot segments).\r\n    if (url == \"\" || url.indexOf(\":/\") != -1 || url.indexOf(\"/\") == 0)\r\n      return engine.removeDotSegments( url );\r\n\r\n    // we have $basePath variable placed in context of \"current\" document\r\n    // this is done in construct() function\r\n\r\n    // let's go to the callers and inspect their arguments\r\n    // The 2-nd argument of the callers we hope is context object\r\n    // e.g. see calling signature of bindings and signals\r\n\r\n    // Actually Qt cpp code is doing the same; the difference is that they know calling context\r\n    // https://qt.gitorious.org/qt/qtdeclarative/source/eeaba26596d447c531dfac9d6e6bf5cfe4537813:src/qml/qml/v8/qqmlbuiltinfunctions.cpp#L833\r\n\r\n    var detectedBasePath = \"\";\r\n    var currentCaller = Qt.resolvedUrl.caller;\r\n    var maxcount = 10;\r\n    while (maxcount-- > 0 && currentCaller) {\r\n      if (currentCaller.arguments[1] && currentCaller.arguments[1][\"$basePath\"])\r\n      {\r\n        detectedBasePath = currentCaller.arguments[1][\"$basePath\"];\r\n        break;\r\n      }\r\n      currentCaller = currentCaller.caller;\r\n    }\r\n\r\n    return engine.removeDotSegments( detectedBasePath + url )\r\n  },\r\n\r\n  // Buttons masks\r\n  LeftButton: 1,\r\n  RightButton: 2,\r\n  MiddleButton: 4,\r\n  // Modifiers masks\r\n  NoModifier: 0,\r\n  ShiftModifier: 1,\r\n  ControlModifier: 2,\r\n  AltModifier: 4,\r\n  MetaModifier: 8,\r\n  KeypadModifier: 16, // Note: Not available in web\r\n  // Layout directions\r\n  LeftToRight: 0,\r\n  RightToLeft: 1,\r\n  // Orientations\r\n  Vertical: 0,\r\n  Horizontal: 1,\r\n  // Keys\r\n  Key_Escape: 27,\r\n  Key_Tab: 9,\r\n  Key_Backtab: 245,\r\n  Key_Backspace: 8,\r\n  Key_Return: 13,\r\n  Key_Enter: 13,\r\n  Key_Insert: 45,\r\n  Key_Delete: 46,\r\n  Key_Pause: 19,\r\n  Key_Print: 42,\r\n  Key_SysReq: 0,\r\n  Key_Clear: 12,\r\n  Key_Home: 36,\r\n  Key_End: 35,\r\n  Key_Left: 37,\r\n  Key_Up: 38,\r\n  Key_Right: 39,\r\n  Key_Down: 40,\r\n  Key_PageUp: 33,\r\n  Key_PageDown: 34,\r\n  Key_Shift: 16,\r\n  Key_Control: 17,\r\n  Key_Meta: 91,\r\n  Key_Alt: 18,\r\n  Key_AltGr: 0,\r\n  Key_CapsLock: 20,\r\n  Key_NumLock: 144,\r\n  Key_ScrollLock: 145,\r\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117, Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122, Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127, Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132, Key_F22: 133, Key_F23: 134, Key_F24: 135, Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0, Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\r\n  Key_Super_L: 0,\r\n  Key_Super_R: 0,\r\n  Key_Menu: 0,\r\n  Key_Hyper_L: 0,\r\n  Key_Hyper_R: 0,\r\n  Key_Help: 6,\r\n  Key_Direction_L: 0,\r\n  Key_Direction_R: 0,\r\n  Key_Space: 32,\r\n  Key_Any:   32,\r\n  Key_Exclam: 161,\r\n  Key_QuoteDbl: 162,\r\n  Key_NumberSign: 163,\r\n  Key_Dollar: 164,\r\n  Key_Percent: 165,\r\n  Key_Ampersant: 166,\r\n  Key_Apostrophe: 222,\r\n  Key_ParenLeft: 168,\r\n  Key_ParenRight: 169,\r\n  Key_Asterisk: 170,\r\n  Key_Plus: 171,\r\n  Key_Comma: 188,\r\n  Key_Minus: 173,\r\n  Key_Period: 190,\r\n  Key_Slash: 191,\r\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52, Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\r\n  Key_Colon: 58,\r\n  Key_Semicolon: 59,\r\n  Key_Less: 60,\r\n  Key_Equal: 61,\r\n  Key_Greater: 62,\r\n  Key_Question: 63,\r\n  Key_At: 64,\r\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71, Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78, Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85, Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\r\n  Key_BracketLeft: 219,\r\n  Key_Backslash: 220,\r\n  Key_BracketRight: 221,\r\n  Key_AsciiCircum: 160,\r\n  Key_Underscore: 167,\r\n  Key_QuoteLeft: 0,\r\n  Key_BraceLeft: 174,\r\n  Key_Bar: 172,\r\n  Key_BraceRight: 175,\r\n  Key_AsciiTilde: 176,\r\n  Key_Back: 0,\r\n  Key_Forward: 0,\r\n  Key_Stop: 0,\r\n  Key_VolumeDown: 182,\r\n  Key_VolumeUp: 183,\r\n  Key_VolumeMute: 181,\r\n  Key_Yes: 0,\r\n  Key_multiply: 106,\r\n  Key_add: 107,\r\n  Key_substract: 109,\r\n  Key_divide: 111,\r\n  Key_News: 0,\r\n  Key_OfficeHome: 0,\r\n  Key_Option: 0,\r\n  Key_Paste: 0,\r\n  Key_Phone: 0,\r\n  Key_Calendar: 0,\r\n  Key_Reply: 0,\r\n  Key_Reload: 0,\r\n  Key_RotateWindows: 0,\r\n  Key_RotationPB: 0,\r\n  Key_RotationKB: 0,\r\n  Key_Save: 0,\r\n  Key_Send: 0,\r\n  Key_Spell: 0,\r\n  Key_SplitScreen: 0,\r\n  Key_Support: 0,\r\n  Key_TaskPane: 0,\r\n  Key_Terminal: 0,\r\n  Key_Tools: 0,\r\n  Key_Travel: 0,\r\n  Key_Video: 0,\r\n  Key_Word: 0,\r\n  Key_Xfer: 0,\r\n  Key_ZoomIn: 0,\r\n  Key_ZoomOut: 0,\r\n  Key_Away: 0,\r\n  Key_Messenger: 0,\r\n  Key_WebCam: 0,\r\n  Key_MailForward: 0,\r\n  Key_Pictures: 0,\r\n  Key_Music: 0,\r\n  Key_Battery: 0,\r\n  Key_Bluetooth: 0,\r\n  Key_WLAN: 0,\r\n  Key_UWB: 0,\r\n  Key_AudioForward: 0,\r\n  Key_AudioRepeat: 0,\r\n  Key_AudioRandomPlay: 0,\r\n  Key_Subtitle: 0,\r\n  Key_AudioCycleTrack: 0,\r\n  Key_Time: 0,\r\n  Key_Hibernate: 0,\r\n  Key_View: 0,\r\n  Key_TopMenu: 0,\r\n  Key_PowerDown: 0,\r\n  Key_Suspend: 0,\r\n  Key_ContrastAdjust: 0,\r\n  Key_MediaLast: 0,\r\n  Key_unknown: -1,\r\n  Key_Call: 0,\r\n  Key_Camera: 0,\r\n  Key_CameraFocus: 0,\r\n  Key_Context1: 0,\r\n  Key_Context2: 0,\r\n  Key_Context3: 0,\r\n  Key_Context4: 0,\r\n  Key_Flip: 0,\r\n  Key_Hangup: 0,\r\n  Key_No: 0,\r\n  Key_Select: 93,\r\n  Key_Yes: 0,\r\n  Key_ToggleCallHangup: 0,\r\n  Key_VoiceDial: 0,\r\n  Key_LastNumberRedial: 0,\r\n  Key_Execute: 43,\r\n  Key_Printer: 42,\r\n  Key_Play: 250,\r\n  Key_Sleep: 95,\r\n  Key_Zoom: 251,\r\n  Key_Cancel: 3\r\n}\r\n\n/**\r\n * Creates and returns a signal with the parameters specified in @p params.\r\n *\r\n * @param params Array with the parameters of the signal. Each element has to be\r\n *               an object with the two properties \"type\" and \"name\" specifying\r\n *               the datatype of the parameter and its name. The type is\r\n *               currently ignored.\r\n * @param options Options that allow finetuning of the signal.\r\n */\r\nglobal.Signal = function Signal(params, options) {\r\n    options = options || {};\r\n    var connectedSlots = [];\r\n    var obj = options.obj\r\n\r\n    var signal = function() {\r\n        for (var i in connectedSlots)\r\n            try {\r\n                connectedSlots[i].slot.apply(connectedSlots[i].thisObj, arguments);\r\n            } catch(err) {\r\n                console.log(err.message);\r\n            }\r\n    };\r\n    signal.parameters = params || [];\r\n    signal.connect = function() {\r\n        if (arguments.length == 1)\r\n            connectedSlots.push({thisObj: global, slot: arguments[0]});\r\n        else if (typeof arguments[1] == 'string' || arguments[1] instanceof String) {\r\n            if (arguments[0].$tidyupList && arguments[0] !== obj)\r\n                arguments[0].$tidyupList.push(this);\r\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[0][arguments[1]]});\r\n        } else {\r\n            if (arguments[0].$tidyupList && (!obj || (arguments[0] !== obj && arguments[0] !== obj.$parent)))\r\n                arguments[0].$tidyupList.push(this);\r\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[1]});\r\n        }\r\n\r\n        // Notify object of connect\r\n        if (options.obj && options.obj.$connectNotify) {\r\n            options.obj.$connectNotify(options);\r\n        }\r\n\r\n    }\r\n    signal.disconnect = function() {\r\n        var callType = arguments.length == 1 ? (arguments[0] instanceof Function ? 1 : 2)\r\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 3 : 4;\r\n        for (var i = 0; i < connectedSlots.length; i++) {\r\n            var item = connectedSlots[i];\r\n            if ((callType == 1 && item.slot == arguments[0])\r\n                || (callType == 2 && item.thisObj == arguments[0])\r\n                || (callType == 3 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\r\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\r\n            ) {\r\n                if (item.thisObj)\r\n                    item.thisObj.$tidyupList.splice(item.thisObj.$tidyupList.indexOf(this), 1);\r\n                connectedSlots.splice(i, 1);\r\n                i--; // We have removed an item from the list so the indexes shifted one backwards\r\n            }\r\n        }\r\n\r\n        // Notify object of disconnect\r\n        if (options.obj && options.obj.$disconnectNotify) {\r\n            options.obj.$disconnectNotify(options);\r\n        }\r\n    }\r\n    signal.isConnected = function() {\r\n        var callType = arguments.length == 1 ? 1\r\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 2 : 3;\r\n        for (var i in connectedSlots) {\r\n            var item = connectedSlots[i];\r\n            if ((callType == 1 && item.slot == arguments[0])\r\n                || (callType == 2 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\r\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\r\n            )\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    return signal;\r\n}\r\n\r\n\nglobal.Font = {\r\n  // Capitalization\r\n  MixedCase: \"none\",\r\n  AllUppercase: \"uppercase\",\r\n  AllLowercase: \"lowercase\",\r\n  SmallCaps: \"smallcaps\",\r\n  Capitalize: \"capitalize\",\r\n  // Weight\r\n  Light: \"lighter\",\r\n  Normal: \"normal\",\r\n  DemiBold: \"600\",\r\n  Bold: \"bold\",\r\n  Black: \"bolder\",\r\n}\r\n\n/*global.Easing = {\r\n  Linear: 1,\r\n  InQuad: 2,          OutQuad: 3,     InOutQuad: 4,           OutInQuad: 5,\r\n  InCubic: 6,         OutCubic: 7,    InOutCubic: 8,          OutInCubic: 9,\r\n  InQuart: 10,        OutQuart: 11,   InOutQuart: 12,         OutInQuart: 13,\r\n  InQuint: 14,        OutQuint: 15,   InOutQuint: 16,         OutInQuint: 17,\r\n  InSine: 18,         OutSine: 19,    InOutSine: 20,          OutInSine: 21,\r\n  InExpo: 22,         OutExpo: 23,    InOutExpo: 24,          OutInExpo: 25,\r\n  InCirc: 26,         OutCirc: 27,    InOutCirc: 28,          OutInCirc: 29,\r\n  InElastic: 30,      OutElastic: 31, InOutElastic: 32,       OutInElastic: 33,\r\n  InBack: 34,         OutBack: 35,    InOutBack: 36,          OutInBack: 37,\r\n  InBounce: 38,       OutBounce: 39,  InOutBounce: 40,        OutInBounce: 41\r\n}*/\r\nglobal.Easing = function() {\r\n  var IN = \"In\";\r\n  var OUT = \"Out\";\r\n  return [\r\n      \"Quad\",\r\n      \"Cubic\",\r\n      \"Quart\",\r\n      \"Quint\",\r\n      \"Sine\",\r\n      \"Expo\",\r\n      \"Circ\",\r\n      \"Elastic\",\r\n      \"Back\",\r\n      \"Bounce\"\r\n    ].reduce(function(res, key) {\r\n      res.push(IN + key, OUT + key, IN + OUT + key, OUT + IN + key)\r\n      return res;\r\n    }, [\"Linear\"])\r\n    // \r\n    .reduce(function(res, key, index) {\r\n      res[key] = index + 1\r\n      return res;\r\n    }, {})\r\n}();\nvar GETTER = \"__defineGetter__\",\r\n    SETTER = \"__defineSetter__\",\r\n    // Property that is currently beeing evaluated. Used to get the information\r\n    // which property called the getter of a certain other property for\r\n    // evaluation and is thus dependant on it.\r\n    evaluatingProperty = undefined,\r\n    // All object constructors\r\n    constructors = {\r\n      int:         QMLInteger,\r\n      real:        Number,\r\n      double:      Number,\r\n      string:      String,\r\n      bool:        Boolean,\r\n      list:        QMLList,\r\n      color:       QMLColor,\r\n      enum:        Number,\r\n      url:         String,\r\n      variant:     QMLVariant,\r\n      'var':       QMLVariant,\r\n      QMLDocument: QMLComponent\r\n    };\r\nvar modules = {\r\n    Main: constructors\r\n  };\r\n\r\n// Helper. Adds a type to the constructor list\r\nglobal.registerGlobalQmlType = function (name, type) {\r\n  global[type.name]  = type;\r\n  constructors[name] = type;\r\n  modules.Main[name] = type;\r\n};\r\n\r\n// Helper. Register a type to a module\r\nglobal.registerQmlType = function(options) {\r\n  if (typeof options != 'object') {\r\n    registerGlobalQmlType(arguments[0], arguments[1]);\r\n  } else {\r\n    var moduleDescriptor = {\r\n      name:        options.name,\r\n      versions:    options.versions,\r\n      constructor: options.constructor\r\n    };\r\n\r\n    if (typeof modules[options.module] == 'undefined')\r\n      modules[options.module] = [];\r\n    modules[options.module].push(moduleDescriptor);\r\n\r\n    if (typeof options.baseClass !== 'undefined') {\r\n      inherit(options.constructor, options.baseClass);\r\n    }\r\n  }\r\n};\r\n\r\nglobal.getConstructor = function (moduleName, version, name) {\r\n  if (typeof modules[moduleName] != 'undefined') {\r\n    for (var i = 0 ; i < modules[moduleName].length ; ++i) {\r\n      var type = modules[moduleName][i];\r\n\r\n      if (type.name == name && type.versions.test(version))\r\n        return type.constructor;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nglobal.collectConstructorsForModule = function (moduleName, version) {\r\n  var constructors = {};\r\n\r\n  if (typeof modules[moduleName] == 'undefined') {\r\n    console.warn(\"module `\" + moduleName + \"` not found\");\r\n    return constructors;\r\n  }\r\n  for (var i = 0 ; i < modules[moduleName].length ; ++i) {\r\n    var module = modules[moduleName][i];\r\n\r\n    if (module.versions.test(version)) {\r\n      constructors[module.name] = module.constructor;\r\n    }\r\n  }\r\n  return constructors;\r\n};\r\n\r\nglobal.mergeObjects = function (obj1, obj2) {\r\n  var mergedObject = {};\r\n\r\n  if (typeof obj1 != 'undefined' && obj1 != null) {\r\n    for (var key in obj1) { mergedObject[key] = obj1[key]; }\r\n  }\r\n  if (typeof obj2 != 'undefined' && obj2 != null) {\r\n    for (var key in obj2) { mergedObject[key] = obj2[key]; }\r\n  }\r\n  return mergedObject;\r\n}\r\n\r\nglobal.perContextConstructors = {};\r\n\r\nglobal.loadImports = function (self, imports) {\r\n  constructors = mergeObjects(modules.Main, null);\r\n  for (var i = 0 ; i < imports.length ; ++i) {\r\n    var moduleName = imports[i][1],\r\n        moduleVersion = imports[i][2],\r\n        moduleAlias = imports[i][3],\r\n        moduleConstructors = collectConstructorsForModule(moduleName, moduleVersion);\r\n\r\n    if (moduleAlias !== \"\")\r\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\r\n    else\r\n      constructors = mergeObjects(constructors, moduleConstructors);\r\n  }\r\n  perContextConstructors[self.objectId] = constructors;\r\n}\r\n\r\nglobal.inherit = function(constructor, baseClass) {\r\n  var oldProto = constructor.prototype;\r\n  constructor.prototype = Object.create(baseClass.prototype);\r\n  Object.keys(oldProto).forEach(function(prop) {\r\n    constructor.prototype[prop] = oldProto[prop];\r\n  });\r\n  constructor.prototype.constructor = baseClass;\r\n}\r\n\r\n/**\r\n * QML Object constructor.\r\n * @param {Object} meta Meta information about the object and the creation context\r\n * @return {Object} New qml object\r\n */\r\nfunction construct(meta) {\r\n    var item,\r\n        component;\r\n\r\n    if (meta.object.$class in constructors) {\r\n        item = new constructors[meta.object.$class](meta);\r\n    }\r\n    else {\r\n        // Load component from file. Please look at import.js for main notes.\r\n        // Actually, we have to use that order:\r\n        // 1) try to load component from current basePath\r\n        // 2) from importPathList\r\n        // 3) from directories in imports statements and then\r\n        // 4) from qmldir files\r\n        // Currently we support only 1,2 and 4 and use order: 4,1,2\r\n        // TODO: engine.qmldirs is global for all loaded components. That's not qml's original behaviour.\r\n        var qdirInfo = engine.qmldirs[meta.object.$class]; // Are we have info on that component in some imported qmldir files?\r\n        if (qdirInfo) {\r\n            // We have that component in some qmldir, load it from qmldir's url\r\n            component = Qt.createComponent( \"@\" + qdirInfo.url, meta.context);\r\n        }\r\n        else\r\n            component = Qt.createComponent(meta.object.$class + \".qml\", meta.context);\r\n\r\n        if (component) {\r\n            var item = component.createObject(meta.parent);\r\n\r\n            if (typeof item.dom != 'undefined')\r\n                item.dom.className += \" \" + meta.object.$class + (meta.object.id ? \" \" + meta.object.id : \"\");\r\n            var dProp; // Handle default properties\r\n        } else {\r\n            console.log(\"No constructor found for \" + meta.object.$class);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // id\r\n    if (meta.object.id)\r\n        meta.context[meta.object.id] = item;\r\n\r\n    // keep path in item for probale use it later in Qt.resolvedUrl\r\n    item.$context[\"$basePath\"] = engine.$basePath; //gut\r\n\r\n    // Apply properties (Bindings won't get evaluated, yet)\r\n    applyProperties(meta.object, item, item, item.$context);\r\n\r\n    return item;\r\n}\r\n\r\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {String} propName Property name\r\n * @param {Object} [options] Options that allow finetuning of the property\r\n */\r\nfunction createSimpleProperty(type, obj, propName, options) {\r\n    var prop = new QMLProperty(type, obj, propName);\r\n    var getter, setter;\r\n\r\n    if (typeof options == 'undefined')\r\n      options = {};\r\n    else if (typeof options != 'object')\r\n      options = { default: options }\r\n\r\n    obj[propName + \"Changed\"] = prop.changed;\r\n    obj.$properties[propName] = prop;\r\n    obj.$properties[propName].set(options.default);\r\n    getter = function()       { return obj.$properties[propName].get(); };\r\n    if (!options.readOnly)\r\n      setter = function(newVal) { return obj.$properties[propName].set(newVal); };\r\n    else {\r\n      setter = function(newVal) {\r\n        if (obj.$canEditReadOnlyProperties != true)\r\n          throw \"property '\" + propName + \"' has read only access\";\r\n        return obj.$properties[propName].set(newVal);\r\n      }\r\n    }\r\n    setupGetterSetter(obj, propName, getter, setter);\r\n    if (obj.$isComponentRoot)\r\n        setupGetterSetter(obj.$context, propName, getter, setter);\r\n}\r\n\r\n/**\r\n * Set up simple getter function for property\r\n */\r\nvar setupGetter,\r\n    setupSetter,\r\n    setupGetterSetter;\r\n(function() {\r\n\r\n// todo: What's wrong with Object.defineProperty on some browsers?\r\n// Object.defineProperty is the standard way to setup getters and setters.\r\n// However, the following way to use Object.defineProperty don't work on some\r\n// webkit-based browsers, namely Safari, iPad, iPhone and Nokia N9 browser.\r\n// Chrome, firefox and opera still digest them fine.\r\n\r\n// So, if the deprecated __defineGetter__ is available, use those, and if not\r\n// use the standard Object.defineProperty (IE for example).\r\n\r\n    var useDefineProperty = !(Object[GETTER] && Object[SETTER]);\r\n\r\n    if (useDefineProperty) {\r\n\r\n        if (!Object.defineProperty) {\r\n            console.log(\"No __defineGetter__ or defineProperty available!\");\r\n        }\r\n\r\n        setupGetter = function(obj, propName, func) {\r\n            Object.defineProperty(obj, propName,\r\n                { get: func, configurable: true, enumerable: true } );\r\n        }\r\n        setupSetter = function(obj, propName, func) {\r\n            Object.defineProperty(obj, propName,\r\n                { set: func, configurable: true, enumerable: false });\r\n        }\r\n        setupGetterSetter = function(obj, propName, getter, setter) {\r\n            Object.defineProperty(obj, propName,\r\n                {get: getter, set: setter, configurable: true, enumerable: false });\r\n        }\r\n    } else {\r\n        setupGetter = function(obj, propName, func) {\r\n            obj[GETTER](propName, func);\r\n        }\r\n        setupSetter = function(obj, propName, func) {\r\n            obj[SETTER](propName, func);\r\n        }\r\n        setupGetterSetter = function(obj, propName, getter, setter) {\r\n            obj[GETTER](propName, getter);\r\n            obj[SETTER](propName, setter);\r\n        }\r\n    }\r\n\r\n})();\r\n/**\r\n * Apply properties from metaObject to item.\r\n * @param {Object} metaObject Source of properties\r\n * @param {Object} item Target of property apply\r\n * @param {Object} objectScope Scope in which properties should be evaluated\r\n * @param {Object} componentScope Component scope in which properties should be evaluated\r\n */\r\nfunction applyProperties(metaObject, item, objectScope, componentScope) {\r\n    var i;\r\n    objectScope = objectScope || item;\r\n    for (i in metaObject) {\r\n        var value = metaObject[i];\r\n        // skip global id's and internal values\r\n        if (i == \"id\" || i[0] == \"$\") {\r\n            continue;\r\n        }\r\n        // slots\r\n        if (i.indexOf(\"on\") == 0 && i[2].toUpperCase() == i[2]) {\r\n            var signalName =  i[2].toLowerCase() + i.slice(3);\r\n            if (!item[signalName]) {\r\n                console.warn(\"No signal called \" + signalName + \" found!\");\r\n                continue;\r\n            }\r\n            else if (typeof item[signalName].connect != 'function') {\r\n                console.warn(signalName + \" is not a signal!\");\r\n                continue;\r\n            }\r\n            if (!value.eval) {\r\n                var params = \"\";\r\n                for (var j in item[signalName].parameters) {\r\n                    params += j==0 ? \"\" : \", \";\r\n                    params += item[signalName].parameters[j].name;\r\n                }\r\n                value.src = \"(function(\" + params + \") {\" + value.src + \"})\";\r\n                value.function = false;\r\n                value.compile();\r\n            }\r\n            item[signalName].connect(item, value.eval(objectScope, componentScope));\r\n            continue;\r\n        }\r\n\r\n        if (value instanceof Object) {\r\n            if (value instanceof QMLSignalDefinition) {\r\n                item[i] = Signal(value.parameters);\r\n                if (item.$isComponentRoot)\r\n                    componentScope[i] = item[i];\r\n                continue;\r\n            } else if (value instanceof QMLMethod) {\r\n                value.compile();\r\n                item[i] = value.eval(objectScope, componentScope);\r\n                if (item.$isComponentRoot)\r\n                    componentScope[i] = item[i];\r\n                continue;\r\n            } else if (value instanceof QMLAliasDefinition) {\r\n                createSimpleProperty(\"alias\", item, i);\r\n                item.$properties[i].componentScope = componentScope;\r\n                item.$properties[i].val = value;\r\n                item.$properties[i].get = function() {\r\n                    var obj = this.componentScope[this.val.objectName];\r\n                    return this.val.propertyName ? obj.$properties[this.val.propertyName].get() : obj;\r\n                }\r\n                item.$properties[i].set = function(newVal, fromAnimation, objectScope, componentScope) {\r\n                    if (!this.val.propertyName)\r\n                        throw \"Cannot set alias property pointing to an QML object.\";\r\n                    this.componentScope[this.val.objectName].$properties[this.val.propertyName].set(newVal, fromAnimation, objectScope, componentScope);\r\n                }\r\n                continue;\r\n            } else if (value instanceof QMLPropertyDefinition) {\r\n                createSimpleProperty(value.type, item, i);\r\n                item.$properties[i].set(value.value, true, objectScope, componentScope);\r\n                continue;\r\n            } else if (item[i] && value instanceof QMLMetaPropertyGroup) {\r\n                // Apply properties one by one, otherwise apply at once\r\n                applyProperties(value, item[i], objectScope, componentScope);\r\n                continue;\r\n            }\r\n        }\r\n        if (item.$properties && i in item.$properties)\r\n            item.$properties[i].set(value, true, objectScope, componentScope);\r\n        else if (i in item)\r\n            item[i] = value;\r\n        else if (item.$setCustomData)\r\n            item.$setCustomData(i, value);\r\n        else\r\n            console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\r\n    }\r\n    if (metaObject.$children && metaObject.$children.length !== 0) {\r\n        if (item.$defaultProperty)\r\n            item.$properties[item.$defaultProperty].set(metaObject.$children, true, objectScope, componentScope);\r\n        else\r\n            throw \"Cannot assign to unexistant default property\";\r\n    }\r\n    // We purposefully set the default property AFTER using it, in order to only have it applied for\r\n    // instanciations of this component, but not for its internal children\r\n    if (metaObject.$defaultProperty)\r\n        item.$defaultProperty = metaObject.$defaultProperty;\r\n    if (typeof item.completed != 'undefined' && item.completedAlreadyCalled == false) {\r\n      item.completedAlreadyCalled = true;\r\n      item.completed();\r\n    }\r\n}\r\n\r\n// ItemModel. EXPORTED.\r\nJSItemModel = function() {\r\n    this.roleNames = [];\r\n\r\n    this.setRoleNames = function(names) {\r\n        this.roleNames = names;\r\n    }\r\n\r\n    this.dataChanged = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.rowsInserted = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.rowsMoved = Signal([\r\n        {type:\"int\", name:\"sourceStartIndex\"},\r\n        {type:\"int\", name:\"sourceEndIndex\"},\r\n        {type:\"int\", name:\"destinationIndex\"}\r\n    ]);\r\n    this.rowsRemoved = Signal([\r\n        {type:\"int\", name:\"startIndex\"},\r\n        {type:\"int\", name:\"endIndex\"}\r\n    ]);\r\n    this.modelReset = Signal();\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n// Stuff below defines QML things\r\n// -----------------------------------------------------------------------------\r\n\r\n// Helper\r\nfunction unboundMethod() {\r\n    console.log(\"Unbound method for\", this);\r\n}\r\n\n(function() {\r\n  var uglify_parse;\r\n\r\n  if (typeof module !== 'undefined' && module.exports)\r\n    uglify_parse = require(\"uglify-js\").parse;\r\n  else\r\n    uglify_parse = parse;\r\n\r\n  global.importJavascriptInContext = function (jsData, $context) {\r\n    with($context) {\r\n      eval(jsData.source);\r\n      for (var i = 0 ; i < jsData.exports.length ; ++i) {\r\n        var symbolName = jsData.exports[i];\r\n        $context[symbolName] = eval(symbolName);\r\n      }\r\n    }\r\n  }\r\n\r\n  global.jsparse = function (source) {\r\n    var AST_Tree = uglify_parse(source);\r\n    var obj = { exports: [], source: source };\r\n\r\n    for (var i = 0 ; i < AST_Tree.body.length ; ++i) {\r\n      var element = AST_Tree.body[i];\r\n\r\n      switch (element.__proto__.TYPE) {\r\n        case \"VAR\":\r\n          obj.exports.push(element.definitions[0].name.name);\r\n          break ;\r\n        case \"Defun\":\r\n          obj.exports.push(element.name.name);\r\n          break ;\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n})();\r\n\n// Base object for all qml elements\r\nfunction QMLBaseObject(meta) {\r\n    QObject.call(this, meta.parent);\r\n    var i,\r\n        prop;\r\n\r\n    this.$draw = function(){};\r\n    this.$isComponentRoot = meta.isComponentRoot;\r\n    this.$context = meta.context;\r\n\r\n    // Component.onCompleted\r\n    this.Component = new QObject(this);\r\n    this.Component.completed = Signal([]);\r\n    engine.completedSignals.push(this.Component.completed);\r\n    this.completed = this.Component.completed;\r\n\r\n    this.Component.destruction = Signal([]);\r\n    this.destruction = this.Component.destruction;\r\n\r\n    // Component get own properties\r\n    var attributes = [];\r\n    for (var key in meta.object) {\r\n      if (meta.object.hasOwnProperty(key) &&\r\n          typeof meta.object[key] != 'undefined' && meta.object[key] != null &&\r\n          (meta.object[key].__proto__.constructor.name == 'QMLPropertyDefinition' ||\r\n           meta.object[key].__proto__.constructor.name == 'QMLAliasDefinition')) {\r\n        attributes.push(key);\r\n      }\r\n    }\r\n\r\n    this.Keys = new QObject(this);\r\n    this.Keys.asteriskPresed = Signal();\r\n    this.Keys.backPressed = Signal();\r\n    this.Keys.backtabPressed = Signal();\r\n    this.Keys.callPressed = Signal();\r\n    this.Keys.cancelPressed = Signal();\r\n    this.Keys.deletePressed = Signal();\r\n    for (var i = 0 ; i < 10 ; ++i)\r\n      this.Keys['digit'+i+'Pressed'] = Signal();\r\n    this.Keys.escapePressed = Signal();\r\n    this.Keys.flipPressed = Signal();\r\n    this.Keys.hangupPressed = Signal();\r\n    this.Keys.leftPressed = Signal();\r\n    this.Keys.menuPressed = Signal();\r\n    this.Keys.noPressed = Signal();\r\n    this.Keys.pressed = Signal();\r\n    this.Keys.released = Signal();\r\n    this.Keys.returnPressed = Signal();\r\n    this.Keys.rightPressed = Signal();\r\n    this.Keys.selectPressed = Signal();\r\n    this.Keys.spacePressed = Signal();\r\n    this.Keys.tabPressed = Signal();\r\n    this.Keys.upPressed = Signal();\r\n    this.Keys.volumeDownPressed = Signal();\r\n    this.Keys.volumeUpPressed = Signal();\r\n    this.Keys.yesPressed = Signal();\r\n\r\n    this.getAttributes = function() { return (attributes); }\r\n}\r\n\r\nregisterQmlType({\r\n    module: 'QtQuick',\r\n    name: 'QtObject',\r\n    versions: /.*/,\r\n    constructor: QMLBaseObject\r\n});\r\n\n// TODO\r\nfunction QMLColor(val) {\r\n  if (typeof val === \"number\") {\r\n    // we assume it is int value and must be converted to css hex with padding\r\n    // http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript\r\n    val = \"#\" + (Math.round(val) + 0x1000000).toString(16).substr(-6).toUpperCase();\r\n  } else {\r\n    if(typeof val === \"array\" && val.length >= 3) {\r\n      // array like [r,g,b] where r,g,b are in 0..1 range\r\n      var m = 255;\r\n      val = \"rgb(\" + Math.round(m * val[0]) + \",\" + Math.round(m * val[1]) + \",\" + Math.round(m * val[2]) + \")\";\r\n    }\r\n  }\r\n  return val;\r\n};\r\n\nfunction QMLContext() {\r\n    this.nameForObject = function(obj) {\r\n        for (var name in this) {\r\n            if (this[name] == obj)\r\n                return name;\r\n        }\r\n    }\r\n}\r\n\r\nQMLComponent.prototype.createObject = function(parent, properties) {\r\n    var oldState = engine.operationState;\r\n    engine.operationState = QMLOperationState.Init;\r\n    // change base path to current component base path\r\n    var bp = engine.$basePath; engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\r\n\r\n    var item = construct({\r\n        object: this.$metaObject,\r\n        parent: parent,\r\n        context: this.$context ? Object.create(this.$context) : new QMLContext(),\r\n        isComponentRoot: true\r\n    });\r\n\r\n    // change base path back\r\n    //TODO looks a bit hacky\r\n    engine.$basePath = bp;\r\n\r\n    engine.operationState = oldState;\r\n    return item;\r\n}\r\n\r\nfunction QMLComponent(meta) {\r\n    if (constructors[meta.object.$class] == QMLComponent)\r\n        this.$metaObject = meta.object.$children[0];\r\n    else\r\n        this.$metaObject = meta.object;\r\n    this.$context = meta.context;\r\n\r\n    var jsImports = [];\r\n\r\n    this.finalizeImports = (function($context) {\r\n      for (var i = 0 ; i < jsImports.length ; ++i) {\r\n        var importDesc = jsImports[i];\r\n        var src = importDesc[1];\r\n        var js;\r\n\r\n        if (typeof qmlEngine.$basePath != 'undefined')\r\n          src = qmlEngine.$basePath + src;\r\n        if (typeof qrc[src] != 'undefined')\r\n          js = qrc[src];\r\n        else\r\n          js = global.jsparse(getUrlContents(src));\r\n        if (importDesc[3] !== \"\") {\r\n          $context[importDesc[3]] = {};\r\n          importJavascriptInContext(js, $context[importDesc[3]]);\r\n        }\r\n        else\r\n          importJavascriptInContext(js, $context);\r\n      }\r\n    }).bind(this);\r\n\r\n    if (meta.object.$imports instanceof Array)\r\n    {\r\n      var moduleImports = [];\r\n      var loadImport    = (function(importDesc) {\r\n        if (/\\.js$/.test(importDesc[1]))\r\n          jsImports.push(importDesc);\r\n        else\r\n          moduleImports.push(importDesc);\r\n      }).bind(this);\r\n\r\n      for (var i = 0 ; i < meta.object.$imports.length ; ++i) {\r\n        loadImport(meta.object.$imports[i]);\r\n      }\r\n      loadImports(this, moduleImports);\r\n      if (typeof this.$context != 'undefined' && this.$context != null)\r\n        this.finalizeImports(this.$context);\r\n    }\r\n}\r\ninherit(QMLComponent, QMLBaseObject);\r\n\r\nregisterQmlType('Component',   QMLComponent);\r\nregisterQmlType('QMLDocument', QMLComponent);\r\n\n/*\r\n * - QMLEngine(element, options) -- Returns new qml engine object, for which:\r\n *   - loadFile(file) -- Load file to the engine (.qml or .qml.js atm)\r\n *   - start() -- start the engine/application\r\n *   - stop() -- stop the engine/application. Restarting is experimental.\r\n *   element is HTMLCanvasElement and options are for debugging.\r\n *   For further reference, see testpad and qml viewer applications.\r\n */\r\n\r\n// There can only be one running QMLEngine. This variable points to the currently running engine.\r\nvar engine = null;\r\n\r\n// QML engine. EXPORTED.\r\nQMLEngine = function (element, options) {\r\n//----------Public Members----------\r\n    this.fps = 60;\r\n    this.$interval = Math.floor(1000 / this.fps); // Math.floor, causes bugs to timing?\r\n    this.running = false;\r\n\r\n    // Mouse Handling\r\n    this.mouseAreas = [];\r\n    this.oldMousePos = {x:0, y:0};\r\n\r\n    // List of available Components\r\n    this.components = {};\r\n\r\n    this.rootElement = element;\r\n\r\n    // List of Component.completed signals\r\n    this.completedSignals = [];\r\n\r\n    // Current operation state of the engine (Idle, init, etc.)\r\n    this.operationState = 1;\r\n\r\n    // List of properties whose values are bindings. For internal use only.\r\n    this.bindedProperties = [];\r\n\r\n    // Root object of the engine\r\n    this.rootObject = null;\r\n\r\n    // Base path of qml engine (used for resource loading)\r\n    this.$basePath = \"\";\r\n\r\n\r\n//----------Public Methods----------\r\n    // Start the engine\r\n    this.start = function()\r\n    {\r\n        engine = this;\r\n        var i;\r\n        if (this.operationState !== QMLOperationState.Running) {\r\n            this.operationState = QMLOperationState.Running;\r\n            tickerId = setInterval(tick, this.$interval);\r\n            for (i = 0; i < whenStart.length; i++) {\r\n                whenStart[i]();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Stop the engine\r\n    this.stop = function()\r\n    {\r\n        var i;\r\n        if (this.operationState == QMLOperationState.Running) {\r\n            element.removeEventListener(\"touchstart\", touchHandler);\r\n            element.removeEventListener(\"mousemove\", mousemoveHandler);\r\n            clearInterval(tickerId);\r\n            this.operationState = QMLOperationState.Idle;\r\n            for (i = 0; i < whenStop.length; i++) {\r\n                whenStop[i]();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    this.ensureFileIsLoadedInQrc = function(file) {\r\n      if (!qrc.includesFile(file)) {\r\n        var src = getUrlContents(file);\r\n\r\n        if (src) {\r\n            console.log('Loading file [', file, ']');\r\n            qrc[file] = qmlparse(src);\r\n        } else {\r\n            console.log('Can not load file [', file, ']');\r\n        }\r\n      }\r\n    }\r\n\r\n    this.extractBasePath = function( file ) {\r\n       var basePath = file.split(/[\\/\\\\]/); // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\r\n       basePath[basePath.length - 1] = \"\";\r\n       basePath = basePath.join(\"/\");\r\n       return basePath;\r\n    }\r\n    // Load file, parse and construct (.qml or .qml.js)\r\n    this.loadFile = function(file) {\r\n        var tree;\r\n\r\n        this.$basePath = this.extractBasePath(file);\r\n        this.ensureFileIsLoadedInQrc(file);\r\n        tree = convertToEngine(qrc[file]);\r\n        this.loadQMLTree(tree);\r\n    }\r\n\r\n    // parse and construct qml\r\n    this.loadQML = function(src) {\r\n        this.loadQMLTree(parseQML(src));\r\n    }\r\n\r\n    this.loadQMLTree = function(tree, file) {\r\n        engine = this;\r\n        if (options.debugTree) {\r\n            options.debugTree(tree);\r\n        }\r\n\r\n        // Create and initialize objects\r\n        var component = new QMLComponent({ object: tree, parent: null });\r\n\r\n        this.loadImports( tree.$imports );\r\n        component.$basePath = engine.$basePath;\r\n        component.$imports = tree.$imports; // for later use\r\n        component.$file = file; // just for debugging\r\n\r\n        this.rootObject = component.createObject(null);\r\n        component.finalizeImports(this.rootContext());\r\n        this.$initializePropertyBindings();\r\n\r\n        this.start();\r\n\r\n        // Call completed signals\r\n        for (var i in this.completedSignals) {\r\n            this.completedSignals[i]();\r\n        }\r\n    }\r\n\r\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\r\n     *\r\n     * Removes dot segments in given path component, as described in\r\n     * RFC 3986, section 5.2.4.\r\n     *\r\n     * @param {string} path A non-empty path component.\r\n     * @return {string} Path component with removed dot segments.\r\n     */\r\n    this.removeDotSegments = function(path) {\r\n        var leadingSlash = (path && path[0] == \"/\");   // path.startsWith('/'); -- startsWith seems to be undefined in some browsers\r\n        var segments = path.split('/');\r\n        var out = [];\r\n\r\n        for (var pos = 0; pos < segments.length; ) {\r\n            var segment = segments[pos++];\r\n\r\n            if (segment == '.') {\r\n                if (leadingSlash && pos == segments.length) {\r\n                    out.push('');\r\n                }\r\n            } else if (segment == '..') {\r\n                if (out.length > 1 || out.length == 1 && out[0] != '') {\r\n                    out.pop();\r\n                }\r\n                if (leadingSlash && pos == segments.length) {\r\n                    out.push('');\r\n                }\r\n            } else {\r\n                out.push(segment);\r\n                leadingSlash = true;\r\n            }\r\n        }\r\n\r\n        return out.join('/');\r\n    };\r\n\r\n    /*\r\n      engine.loadImports( imports, currentDir ) : performs loading of qmldir files from given qml import records.\r\n\r\n      Input:\r\n      * parameter `importsArray` - import statements. It is in parser notation, e.g. [import1, import2, ...] where each importN is also array: [\"qmlimport\",\"name\",version,as,isQualifiedName]\r\n      * parameter `currentFileDir` - base dir for imports lookup. It will be used together with importPathList()\r\n\r\n      Implicit input:\r\n      * engine object function `importPathList()` - list of urls bases used for qmldir files lookup\r\n\r\n      Additional implicit input/output:\r\n      * engine object variable `qmldirsContents` - used for caching, e.g. memory for previously loaded qmldir files\r\n\r\n      Output: \r\n      * engine object variable `qmldirs` - new records will be added there\r\n\r\n      Return value: \r\n      * nothing\r\n\r\n      Details:\r\n\r\n      For each of given import statements, loadImports \r\n      1. computes qmldir file location according to http://doc.qt.io/qt-5/qtqml-syntax-imports.html\r\n      2. calls `readQmlDir` for actual reading and parsing of qmldir file content\r\n      3. gets `external` declarations of that qmldir file and pushes them to `engine.qmldirs` hash.\r\n\r\n      `engine.qmldirs` is a hash of form: { componentName => componentFileUrl }\r\n      This hash then used by `qml.js::construct` method for computing component urls.\r\n\r\n      Notes:\r\n      1. This method is not suited for loading js imports. This may be done probably after answering to Q1 (below).\r\n      2. Please look for additional notes at readQmlDir function.\r\n\r\n      QNA\r\n      Q1: How and where in engine component names might be prefixed? E.g. names with dot inside: SomeModule.Component1\r\n      A1: Seems it doesn't matter. Seems we may just save name with dot-inside right to qmldirs, and it may be used by construct() seamlessly. Check it..\r\n\r\n      Q2: How we may access component object from here, to store qmldirs info in components logical scope, and not at engine scope?\r\n      A2: Probably, answer is in Component.js and in global.loadImports\r\n\r\n      TODO \r\n      * We have to keep output in component scope, not in engine scope.\r\n      * We have to add module \"as\"-names to component's names (which is possible after keeping imports in component scope).\r\n      * Determine how this stuff is related to `global.loadImports`\r\n      * Check A1\r\n      * Make a complete picture of what going in with imports, including Component.js own imports loading\r\n      * Note importJs method in import.js \r\n    */\r\n\r\n    this.loadImports = function(importsArray, currentFileDir) {\r\n        if (!this.qmldirsContents) this.qmldirsContents = { \"QtQuick\":{}, \"QtQuick.Controls\":{} }; // cache\r\n        // putting initial keys in qmldirsContents - is a hack. We should find a way to explain to qmlweb, is this built-in module or qmldir-style module.\r\n\r\n        if (!this.qmldirs) this.qmldirs = {};                 // resulting components lookup table\r\n\r\n        if (!importsArray || importsArray.length == 0) return;\r\n        if (!currentFileDir) currentFileDir = this.$basePath;     // use this.$basePath by default\r\n\r\n        for (var i=0; i<importsArray.length; i++) {\r\n            var entry = importsArray[i];\r\n\r\n            var name = entry[1];\r\n\r\n            var nameIsUrl = name.indexOf(\"//\") == 0 || name.indexOf(\"://\") >= 0;  // is it url to remote resource\r\n            var nameIsQualifiedModuleName = entry[4]; // e.g. QtQuick, QtQuick.Controls, etc\r\n            var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl; // local [relative] dir\r\n\r\n            if (nameIsDir) {\r\n                // resolve name from relative to full dir path\r\n                // we hope all dirs are relative\r\n                name = this.removeDotSegments( currentFileDir + name );\r\n                if (name[ name.length-1 ] == \"/\")\r\n                    name = name.substr( 0, name.length-1 ); // remove trailing slash as it required for `readQmlDir`\r\n            }\r\n            // TODO if nameIsDir, we have also to add `name` to importPathList() for current component...\r\n\r\n            // check if we have already loaded that qmldir file\r\n            if (this.qmldirsContents[ name ]) continue;\r\n\r\n            var content = false;\r\n            if (nameIsQualifiedModuleName && this.userAddedModulePaths && this.userAddedModulePaths[ name ]) {\r\n                // 1. we have qualified module and user had configured path for that module with this.addModulePath\r\n                content = readQmlDir( this.userAddedModulePaths[ name ] );\r\n            }\r\n            else if (nameIsUrl || nameIsDir)\r\n            {\r\n                // 2. direct load\r\n                // nameIsUrl => url do not need dirs\r\n                // nameIsDir => already computed full path above\r\n                content = readQmlDir( name );\r\n            }\r\n            else\r\n            {\r\n                // 3. qt-style lookup for qualified module\r\n                var probableDirs = [currentFileDir].concat( this.importPathList() )\r\n                var diredName = name.replace( /\\./g,\"/\" );\r\n\r\n                for (var k=0; k<probableDirs.length; k++) {\r\n                    var file = probableDirs[k] + diredName;\r\n                    content = readQmlDir( file );\r\n                    if (content) break;\r\n                }\r\n            }\r\n\r\n            if (!content) {\r\n                console.log(\"qmlengine::loadImports: cannot load qmldir file for import name=\",name );\r\n                // save blank info, meaning that we failed to load import\r\n                // this prevents repeated lookups\r\n                this.qmldirsContents[ name ] = {};\r\n\r\n               // NEW\r\n               // add that dir to import path list\r\n               // that means, lookup qml files in that failed dir by trying to load them directly\r\n               // this is not the same behavior as in Qt for \"url\" schemes,\r\n               // but it is same as for ordirnal disk files. \r\n               // So, we do it for experimental purposes.\r\n               if (nameIsDir) \r\n                 this.addImportPath( name + \"/\" );\r\n\r\n               continue;\r\n            }\r\n\r\n            // copy founded externals to global var\r\n            // TODO actually we have to copy it to current component\r\n            for (var attrname in content.externals) { this.qmldirs[attrname] = content.externals[attrname]; }\r\n\r\n            // keep already loaded qmldir files\r\n            this.qmldirsContents[ name ] = content;\r\n        }\r\n\r\n    }\r\n\r\n    this.rootContext = function() {\r\n      return this.rootObject.$context;\r\n    }\r\n\r\n    this.focusedElement = (function() {\r\n      return this.rootContext().activeFocus;\r\n    }).bind(this);\r\n\r\n    // KEYBOARD MANAGEMENT\r\n    var keyboardSignals = {};\r\n    keyboardSignals[Qt.Key_Asterisk]   = 'asteriskPressed';\r\n    keyboardSignals[Qt.Key_Back]       = 'backPressed';\r\n    keyboardSignals[Qt.Key_Backtab]    = 'backtabPressed';\r\n    keyboardSignals[Qt.Key_Call]       = 'callPressed';\r\n    keyboardSignals[Qt.Key_Cancel]     = 'cancelPressed';\r\n    keyboardSignals[Qt.Key_Delete]     = 'deletePressed';\r\n    keyboardSignals[Qt.Key_0]          = 'digit0Pressed';\r\n    keyboardSignals[Qt.Key_1]          = 'digit1Pressed';\r\n    keyboardSignals[Qt.Key_2]          = 'digit2Pressed';\r\n    keyboardSignals[Qt.Key_3]          = 'digit3Pressed';\r\n    keyboardSignals[Qt.Key_4]          = 'digit4Pressed';\r\n    keyboardSignals[Qt.Key_5]          = 'digit5Pressed';\r\n    keyboardSignals[Qt.Key_6]          = 'digit6Pressed';\r\n    keyboardSignals[Qt.Key_7]          = 'digit7Pressed';\r\n    keyboardSignals[Qt.Key_8]          = 'digit8Pressed';\r\n    keyboardSignals[Qt.Key_9]          = 'digit9Pressed';\r\n    keyboardSignals[Qt.Key_Escape]     = 'escapePressed';\r\n    keyboardSignals[Qt.Key_Flip]       = 'flipPressed';\r\n    keyboardSignals[Qt.Key_Hangup]     = 'hangupPressed';\r\n    keyboardSignals[Qt.Key_Menu]       = 'menuPressed';\r\n    keyboardSignals[Qt.Key_No]         = 'noPressed';\r\n    keyboardSignals[Qt.Key_Return]     = 'returnPressed';\r\n    keyboardSignals[Qt.Key_Select]     = 'selectPressed';\r\n    keyboardSignals[Qt.Key_Space]      = 'spacePressed';\r\n    keyboardSignals[Qt.Key_Tab]        = 'tabPressed';\r\n    keyboardSignals[Qt.Key_VolumeDown] = 'volumeDownPressed';\r\n    keyboardSignals[Qt.Key_VolumeUp]   = 'volumeUpPressed';\r\n    keyboardSignals[Qt.Key_Yes]        = 'yesPressed';\r\n    keyboardSignals[Qt.Key_Up]         = 'upPressed';\r\n    keyboardSignals[Qt.Key_Right]      = 'rightPressed';\r\n    keyboardSignals[Qt.Key_Down]       = 'downPressed';\r\n    keyboardSignals[Qt.Key_Left]       = 'leftPressed';\r\n\r\n    function keyCodeToQt(e) {\r\n      if (e.keyCode >= 96 && e.keyCode <= 111) {\r\n        e.keypad = true;\r\n      }\r\n      if (e.keyCode == Qt.Key_Tab && e.shiftKey == true)\r\n        return Qt.Key_Backtab;\r\n      else if (e.keyCode >= 97 && e.keyCode <= 122)\r\n        return e.keyCode - (97 - Qt.Key_A);\r\n      return e.keyCode;\r\n    }\r\n\r\n    function eventToKeyboard(e) {\r\n        return {\r\n            accepted: false,\r\n            count: 1,\r\n            isAutoRepeat: false,\r\n            key: keyCodeToQt(e),\r\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\r\n                    | (e.altKey   * Qt.AltModifier)\r\n                    | (e.shiftKey * Qt.ShiftModifier)\r\n                    | (e.metaKey  * Qt.MetaModifier)\r\n                    | (e.keypad   * Qt.KeypadModifier),\r\n            text: String.fromCharCode(e.charCode)\r\n        };\r\n    }\r\n\r\n    document.onkeypress = (function(e) {\r\n      var focusedElement = this.focusedElement();\r\n      var event          = eventToKeyboard(e || window.event);\r\n      var eventName      = keyboardSignals[event.key];\r\n\r\n      while (event.accepted != true && focusedElement != null) {\r\n        var backup       = focusedElement.$context.event;\r\n\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.pressed(event);\r\n        if (eventName != null)\r\n          focusedElement.Keys[eventName](event);\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted == true)\r\n          e.preventDefault();\r\n        else\r\n          focusedElement = focusedElement.$parent;\r\n      }\r\n    }).bind(this);\r\n\r\n    document.onkeyup = (function(e) {\r\n      var focusedElement = this.focusedElement();\r\n      var event          = eventToKeyboard(e || window.event);\r\n\r\n      while (event.accepted != true && focusedElement != null) {\r\n        var backup       = focusedElement.$context.event;\r\n\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.released(event);\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted == true)\r\n          e.preventDefault();\r\n        else\r\n          focusedElement = focusedElement.$parent;\r\n      }\r\n    }).bind(this);\r\n    // END KEYBOARD MANAGEMENT\r\n\r\n    this.registerProperty = function(obj, propName)\r\n    {\r\n        var dependantProperties = [];\r\n        var value = obj[propName];\r\n\r\n        function getter() {\r\n            if (evaluatingProperty && dependantProperties.indexOf(evaluatingProperty) == -1)\r\n                dependantProperties.push(evaluatingProperty);\r\n\r\n            return value;\r\n        }\r\n\r\n        function setter(newVal) {\r\n            value = newVal;\r\n\r\n            for (i in dependantProperties)\r\n                dependantProperties[i].update();\r\n        }\r\n\r\n        setupGetterSetter(obj, propName, getter, setter);\r\n    }\r\n\r\n    // next 3 methods used in Qt.createComponent for qml files lookup\r\n    // please open qt site for documentation\r\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\r\n\r\n    this.addImportPath = function( dirpath ) {\r\n        if (!this.userAddedImportPaths) this.userAddedImportPaths = [];\r\n        this.userAddedImportPaths.push( dirpath );\r\n    }\r\n\r\n    this.setImportPathList = function( arrayOfDirs )\r\n    {\r\n        this.userAddedImportPaths = arrayOfDirs;\r\n    }\r\n\r\n    this.importPathList = function() {\r\n        return (this.userAddedImportPaths || []);\r\n    }\r\n\r\n    // `addModulePath` defines conrete path for module lookup\r\n    // e.g. addModulePath( \"QtQuick.Controls\",\"http://someserver.com/controls\" )\r\n    // will force system to `import QtQuick.Controls` module from `http://someserver.com/controls/qmldir`\r\n\r\n    this.addModulePath = function( moduleName, dirPath ) {\r\n\r\n        // remove trailing slash as it required for `readQmlDir`\r\n        if (dirPath[ dirPath.length-1 ] == \"/\")\r\n            dirPath = dirPath.substr( 0, dirPath.length-1 );\r\n\r\n        // keep the mapping. It will be used in loadImports() function .\r\n        if (!this.userAddedModulePaths) this.userAddedModulePaths = {};\r\n        this.userAddedModulePaths[ moduleName ] = dirPath;\r\n    }\r\n\r\n//Intern\r\n\r\n    // Load file, parse and construct as Component (.qml)\r\n    this.loadComponent = function(name)\r\n    {\r\n        if (name in this.components)\r\n            return this.components[name];\r\n\r\n        var file = qmlEngine.$basePath + name + \".qml\";\r\n\r\n        this.ensureFileIsLoadedInQrc(file);\r\n        tree = convertToEngine(qrc[file]);\r\n        this.components[name] = tree;\r\n        return tree;\r\n    }\r\n\r\n    this.$initializePropertyBindings = function() {\r\n        // Initialize property bindings\r\n        for (var i = 0; i < this.bindedProperties.length; i++) {\r\n            var property = this.bindedProperties[i];\r\n            property.binding.compile();\r\n            property.update();\r\n        }\r\n        this.bindedProperties = [];\r\n    }\r\n\r\n    this.$getTextMetrics = function(text, fontCss)\r\n    {\r\n        canvas.save();\r\n        canvas.font = fontCss;\r\n        var metrics = canvas.measureText(text);\r\n        canvas.restore();\r\n        return metrics;\r\n    }\r\n\r\n    // Return a path to load the file\r\n    this.$resolvePath = function(file)\r\n    {\r\n        // probably, replace :// with :/ ?\r\n        if (file == \"\" || file.indexOf(\"://\") != -1 || file.indexOf(\"/\") == 0 || file.indexOf(\"data:\") == 0 || file.indexOf(\"blob:\") == 0) {\r\n            return file;\r\n        }\r\n        return this.$basePath + file;\r\n    }\r\n\r\n    this.$registerStart = function(f)\r\n    {\r\n        whenStart.push(f);\r\n    }\r\n\r\n    this.$registerStop = function(f)\r\n    {\r\n        whenStop.push(f);\r\n    }\r\n\r\n    this.$addTicker = function(t)\r\n    {\r\n        tickers.push(t);\r\n    }\r\n\r\n    this.$removeTicker = function(t)\r\n    {\r\n        var index = tickers.indexOf(t);\r\n        if (index != -1) {\r\n            tickers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    this.size = function()\r\n    {\r\n        return { width: this.rootObject.getWidth(), height: this.rootObject.getHeight() };\r\n    }\r\n\r\n    // Performance measurements\r\n    this.$perfDraw = function(canvas)\r\n    {\r\n        this.rootObject.$draw(canvas);\r\n    }\r\n\r\n//----------Private Methods----------\r\n    // In JS we cannot easily access public members from\r\n    // private members so self acts as a bridge\r\n    var self = this;\r\n\r\n    // Listen also to touchstart events on supporting devices\r\n    // Makes clicks more responsive (do not wait for click event anymore)\r\n    function touchHandler(e)\r\n    {\r\n        // preventDefault also disables pinching and scrolling while touching\r\n        // on qml application\r\n        e.preventDefault();\r\n        var at = {\r\n            layerX: e.touches[0].pageX - element.offsetLeft,\r\n            layerY: e.touches[0].pageY - element.offsetTop,\r\n            button: 1\r\n        }\r\n        element.onclick(at);\r\n\r\n    }\r\n\r\n    function mousemoveHandler(e)\r\n    {\r\n        var i;\r\n        for (i in self.mouseAreas) {\r\n            var l = self.mouseAreas[i];\r\n            if (l && l.hoverEnabled\r\n                  && (self.oldMousePos.x >= l.left\r\n                      && self.oldMousePos.x <= l.right\r\n                      && self.oldMousePos.y >= l.top\r\n                      && self.oldMousePos.y <= l.bottom)\r\n                  && !(e.pageX - element.offsetLeft >= l.left\r\n                       && e.pageX - element.offsetLeft <= l.right\r\n                       && e.pageY - element.offsetTop >= l.top\r\n                       && e.pageY - element.offsetTop <= l.bottom) )\r\n                l.exited();\r\n        }\r\n        for (i in self.mouseAreas) {\r\n            var l = self.mouseAreas[i];\r\n            if (l && l.hoverEnabled\r\n                  && (e.pageX - element.offsetLeft >= l.left\r\n                      && e.pageX - element.offsetLeft <= l.right\r\n                      && e.pageY - element.offsetTop >= l.top\r\n                      && e.pageY - element.offsetTop <= l.bottom)\r\n                  && !(self.oldMousePos.x >= l.left\r\n                       && self.oldMousePos.x <= l.right\r\n                       && self.oldMousePos.y >= l.top\r\n                       && self.oldMousePos.y <= l.bottom))\r\n                l.entered();\r\n        }\r\n        self.oldMousePos = { x: e.pageX - element.offsetLeft,\r\n                            y: e.pageY - element.offsetTop };\r\n    }\r\n\r\n    function tick()\r\n    {\r\n        var i,\r\n            now = (new Date).getTime(),\r\n            elapsed = now - lastTick;\r\n        lastTick = now;\r\n        for (i = 0; i < tickers.length; i++) {\r\n            tickers[i](now, elapsed);\r\n        }\r\n    }\r\n\r\n\r\n//----------Private Members----------\r\n    // Target canvas\r\n    var // Callbacks for stopping or starting the engine\r\n        whenStop = [],\r\n        whenStart = [],\r\n        // Ticker resource id and ticker callbacks\r\n        tickerId,\r\n        tickers = [],\r\n        lastTick = new Date().getTime(),\r\n        i;\r\n\r\n\r\n//----------Construct----------\r\n\r\n    options = options || {};\r\n\r\n    if (options.debugConsole) {\r\n        // Replace QML-side console.log\r\n        console = {};\r\n        console.log = function() {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            options.debugConsole.apply(undefined, args);\r\n        };\r\n    }\r\n}\r\n\r\n\nfunction QMLInteger(val) {\r\n    return (val|0);\r\n}\r\n\nfunction QMLItem(meta) {\r\n    QMLBaseObject.call(this, meta);\r\n    var child,\r\n        o, i;\r\n\r\n    this.completed = Signal();\r\n    this.completedAlreadyCalled = false;\r\n\r\n    if (this.$parent === null) { // This is the root element. Initialize it.\r\n        this.dom = engine.rootElement || document.body;\r\n        this.dom.innerHTML = \"\";\r\n        var self = this;\r\n        this.dom.style.position = \"relative\"; // Needed to make absolute positioning work\r\n        this.dom.style.top = \"0\";\r\n        this.dom.style.left = \"0\";\r\n        this.dom.style.overflow = \"hidden\"; // No QML stuff should stand out the root element\r\n    } else {\r\n        if (!this.dom) // Create a dom element for this item.\r\n            this.dom = document.createElement(\"div\");\r\n        this.dom.style.position = \"absolute\";\r\n    }\r\n    this.dom.style.pointerEvents = \"none\";\r\n    this.dom.className = meta.object.$class + (this.id ? \" \" + this.id : \"\");\r\n    this.dom.qml = this;\r\n    this.css = this.dom.style;\r\n\r\n    this.css.boxSizing = 'border-box';\r\n\r\n    createSimpleProperty(\"list\", this, \"data\");\r\n    this.$defaultProperty = \"data\";\r\n    createSimpleProperty(\"list\", this, \"children\");\r\n    createSimpleProperty(\"list\", this, \"resources\");\r\n    createSimpleProperty(\"Item\", this, \"parent\");\r\n    this.children = [];\r\n    this.resources = [];\r\n    this.parentChanged.connect(this, function(newParent, oldParent) {\r\n        if (oldParent) {\r\n            oldParent.children.splice(oldParent.children.indexOf(this), 1);\r\n            oldParent.childrenChanged();\r\n            oldParent.dom.removeChild(this.dom);\r\n        }\r\n        if (newParent && newParent.children.indexOf(this) == -1) {\r\n            newParent.children.push(this);\r\n            newParent.childrenChanged();\r\n        }\r\n        if (newParent)\r\n            newParent.dom.appendChild(this.dom);\r\n    });\r\n    this.parentChanged.connect(this, updateHGeometry);\r\n    this.parentChanged.connect(this, updateVGeometry);\r\n    this.dataChanged.connect(this, function(newData) {\r\n        for (var i in newData) {\r\n            var child = newData[i];\r\n            if (child.hasOwnProperty(\"parent\")) // Seems to be an Item. TODO: Use real inheritance and ask using instanceof.\r\n                child.parent = this; // This will also add it to children.\r\n            else\r\n                this.resources.push(child);\r\n        }\r\n    });\r\n\r\n    if (this.$isComponentRoot)\r\n      createSimpleProperty(\"var\", this, \"activeFocus\");\r\n    createSimpleProperty(\"real\", this, \"x\");\r\n    createSimpleProperty(\"real\", this, \"y\");\r\n    createSimpleProperty(\"real\", this, \"width\");\r\n    createSimpleProperty(\"real\", this, \"height\");\r\n    createSimpleProperty(\"real\", this, \"implicitWidth\");\r\n    createSimpleProperty(\"real\", this, \"implicitHeight\");\r\n    createSimpleProperty(\"real\", this, \"left\");\r\n    createSimpleProperty(\"real\", this, \"right\");\r\n    createSimpleProperty(\"real\", this, \"top\");\r\n    createSimpleProperty(\"real\", this, \"bottom\");\r\n    createSimpleProperty(\"real\", this, \"horizontalCenter\");\r\n    createSimpleProperty(\"real\", this, \"verticalCenter\");\r\n    createSimpleProperty(\"real\", this, \"rotation\");\r\n    createSimpleProperty(\"real\", this, \"scale\");\r\n    createSimpleProperty(\"real\", this, \"z\");\r\n    createSimpleProperty(\"list\", this, \"transform\");\r\n    createSimpleProperty(\"bool\", this, \"visible\");\r\n    createSimpleProperty(\"real\", this, \"opacity\");\r\n    createSimpleProperty(\"bool\", this, \"clip\");\r\n    createSimpleProperty(\"bool\", this, \"focus\");\r\n    this.xChanged.connect(this, updateHGeometry);\r\n    this.yChanged.connect(this, updateVGeometry);\r\n    this.widthChanged.connect(this, updateHGeometry);\r\n    this.heightChanged.connect(this, updateVGeometry);\r\n    this.implicitWidthChanged.connect(this, updateHGeometry);\r\n    this.implicitHeightChanged.connect(this, updateVGeometry);\r\n    this.focus = false;\r\n\r\n    this.setupFocusOnDom = (function(element) {\r\n      var updateFocus = (function() {\r\n        var hasFocus = document.activeElement == this.dom || document.activeElement == this.dom.firstChild;\r\n\r\n        if (this.focus != hasFocus)\r\n          this.focus = hasFocus;\r\n      }).bind(this);\r\n      element.addEventListener(\"focus\", updateFocus);\r\n      element.addEventListener(\"blur\",  updateFocus);\r\n    }).bind(this);\r\n\r\n    this.focusChanged.connect(this, (function(newVal) {\r\n      if (newVal == true) {\r\n        if (this.dom.firstChild != null)\r\n          this.dom.firstChild.focus();\r\n        document.qmlFocus = this;\r\n        this.$context.activeFocus = this;\r\n      } else if (document.qmlFocus == this) {\r\n        document.getElementsByTagName(\"BODY\")[0].focus();\r\n        document.qmlFocus = qmlEngine.rootContext().base;\r\n        this.$context.activeFocus = null;\r\n      }\r\n    }).bind(this));\r\n\r\n    this.$isUsingImplicitWidth = true;\r\n    this.$isUsingImplicitHeight = true;\r\n\r\n    this.anchors = new QObject(this);\r\n    createSimpleProperty(\"real\", this.anchors, \"left\");\r\n    createSimpleProperty(\"real\", this.anchors, \"right\");\r\n    createSimpleProperty(\"real\", this.anchors, \"top\");\r\n    createSimpleProperty(\"real\", this.anchors, \"bottom\");\r\n    createSimpleProperty(\"real\", this.anchors, \"horizontalCenter\");\r\n    createSimpleProperty(\"real\", this.anchors, \"verticalCenter\");\r\n    createSimpleProperty(\"real\", this.anchors, \"fill\");\r\n    createSimpleProperty(\"real\", this.anchors, \"centerIn\");\r\n    createSimpleProperty(\"real\", this.anchors, \"margins\");\r\n    createSimpleProperty(\"real\", this.anchors, \"leftMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"rightMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"topMargin\");\r\n    createSimpleProperty(\"real\", this.anchors, \"bottomMargin\");\r\n    this.anchors.leftChanged.connect(this, updateHGeometry);\r\n    this.anchors.rightChanged.connect(this, updateHGeometry);\r\n    this.anchors.topChanged.connect(this, updateVGeometry);\r\n    this.anchors.bottomChanged.connect(this, updateVGeometry);\r\n    this.anchors.horizontalCenterChanged.connect(this, updateHGeometry);\r\n    this.anchors.verticalCenterChanged.connect(this, updateVGeometry);\r\n    this.anchors.fillChanged.connect(this, updateHGeometry);\r\n    this.anchors.fillChanged.connect(this, updateVGeometry);\r\n    this.anchors.centerInChanged.connect(this, updateHGeometry);\r\n    this.anchors.centerInChanged.connect(this, updateVGeometry);\r\n    this.anchors.leftMarginChanged.connect(this, updateHGeometry);\r\n    this.anchors.rightMarginChanged.connect(this, updateHGeometry);\r\n    this.anchors.topMarginChanged.connect(this, updateVGeometry);\r\n    this.anchors.bottomMarginChanged.connect(this, updateVGeometry);\r\n    this.anchors.marginsChanged.connect(this, updateHGeometry);\r\n    this.anchors.marginsChanged.connect(this, updateVGeometry);\r\n\r\n    createSimpleProperty(\"list\", this, \"states\");\r\n    createSimpleProperty(\"string\", this, \"state\");\r\n    createSimpleProperty(\"list\", this, \"transitions\");\r\n    this.stateChanged.connect(this, function(newVal, oldVal) {\r\n        var oldState, newState, i, j, k;\r\n        for (i = 0; i < this.states.length; i++)\r\n            if (this.states[i].name === newVal)\r\n                newState = this.states[i];\r\n            else if (this.states[i].name === oldVal)\r\n                oldState = this.states[i];\r\n\r\n        var actions = this.$revertActions.slice();\r\n\r\n        // Get current values for revert actions\r\n        for (i in actions) {\r\n            var action  = actions[i];\r\n            action.from = action.target[action.property];\r\n        }\r\n        if (newState) {\r\n            var changes = newState.$getAllChanges();\r\n\r\n            // Get all actions we need to do and create actions to revert them\r\n            for (i = 0; i < changes.length; i++) {\r\n                var change = changes[i];\r\n\r\n                for (j = 0; j < change.$actions.length; j++) {\r\n                    var item = change.$actions[j];\r\n\r\n                    var action = {\r\n                        target: change.target,\r\n                        property: item.property,\r\n                        origValue: change.target.$properties[item.property].binding\r\n                                    || change.target.$properties[item.property].val,\r\n                        value: item.value,\r\n                        from: change.target[item.property],\r\n                        to: undefined,\r\n                        explicit: change.explicit\r\n                    };\r\n                    var found = false;\r\n                    for (k in actions)\r\n                        if (actions[k].target == action.target\r\n                            && actions[k].property == action.property) {\r\n                            found = true;\r\n                            actions[k] = action;\r\n                            break;\r\n                        }\r\n                    if (!found)\r\n                        actions.push(action);\r\n\r\n                    // Look for existing revert action, else create it\r\n                    var found = false;\r\n                    for (k = 0; k < this.$revertActions.length; k++)\r\n                        if (this.$revertActions[k].target == change.target\r\n                            && this.$revertActions[k].property == item.property) {\r\n                            if (!change.restoreEntryValues)\r\n                                this.$revertActions.splice(k, 1); // We don't want to revert, so remove it\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    if (!found && change.restoreEntryValues)\r\n                        this.$revertActions.push({\r\n                            target: change.target,\r\n                            property: item.property,\r\n                            value: change.target.$properties[item.property].binding\r\n                                        || change.target.$properties[item.property].val,\r\n                            from: undefined,\r\n                            to: change.target[item.property]\r\n                        });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Set all property changes and fetch the actual values afterwards\r\n        // The latter is needed for transitions. We need to set all properties\r\n        // before we fetch the values because properties can be interdependent.\r\n        for (i in actions) {\r\n            var action = actions[i];\r\n            action.target.$properties[action.property].set(action.value, false, action.target,\r\n                                                           newState ? newState.$context: action.target.$context);\r\n        }\r\n        for (i in actions) {\r\n            var action = actions[i];\r\n            action.to = action.target[action.property];\r\n            if (action.explicit) {\r\n                action.target[action.property] = action.target[action.property]; //Remove binding\r\n                action.value = action.target[action.property];\r\n            }\r\n        }\r\n\r\n        // Find the best transition to use\r\n        var transition,\r\n            rating = 0;\r\n        for (var i = 0; i < this.transitions.length; i++) {\r\n            this.transitions[i].$stop(); // We need to stop running transitions, so let's do\r\n                                        // it while iterating through the transitions anyway\r\n            var curTransition = this.transitions[i],\r\n                curRating = 0;\r\n            if (curTransition.from == oldVal || curTransition.reversible && curTransition.from == newVal)\r\n                curRating += 2;\r\n            else if (curTransition.from == \"*\")\r\n                curRating++;\r\n            else\r\n                continue;\r\n            if (curTransition.to == newVal || curTransition.reversible && curTransition.to == oldVal)\r\n                curRating += 2;\r\n            else if (curTransition.to == \"*\")\r\n                curRating++;\r\n            else\r\n                continue;\r\n            if (curRating > rating) {\r\n                rating = curRating;\r\n                transition = curTransition;\r\n            }\r\n        }\r\n        if (transition)\r\n            transition.$start(actions);\r\n    });\r\n\r\n    var QMLRotation  = getConstructor('QtQuick', '2.0', 'Rotation');\r\n    var QMLScale     = getConstructor('QtQuick', '2.0', 'Scale');\r\n    var QMLTranslate = getConstructor('QtQuick', '2.0', 'Translate');\r\n\r\n    this.$updateTransform = function() {\r\n            var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\r\n            var filter = \"\";\r\n            var transformStyle = \"preserve-3d\";\r\n\r\n            for (var i = 0; i < this.transform.length; i++) {\r\n                var t = this.transform[i];\r\n                if (t instanceof QMLRotation)\r\n                    transform += \" rotate3d(\" + t.axis.x + \", \" + t.axis.y + \", \" + t.axis.z + \", \" + t.angle + \"deg)\";\r\n                else if (t instanceof QMLScale)\r\n                    transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\r\n                else if (t instanceof QMLTranslate)\r\n                    transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\r\n                else if (typeof t.transformType != 'undefined') {\r\n                    if (t.transformType == 'filter')\r\n                      filter += t.operation + '(' + t.parameters + ') ';\r\n                }\r\n                else if (typeof t == 'string')\r\n                    transform += t;\r\n            }\r\n            if (typeof this.z == \"number\")\r\n              transform += \" translate3d(0, 0, \" + this.z + \"px)\";\r\n            this.dom.style.transform = transform;\r\n            this.dom.style.transformStyle = transformStyle;\r\n            this.dom.style.MozTransform = transform;    // Firefox\r\n            this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\r\n            this.dom.style.webkitTransformStyle = transformStyle;\r\n            this.dom.style.OTransform = transform;      // Opera\r\n            this.dom.style.msTransform = transform;     // IE\r\n            this.dom.style.filter = filter;\r\n            this.dom.style.msFilter = filter;     // IE\r\n            this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\r\n            this.dom.style.MozFilter = filter;    // Firefox\r\n    }\r\n    this.rotationChanged.connect(this, this.$updateTransform);\r\n    this.scaleChanged.connect(this, this.$updateTransform);\r\n    this.transformChanged.connect(this, this.$updateTransform);\r\n    this.visibleChanged.connect(this, function(newVal) {\r\n        this.css.visibility = newVal ? \"inherit\" : \"hidden\";\r\n    });\r\n    this.opacityChanged.connect(this, function(newVal) {\r\n        this.css.opacity = newVal;\r\n    });\r\n    this.clipChanged.connect(this, function(newVal) {\r\n        this.css.overflow = newVal ? \"hidden\" : \"visible\";\r\n    });\r\n    this.zChanged.connect(this, function(newVal) {\r\n        this.$updateTransform();\r\n    });\r\n    this.xChanged.connect(this, function(newVal) {\r\n        this.css.left = newVal + \"px\";\r\n    });\r\n    this.yChanged.connect(this, function(newVal) {\r\n        this.css.top = newVal + \"px\";\r\n    });\r\n    this.widthChanged.connect(this, function(newVal) {\r\n        this.css.width = newVal ? newVal + \"px\" : \"auto\";\r\n    });\r\n    this.heightChanged.connect(this, function(newVal) {\r\n        this.css.height = newVal ? newVal + \"px\" : \"auto\";\r\n    });\r\n\r\n    this.implicitHeight = 0;\r\n    this.implicitWidth = 0;\r\n    this.spacing = 0;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.anchors.margins = 0;\r\n    this.visible = true;\r\n    this.opacity = 1;\r\n    this.$revertActions = [];\r\n    this.states = [];\r\n    this.transitions = [];\r\n    this.state = \"\";\r\n    this.transform = [];\r\n    this.rotation = 0;\r\n    this.scale = 1;\r\n\r\n    // Init size of root element\r\n    if (this.$parent === null) {\r\n        if (engine.rootElement == undefined) {\r\n            window.onresize = function() {\r\n                self.implicitHeight = window.innerHeight;\r\n                self.implicitWidth = window.innerWidth;\r\n            }\r\n            window.onresize();\r\n        } else {\r\n            this.implicitHeight = this.dom.offsetHeight;\r\n            this.implicitWidth = this.dom.offsetWidth;\r\n        }\r\n    }\r\n\r\n    this.$draw = function(c) {\r\n        var i;\r\n        if (this.visible !== false) { // Undefined means inherit, means true\r\n            if (this.$drawItem ) {\r\n                var rotRad = (this.rotation || 0) / 180 * Math.PI,\r\n                    rotOffsetX = Math.sin(rotRad) * this.width,\r\n                    rotOffsetY = Math.sin(rotRad) * this.height;\r\n                c.save();\r\n\r\n                // Handle rotation\r\n                // todo: implement transformOrigin\r\n                c.globalAlpha = this.opacity;\r\n                c.translate(this.left + rotOffsetX, this.top + rotOffsetY);\r\n                c.rotate(rotRad);\r\n                c.translate(-this.left, -this.top);\r\n                // Leave offset for drawing...\r\n                this.$drawItem(c);\r\n                c.translate(-rotOffsetX, -rotOffsetY);\r\n                c.restore();\r\n            }\r\n            for (i = 0; i < this.children.length; i++) {\r\n                if (this.children[i]\r\n                    && this.children[i].$draw) {\r\n                    this.children[i].$draw(c);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\ninherit(QMLItem, QMLBaseObject);\r\n\r\nconstructors['Item'] = QMLItem;\r\n\n\nfunction QMLList(meta) {\r\n    var list = [];\r\n    if (meta.object instanceof Array)\r\n        for (var i in meta.object)\r\n            list.push(construct({object: meta.object[i], parent: meta.parent, context: meta.context }));\r\n    else if (meta.object instanceof QMLMetaElement)\r\n        list.push(construct({object: meta.object, parent: meta.parent, context: meta.context }));\r\n\r\n    return list;\r\n}\r\n\nQMLOperationState = {\r\n    Idle: 1,\r\n    Init: 2,\r\n    Running: 3\r\n};\r\n\nfunction QMLPositioner(meta) {\r\n    QMLItem.call(this, meta);\r\n\r\n    createSimpleProperty(\"int\", this, \"spacing\");\r\n    this.spacingChanged.connect(this, this.layoutChildren);\r\n    this.childrenChanged.connect(this, this.layoutChildren);\r\n    this.childrenChanged.connect(this, QMLPositioner.slotChildrenChanged);\r\n\r\n    this.spacing = 0;\r\n}\r\ninherit(QMLPositioner, QMLItem);\r\n\r\nQMLPositioner.slotChildrenChanged = function() {\r\n    for (var i = 0; i < this.children.length; i++) {\r\n        var child = this.children[i];\r\n        if (!child.widthChanged.isConnected(this, this.layoutChildren))\r\n            child.widthChanged.connect(this, this.layoutChildren);\r\n        if (!child.heightChanged.isConnected(this, this.layoutChildren))\r\n            child.heightChanged.connect(this, this.layoutChildren);\r\n        if (!child.visibleChanged.isConnected(this, this.layoutChildren))\r\n            child.visibleChanged.connect(this, this.layoutChildren);\r\n        if (!child.opacityChanged.isConnected(this, this.layoutChildren))\r\n            child.opacityChanged.connect(this, this.layoutChildren);\r\n    }\r\n}\r\n\r\n\nfunction QMLProperty(type, obj, name) {\r\n    this.obj = obj;\r\n    this.name = name;\r\n    this.changed = Signal([], {obj:obj});\r\n    this.binding = null;\r\n    this.objectScope = null;\r\n    this.componentScope = null;\r\n    this.value = undefined;\r\n    this.type = type;\r\n    this.animation = null;\r\n\r\n    // This list contains all signals that hold references to this object.\r\n    // It is needed when deleting, as we need to tidy up all references to this object.\r\n    this.$tidyupList = [];\r\n}\r\n\r\n// Updater recalculates the value of a property if one of the\r\n// dependencies changed\r\nQMLProperty.prototype.update = function() {\r\n    if (!this.binding)\r\n        return;\r\n\r\n    var oldVal = this.val;\r\n    evaluatingProperty = this;\r\n    this.val = this.binding.eval(this.objectScope, this.componentScope);\r\n    evaluatingProperty = undefined;\r\n\r\n    if (this.animation) {\r\n        this.animation.$actions = [{\r\n            target: this.animation.target || this.obj,\r\n            property: this.animation.property || this.name,\r\n            from: this.animation.from || oldVal,\r\n            to: this.animation.to || this.val\r\n        }];\r\n        this.animation.restart();\r\n    }\r\n\r\n    if (this.val !== oldVal)\r\n        this.changed(this.val, oldVal, this.name);\r\n}\r\n\r\n// Define getter\r\nQMLProperty.prototype.get = function() {\r\n    // If this call to the getter is due to a property that is dependant on this\r\n    // one, we need it to take track of changes\r\n    if (evaluatingProperty && !this.changed.isConnected(evaluatingProperty, QMLProperty.prototype.update))\r\n        this.changed.connect(evaluatingProperty, QMLProperty.prototype.update);\r\n\r\n    return this.val;\r\n}\r\n\r\n// Define setter\r\nQMLProperty.prototype.set = function(newVal, fromAnimation, objectScope, componentScope) {\r\n    var i,\r\n        oldVal = this.val;\r\n\r\n    if (newVal instanceof QMLBinding) {\r\n        if (!objectScope || !componentScope)\r\n            throw \"Internal error: binding assigned without scope\";\r\n        this.binding = newVal;\r\n        this.objectScope = objectScope;\r\n        this.componentScope = componentScope;\r\n\r\n        if (engine.operationState !== QMLOperationState.Init) {\r\n            if (!newVal.eval)\r\n                newVal.compile();\r\n\r\n            evaluatingProperty = this;\r\n            newVal = this.binding.eval(objectScope, componentScope);\r\n            evaluatingProperty = null;\r\n        } else {\r\n            engine.bindedProperties.push(this);\r\n            return;\r\n        }\r\n    } else {\r\n        if (!fromAnimation)\r\n            this.binding = null;\r\n        if (newVal instanceof Array)\r\n            newVal = newVal.slice(); // Copies the array\r\n    }\r\n\r\n    if (constructors[this.type] == QMLList) {\r\n        this.val = QMLList({ object: newVal, parent: this.obj, context: componentScope });\r\n    } else if (newVal instanceof QMLMetaElement) {\r\n        if (constructors[newVal.$class] == QMLComponent || constructors[this.type] == QMLComponent)\r\n            this.val = new QMLComponent({ object: newVal, parent: this.obj, context: componentScope });\r\n        else\r\n            this.val = construct({ object: newVal, parent: this.obj, context: componentScope });\r\n    } else if (newVal instanceof Object || !newVal) {\r\n        this.val = newVal;\r\n    } else {\r\n        this.val = constructors[this.type](newVal);\r\n    }\r\n\r\n    if (this.val !== oldVal) {\r\n        if (this.animation && !fromAnimation) {\r\n            this.animation.running = false;\r\n            this.animation.$actions = [{\r\n                target: this.animation.target || this.obj,\r\n                property: this.animation.property || this.name,\r\n                from: this.animation.from || oldVal,\r\n                to: this.animation.to || this.val\r\n            }];\r\n            this.animation.running = true;\r\n        }\r\n        if (this.obj.$syncPropertyToRemote instanceof Function && !fromAnimation) { // is a remote object from e.g. a QWebChannel\r\n            this.obj.$syncPropertyToRemote(this.name, newVal);\r\n        } else {\r\n            this.changed(this.val, oldVal, this.name);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\nfunction QMLPropertyChanges(meta) {\r\n    QMLBaseObject.call(this, meta);\r\n\r\n    createSimpleProperty(\"QtObject\", this, \"target\");\r\n    createSimpleProperty(\"bool\", this, \"explicit\");\r\n    createSimpleProperty(\"bool\", this, \"restoreEntryValues\");\r\n\r\n    this.explicit = false;\r\n    this.restoreEntryValues = true;\r\n    this.$actions = [];\r\n\r\n    this.$setCustomData = function(propName, value) {\r\n        this.$actions.push({\r\n            property: propName,\r\n            value: value\r\n        });\r\n    }\r\n}\r\ninherit(QMLPropertyChanges, QMLBaseObject);\r\n\r\nregisterQmlType('PropertyChanges', QMLPropertyChanges);\r\n\nfunction QMLVariant(val) {\r\n    return val;\r\n}\r\n\n// Base object for all qml thingies\r\nvar objectIds = 0;\r\nfunction QObject(parent) {\r\n    this.$parent = parent;\r\n    if (parent && parent.$tidyupList)\r\n        parent.$tidyupList.push(this);\r\n    // List of things to tidy up when deleting this object.\r\n    this.$tidyupList = [];\r\n    this.$properties = {};\r\n\r\n    this.objectId = objectIds++;\r\n    this.$delete = function() {\r\n        if (this.$Component)\r\n          this.$Component.destruction();\r\n\r\n        while (this.$tidyupList.length > 0) {\r\n            var item = this.$tidyupList[0];\r\n            if (item.$delete) // It's a QObject\r\n                item.$delete();\r\n            else // It must be a signal\r\n                item.disconnect(this);\r\n        }\r\n\r\n        for (var i in this.$properties) {\r\n            var prop = this.$properties[i];\r\n            while (prop.$tidyupList.length > 0)\r\n                prop.$tidyupList[0].disconnect(prop);\r\n        }\r\n\r\n        if (this.$parent && this.$parent.$tidyupList)\r\n            this.$parent.$tidyupList.splice(this.$parent.$tidyupList.indexOf(this), 1);\r\n\r\n        // must do this:\r\n        // 1) parent will be notified and erase object from it's children.\r\n        // 2) DOM node will be removed.\r\n        this.parent = undefined;\r\n    }\r\n}\r\n\nfunction updateHGeometry(newVal, oldVal, propName) {\r\n    var anchors = this.anchors || this;\r\n    if (this.$updatingGeometry)\r\n        return;\r\n    this.$updatingGeometry = true;\r\n\r\n    var t, w, width, x, left, hC, right,\r\n        lM = anchors.leftMargin || anchors.margins,\r\n        rM = anchors.rightMargin || anchors.margins;\r\n\r\n    // Width\r\n    if (this.$isUsingImplicitWidth && propName == \"implicitWidth\")\r\n        width = this.implicitWidth;\r\n    else if (propName == \"width\")\r\n        this.$isUsingImplicitWidth = false;\r\n\r\n    // Position TODO: Layouts\r\n    if ((t = anchors.fill) !== undefined) {\r\n        if (!t.$properties.left.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.left.changed.connect(this, updateHGeometry);\r\n        if (!t.$properties.width.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.width.changed.connect(this, updateHGeometry);\r\n\r\n        this.$isUsingImplicitWidth = false;\r\n        width = t.width - lM - rM;\r\n        x = t.left - (this.parent ? this.parent.left : 0) + lM;\r\n        left = t.left + lM;\r\n        right = t.right - rM;\r\n        hC = (left + right) / 2;\r\n    } else if ((t = anchors.centerIn) !== undefined) {\r\n        if (!t.$properties.horizontalCenter.changed.isConnected(this, updateHGeometry))\r\n            t.$properties.horizontalCenter.changed.connect(this, updateHGeometry);\r\n\r\n        w = width || this.width;\r\n        hC = t.horizontalCenter;\r\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\r\n        left = hC - w / 2;\r\n        right = hC + w / 2;\r\n    } else if ((t = anchors.left) !== undefined) {\r\n        left = t + lM\r\n        if ((u = anchors.right) !== undefined) {\r\n            right = u - rM;\r\n            this.$isUsingImplicitWidth = false;\r\n            width = right - left;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            hC = (right + left) / 2;\r\n        } else if ((hC = anchors.horizontalCenter) !== undefined) {\r\n            this.$isUsingImplicitWidth = false;\r\n            width = (hC - left) * 2;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            right = 2 * hC - left;\r\n        } else {\r\n            w = width || this.width;\r\n            x = left - (this.parent ? this.parent.left : 0);\r\n            right = left + w;\r\n            hC = left + w / 2;\r\n        }\r\n    } else if ((t = anchors.right) !== undefined) {\r\n        right = t - rM;\r\n        if ((hC = anchors.horizontalCenter) !== undefined) {\r\n            this.$isUsingImplicitWidth = false;\r\n            width = (right - hC) * 2;\r\n            x = 2 * hC - right - (this.parent ? this.parent.left : 0);\r\n            left = 2 * hC - right;\r\n        } else {\r\n            w = width || this.width;\r\n            x = right - w - (this.parent ? this.parent.left : 0);\r\n            left = right - w;\r\n            hC = right - w / 2;\r\n        }\r\n    } else if ((hC = anchors.horizontalCenter) !== undefined) {\r\n        w = width || this.width;\r\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\r\n        left = hC - w / 2;\r\n        right = hC + w / 2;\r\n    } else {\r\n        if (this.parent && !this.parent.$properties.left.changed.isConnected(this, updateHGeometry))\r\n            this.parent.$properties.left.changed.connect(this, updateHGeometry);\r\n\r\n        w = width || this.width;\r\n        left = this.x + (this.parent ? this.parent.left : 0);\r\n        right = left + w;\r\n        hC = left + w / 2;\r\n    }\r\n\r\n    if (left !== undefined)\r\n        this.left = left;\r\n    if (hC !== undefined)\r\n        this.horizontalCenter = hC;\r\n    if (right !== undefined)\r\n        this.right = right;\r\n    if (x !== undefined)\r\n        this.x = x;\r\n    if (width !== undefined)\r\n        this.width = width;\r\n\r\n    this.$updatingGeometry = false;\r\n}\r\n\r\nfunction updateVGeometry(newVal, oldVal, propName) {\r\n    var anchors = this.anchors || this;\r\n    if (this.$updatingGeometry)\r\n        return;\r\n    this.$updatingGeometry = true;\r\n\r\n    var t, w, height, y, top, vC, bottom,\r\n        tM = anchors.topMargin || anchors.margins,\r\n        bM = anchors.bottomMargin || anchors.margins;\r\n\r\n    // Height\r\n    if (this.$isUsingImplicitHeight && propName == \"implicitHeight\")\r\n        height = this.implicitHeight;\r\n    else if (propName == \"height\")\r\n        this.$isUsingImplicitHeight = false;\r\n\r\n    // Position TODO: Layouts\r\n    if ((t = anchors.fill) !== undefined) {\r\n        if (!t.$properties.top.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.top.changed.connect(this, updateVGeometry);\r\n        if (!t.$properties.height.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.height.changed.connect(this, updateVGeometry);\r\n\r\n        this.$isUsingImplicitHeight = false;\r\n        height = t.height - tM - bM;\r\n        y = t.top - (this.parent ? this.parent.top : 0) + tM;\r\n        top = t.top + tM;\r\n        bottom = t.bottom - bM;\r\n        vC = (top + bottom) / 2;\r\n    } else if ((t = anchors.centerIn) !== undefined) {\r\n        if (!t.$properties.verticalCenter.changed.isConnected(this, updateVGeometry))\r\n            t.$properties.verticalCenter.changed.connect(this, updateVGeometry);\r\n\r\n        w = height || this.height;\r\n        vC = t.verticalCenter;\r\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\r\n        top = vC - w / 2;\r\n        bottom = vC + w / 2;\r\n    } else if ((t = anchors.top) !== undefined) {\r\n        top = t + tM\r\n        if ((u = anchors.bottom) !== undefined) {\r\n            bottom = u - bM;\r\n            this.$isUsingImplicitHeight = false;\r\n            height = bottom - top;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            vC = (bottom + top) / 2;\r\n        } else if ((vC = anchors.verticalCenter) !== undefined) {\r\n            this.$isUsingImplicitHeight = false;\r\n            height = (vC - top) * 2;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            bottom = 2 * vC - top;\r\n        } else {\r\n            w = height || this.height;\r\n            y = top - (this.parent ? this.parent.top : 0);\r\n            bottom = top + w;\r\n            vC = top + w / 2;\r\n        }\r\n    } else if ((t = anchors.bottom) !== undefined) {\r\n        bottom = t - bM;\r\n        if ((vC = anchors.verticalCenter) !== undefined) {\r\n            this.$isUsingImplicitHeight = false;\r\n            height = (bottom - vC) * 2;\r\n            y = 2 * vC - bottom - (this.parent ? this.parent.top : 0);\r\n            top = 2 * vC - bottom;\r\n        } else {\r\n            w = height || this.height;\r\n            y = bottom - w - (this.parent ? this.parent.top : 0);\r\n            top = bottom - w;\r\n            vC = bottom - w / 2;\r\n        }\r\n    } else if ((vC = anchors.verticalCenter) !== undefined) {\r\n        w = height || this.height;\r\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\r\n        top = vC - w / 2;\r\n        bottom = vC + w / 2;\r\n    } else {\r\n        if (this.parent && !this.parent.$properties.top.changed.isConnected(this, updateVGeometry))\r\n            this.parent.$properties.top.changed.connect(this, updateVGeometry);\r\n\r\n        w = height || this.height;\r\n        top = this.y + (this.parent ? this.parent.top : 0);\r\n        bottom = top + w;\r\n        vC = top + w / 2;\r\n    }\r\n\r\n    if (top !== undefined)\r\n        this.top = top;\r\n    if (vC !== undefined)\r\n        this.verticalCenter = vC;\r\n    if (bottom !== undefined)\r\n        this.bottom = bottom;\r\n    if (y !== undefined)\r\n        this.y = y;\r\n    if (height !== undefined)\r\n        this.height = height;\r\n\r\n    this.$updatingGeometry = false;\r\n}\r\n\r\n\r\n\nregisterQmlType({\r\n  module:   'QmlWeb',\r\n  name:     'RestModel',\r\n  versions: /.*/,\r\n  baseClass: QMLItem,\r\n  constructor: function QMLRestModel(meta) {\r\n    QMLItem.call(this, meta);\r\n    var self = this;\r\n    var attributes = this.getAttributes();\r\n\r\n    createSimpleProperty(\"string\", this, \"url\");\r\n    createSimpleProperty(\"bool\",   this, \"isLoading\");\r\n    createSimpleProperty(\"string\", this, \"mimeType\");\r\n    createSimpleProperty(\"string\", this, \"queryMimeType\");\r\n\r\n    this.mimeType      = \"application/json\";\r\n    this.queryMimeType = \"application/x-www-urlencoded\";\r\n    this.isLoading     = false;\r\n    this.attributes    = attributes;\r\n\r\n    this.fetched = Signal();\r\n    this.saved   = Signal();\r\n\r\n    this.runningRequests = 0;\r\n\r\n    this.fetch = function() {\r\n      ajax({\r\n        method:   'GET',\r\n        mimeType: self.mimetype,\r\n        success: function(xhr) {\r\n          xhrReadResponse(xhr);\r\n          self.fetched();\r\n        }\r\n      });\r\n    };\r\n\r\n    this.create = function() {\r\n      sendToServer('POST');\r\n    };\r\n\r\n    this.save = function() {\r\n      sendToServer('PUT');\r\n    };\r\n\r\n    function sendToServer(method) {\r\n      var body = generateBodyForPostQuery();\r\n\r\n      ajax({\r\n        method:   method,\r\n        mimeType: self.queryMimeType,\r\n        body:     body,\r\n        success:  function(xhr) {\r\n          xhrReadResponse(xhr);\r\n          self.saved();\r\n        }\r\n      });\r\n    }\r\n\r\n    this.remove = function() {\r\n      ajax({\r\n        method: 'DELETE',\r\n        success: function(xhr) {\r\n          self.destroy();\r\n        }\r\n      });\r\n    };\r\n\r\n    function generateBodyForPostQuery() {\r\n      var object     = {};\r\n      var body;\r\n\r\n      for (var i = 0 ; i < self.attributes.length ; ++i)\r\n        object[self.attributes[i]] = self.$properties[self.attributes[i]].get();\r\n      console.log(object);\r\n      if (self.queryMimeType == 'application/json' || self.queryMimeType == 'text/json')\r\n        body = JSON.stringify(object);\r\n      else if (self.queryMimeType == 'application/x-www-urlencoded')\r\n        body = objectToUrlEncoded(object);\r\n      return body;\r\n    }\r\n\r\n    function myEncodeURIComponent(str) {\r\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\r\n        return '%' + c.charCodeAt(0).toString(16);\r\n      });\r\n    }\r\n\r\n    function objectToUrlEncoded(object, prefix) {\r\n      var str = '';\r\n      for (var key in object) {\r\n        if (object.hasOwnProperty(key)) {\r\n          var value = object[key];\r\n          if (str != '')\r\n            str += '&';\r\n          if (typeof prefix != 'undefined')\r\n            key  = prefix + '[' + key + ']';\r\n          if (typeof value == 'object')\r\n            str += objectToUrlEncoded(value, key);\r\n          else\r\n            str += myEncodeURIComponent(key) + '=' + myEncodeURIComponent(value);\r\n        }\r\n      }\r\n      return str;\r\n    }\r\n\r\n    function ajax(options) {\r\n      var xhr = new XMLHttpRequest();\r\n\r\n      xhr.overrideMimeType(self.mimeType);\r\n      xhr.onreadystatechange = function() {\r\n        if (xhr.readyState == XMLHttpRequest.DONE) {\r\n          if (xhr.status == 200)\r\n            options.success(xhr);\r\n          else\r\n            options.failure(xhr);\r\n          self.runningRequests -= 1;\r\n          if (self.runningRequests <= 0)\r\n            self.isLoading = false;\r\n        }\r\n      }\r\n      xhr.open(options.method, self.url, true);\r\n      if (typeof options.body != 'undefined') {\r\n        xhr.setRequestHeader('Content-Type', self.queryMimeType);\r\n        xhr.send(options.body);\r\n      }\r\n      else\r\n        xhr.send(null);\r\n      self.runningRequests += 1;\r\n      self.isLoading = true;\r\n    }\r\n\r\n    function xhrReadResponse(xhr) {\r\n      var responseObject;\r\n\r\n      if (self.mimeType == 'application/json' || self.mimeType == 'text/json') {\r\n        responseObject = JSON.parse(xhr.responseText);\r\n      }\r\n      updatePropertiesFromResponseObject(responseObject);\r\n    }\r\n\r\n    function updatePropertiesFromResponseObject(responseObject) {\r\n      for (var key in responseObject) {\r\n        if (responseObject.hasOwnProperty(key) && self.$hasProperty(key)) {\r\n          self.$properties[key].set(responseObject[key]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.$hasProperty = function(name) {\r\n      return (typeof self.$properties[name] != 'undefined');\r\n    }\r\n  }\r\n});\r\n\nregisterQmlType({\r\n  module: 'QtQuick',\r\n  name:   'Settings',\r\n  versions: /.*/,\r\n  baseClass: QMLItem,\r\n  constructor: function QMLSettings(meta) {\r\n    QMLItem.call(this, meta);\r\n\r\n    createSimpleProperty(\"string\", this, \"category\");\r\n\r\n    if (typeof window.localStorage == 'undefined')\r\n      return ;\r\n\r\n    var attributes;\r\n\r\n    var getKey = (function(attrName) {\r\n      return this.category + '/' + attrName;\r\n    }).bind(this);\r\n\r\n    var loadProperties = (function() {\r\n      for (var i = 0 ; i < attributes.length ; ++i) {\r\n        this[attributes[i]] = localStorage.getItem(getKey(attributes[i]));\r\n      }\r\n    }).bind(this);\r\n\r\n    var initializeProperties = (function() {\r\n      for (var i = 0 ; i < attributes.length ; ++i) {\r\n        var attrName   = attributes[i];\r\n        var signalName = attrName + 'Changed';\r\n        var emitter    = this;\r\n\r\n        if (this.$properties[attrName].type == 'alias') {\r\n          emitter    = this.$context[this.$properties[attrName].val.objectName];\r\n          signalName = this.$properties[attrName].val.propertyName + 'Changed';\r\n        }\r\n        emitter[signalName].connect(this, (function() {\r\n          localStorage.setItem(getKey(this.attrName), this.self[this.attrName]);\r\n        }).bind({ self: this, attrName: attrName }));\r\n      }\r\n    }).bind(this);\r\n\r\n    this.Component.completed.connect(this, (function() {\r\n      attributes = this.getAttributes();\r\n      loadProperties();\r\n      initializeProperties();\r\n    }).bind(this));\r\n  }\r\n});\r\n\n})(typeof global != 'undefined' ? global : typeof window != 'undefined' ? window : this);"],"sourceRoot":"/source/"}